(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["front"] = factory();
	else
		root["DiveSDK"] = root["DiveSDK"] || {}, root["DiveSDK"]["front"] = factory();
})(this, function() {
return webpackJsonpDiveSDK__name_([0],{

/***/ 17:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(523));
__export(__webpack_require__(524));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "index.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 20:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(614));
__export(__webpack_require__(615));
__export(__webpack_require__(616));
__export(__webpack_require__(617));
__export(__webpack_require__(618));
__export(__webpack_require__(619));
__export(__webpack_require__(620));
__export(__webpack_require__(621));
__export(__webpack_require__(622));
__export(__webpack_require__(623));
__export(__webpack_require__(624));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "index.ts" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 266:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var environment = "PRE";
var enableRollbar = false;
exports.SESSION_STORAGE_KEY = 'DiveState';
exports.DIVE_ENVIRONMENT = environment;
exports.ENABLE_ROLLBAR = enableRollbar;
exports.SUPPORTED_CARD_TYPES = ["movie", "serie", "person", "character", "vehicle", "fashion", "location", "historic", "trivia", "quote", "ost", "home", "technology", "art", "song", "weapon", "leisure_sport", "health_beauty", "food_drink", "fauna_flora", "business", "reference", "chapter"];

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "constants.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 267:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(527));
__export(__webpack_require__(551));
__export(__webpack_require__(552));
__export(__webpack_require__(625));
__export(__webpack_require__(626));
__export(__webpack_require__(627));
__export(__webpack_require__(628));
__export(__webpack_require__(629));
__export(__webpack_require__(630));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "index.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 276:
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 31);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(42);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(41)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module dependencies.
 */

var keys = __webpack_require__(52);
var hasBinary = __webpack_require__(16);
var sliceBuffer = __webpack_require__(53);
var after = __webpack_require__(54);
var utf8 = __webpack_require__(55);

var base64encoder;
if (global && global.ArrayBuffer) {
  base64encoder = __webpack_require__(56);
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = __webpack_require__(57);

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),
/* 5 */
/***/ (function(module, exports) {


module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var debug = __webpack_require__(1)('socket.io-parser');
var Emitter = __webpack_require__(2);
var hasBin = __webpack_require__(16);
var binary = __webpack_require__(45);
var isBuf = __webpack_require__(17);

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  if ((obj.type === exports.EVENT || obj.type === exports.ACK) && hasBin(obj.data)) {
    obj.type = obj.type === exports.EVENT ? exports.BINARY_EVENT : exports.BINARY_ACK;
  }

  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    str += JSON.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    p = tryParse(p, str.substr(i));
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(p, str) {
  try {
    p.data = JSON.parse(str);
  } catch(e){
    return error();
  }
  return p; 
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error() {
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// browser shim for xmlhttprequest module

var hasCORS = __webpack_require__(50);

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var parser = __webpack_require__(3);
var Emitter = __webpack_require__(2);

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};


/***/ }),
/* 9 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(12)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(32);
exports.encode = exports.stringify = __webpack_require__(33);


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/* global Blob File */

/*
 * Module requirements.
 */

var isArray = __webpack_require__(44);

var toString = Object.prototype.toString;
var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof global.Buffer === 'function' && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
     (typeof global.ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
     (withNativeBlob && obj instanceof Blob) ||
     (withNativeFile && obj instanceof File)
    ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var eio = __webpack_require__(47);
var Socket = __webpack_require__(23);
var Emitter = __webpack_require__(2);
var parser = __webpack_require__(6);
var on = __webpack_require__(24);
var bind = __webpack_require__(25);
var debug = __webpack_require__(1)('socket.io-client:manager');
var indexOf = __webpack_require__(22);
var Backoff = __webpack_require__(63);

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module dependencies
 */

var XMLHttpRequest = __webpack_require__(7);
var XHR = __webpack_require__(51);
var JSONP = __webpack_require__(58);
var websocket = __webpack_require__(59);

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var Transport = __webpack_require__(8);
var parseqs = __webpack_require__(4);
var parser = __webpack_require__(3);
var inherit = __webpack_require__(5);
var yeast = __webpack_require__(21);
var debug = __webpack_require__(1)('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = __webpack_require__(7);
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;


/***/ }),
/* 22 */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parser = __webpack_require__(6);
var Emitter = __webpack_require__(2);
var toArray = __webpack_require__(62);
var on = __webpack_require__(24);
var bind = __webpack_require__(25);
var debug = __webpack_require__(1)('socket.io-client:socket');
var parseqs = __webpack_require__(4);

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = { type: parser.EVENT, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  if (packet.nsp !== this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};


/***/ }),
/* 24 */
/***/ (function(module, exports) {


/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}


/***/ }),
/* 25 */
/***/ (function(module, exports) {

/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};


/***/ }),
/* 26 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(28);
var defined = __webpack_require__(29);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(80);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 29 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 30 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable
/**
 * Dive REST API
 * Dive third party REST API provides a set of services which leverage obtaining catalog and TV grid info, contextual items (cards) information and saving and a static (scene by scene) version of the card carousel for linear TV and video on demand
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var querystring = __webpack_require__(13);
var url = __webpack_require__(34);
var fetch_iso = __webpack_require__(37);
var io = __webpack_require__(39);
var assign = __webpack_require__(64);
var BASE_PATH = "https://rest.dive.tv/v1".replace(/\/+$/, "");
var BaseAPI = /** @class */ (function () {
    function BaseAPI(basePath, fetch) {
        if (basePath === void 0) { basePath = BASE_PATH; }
        if (fetch === void 0) { fetch = fetch_iso; }
        this.basePath = basePath;
        this.fetch = fetch;
    }
    return BaseAPI;
}());
exports.BaseAPI = BaseAPI;
/**
* DefaultApi - fetch parameter creator
*/
exports.DefaultApiFetchParamCreator = {
    /**
    * Delete card like
    * Removes a card from current user&#39;s likes list
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Requested card ID
    * @param acceptLanguage Client locale, as language-country
    */
    deleteLikes: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling deleteLikes");
        }
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling deleteLikes");
        }
        var baseUrl = "/likes/{card_id}"
            .replace("{" + "card_id" + "}", "" + params["cardId"]);
        var urlObj = url.parse(baseUrl, true);
        var fetchOptions = assign({}, { method: "DELETE" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);fetchOptions.headers.append("Authorization", params["authorization"]);
        */
        fetchOptions.headers = assign({
            "Accept-Language": params["acceptLanguage"], "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Full card detail
    * Retrieves a full card detail, with no relations or context
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Unique identifier for this card
    * @param acceptLanguage Client locale, as language-country
    * @param products Indicates if cards should contain commercial products when available (true) or not (false)
    * @param userData Indicates if cards should contain user data when available (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    getCard: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getCard");
        }
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling getCard");
        }
        var baseUrl = "/cards/{card_id}"
            .replace("{" + "card_id" + "}", "" + params["cardId"]);
        var urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "products": params["products"],
            "user_data": params["userData"],
            "image_size": params["imageSize"],
        });
        var fetchOptions = assign({}, { method: "GET" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Authorization", params["authorization"]);fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);
        */
        fetchOptions.headers = assign({
            "Authorization": params["authorization"], "Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Full card detail with version
    * Retrieves a full card detail, and its relations to other cards in a given context (card version)
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Unique identifier for this card
    * @param version Version identifier, indicates the context where the card is being requested
    * @param acceptLanguage Client locale, as language-country
    * @param products Indicates if cards should contain commercial products when available (true) or not (false)
    * @param userData Indicates if cards should contain user data when available (true) or not (false)
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    getCardVersion: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getCardVersion");
        }
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling getCardVersion");
        }
        // verify required parameter "version" is set
        if (params["version"] == null) {
            throw new Error("Missing required parameter version when calling getCardVersion");
        }
        var baseUrl = "/cards/{card_id}/versions/{version}"
            .replace("{" + "card_id" + "}", "" + params["cardId"])
            .replace("{" + "version" + "}", "" + params["version"]);
        var urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "products": params["products"],
            "user_data": params["userData"],
            "relations": params["relations"],
            "image_size": params["imageSize"],
        });
        var fetchOptions = assign({}, { method: "GET" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Authorization", params["authorization"]);fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);
        */
        fetchOptions.headers = assign({
            "Authorization": params["authorization"], "Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Movie catalog info
    * Retrieves a movie&#39;s full card by its client ID, including catalog and cast information
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieId Client movie ID being played
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    getCatalogMovie: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getCatalogMovie");
        }
        // verify required parameter "clientMovieId" is set
        if (params["clientMovieId"] == null) {
            throw new Error("Missing required parameter clientMovieId when calling getCatalogMovie");
        }
        var baseUrl = "/movies/{client_movie_id}"
            .replace("{" + "client_movie_id" + "}", "" + params["clientMovieId"]);
        var urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "image_size": params["imageSize"],
        });
        var fetchOptions = assign({}, { method: "GET" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Authorization", params["authorization"]);fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);
        */
        fetchOptions.headers = assign({
            "Authorization": params["authorization"], "Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Channel events grid
    * Returns the current and upcoming grid of TV events for the given channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    getChannelGrid: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getChannelGrid");
        }
        // verify required parameter "channelId" is set
        if (params["channelId"] == null) {
            throw new Error("Missing required parameter channelId when calling getChannelGrid");
        }
        var baseUrl = "/channels/{channel_id}/grid"
            .replace("{" + "channel_id" + "}", "" + params["channelId"]);
        var urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "image_size": params["imageSize"],
        });
        var fetchOptions = assign({}, { method: "GET" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Authorization", params["authorization"]);fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);
        */
        fetchOptions.headers = assign({
            "Authorization": params["authorization"], "Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Channel movie catalog info
    * Retrieves full card detail, including catalog and cast information, for the content currently being broadcasted on the channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    getChannelMovie: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getChannelMovie");
        }
        // verify required parameter "channelId" is set
        if (params["channelId"] == null) {
            throw new Error("Missing required parameter channelId when calling getChannelMovie");
        }
        var baseUrl = "/channels/{channel_id}"
            .replace("{" + "channel_id" + "}", "" + params["channelId"]);
        var urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "image_size": params["imageSize"],
        });
        var fetchOptions = assign({}, { method: "GET" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Authorization", params["authorization"]);fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);
        */
        fetchOptions.headers = assign({
            "Authorization": params["authorization"], "Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Get card likes
    * Returns a paginated list of cards liked by current user
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    * @param paginateKey Paginate key
    * @param size Number of desired results
    */
    getLikes: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getLikes");
        }
        var baseUrl = "/likes";
        var urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "image_size": params["imageSize"],
            "paginate_key": params["paginateKey"],
            "size": params["size"],
        });
        var fetchOptions = assign({}, { method: "GET" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);fetchOptions.headers.append("Authorization", params["authorization"]);
        */
        fetchOptions.headers = assign({
            "Accept-Language": params["acceptLanguage"], "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Channel sync availability
    * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelIdList List of client channel IDs as a comma separated list
    * @param acceptLanguage Client locale, as language-country
    */
    getReadyChannels: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getReadyChannels");
        }
        // verify required parameter "channelIdList" is set
        if (params["channelIdList"] == null) {
            throw new Error("Missing required parameter channelIdList when calling getReadyChannels");
        }
        var baseUrl = "/channels/{channel_id_list}/ready"
            .replace("{" + "channel_id_list" + "}", "" + params["channelIdList"]);
        var urlObj = url.parse(baseUrl, true);
        var fetchOptions = assign({}, { method: "GET" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Authorization", params["authorization"]);fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);
        */
        fetchOptions.headers = assign({
            "Authorization": params["authorization"], "Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Movie sync availability
    * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
    * @param acceptLanguage Client locale, as language-country
    */
    getReadyMovies: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getReadyMovies");
        }
        // verify required parameter "clientMovieIdList" is set
        if (params["clientMovieIdList"] == null) {
            throw new Error("Missing required parameter clientMovieIdList when calling getReadyMovies");
        }
        var baseUrl = "/movies/{client_movie_id_list}/ready"
            .replace("{" + "client_movie_id_list" + "}", "" + params["clientMovieIdList"]);
        var urlObj = url.parse(baseUrl, true);
        var fetchOptions = assign({}, { method: "GET" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Authorization", params["authorization"]);fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);
        */
        fetchOptions.headers = assign({
            "Authorization": params["authorization"], "Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Static channel scene
    * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    getStaticChannelScene: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getStaticChannelScene");
        }
        // verify required parameter "channelId" is set
        if (params["channelId"] == null) {
            throw new Error("Missing required parameter channelId when calling getStaticChannelScene");
        }
        var baseUrl = "/channels/{channel_id}/static"
            .replace("{" + "channel_id" + "}", "" + params["channelId"]);
        var urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "relations": params["relations"],
            "image_size": params["imageSize"],
        });
        var fetchOptions = assign({}, { method: "GET" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Authorization", params["authorization"]);fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);
        */
        fetchOptions.headers = assign({
            "Authorization": params["authorization"], "Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Static VOD scene
    * Retrieves the current list of cards related to the given movie scene
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieId Client movie ID being played
    * @param timestamp Current movie timestamp in seconds
    * @param acceptLanguage Client locale, as language-country
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    getStaticMovieScene: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling getStaticMovieScene");
        }
        // verify required parameter "clientMovieId" is set
        if (params["clientMovieId"] == null) {
            throw new Error("Missing required parameter clientMovieId when calling getStaticMovieScene");
        }
        // verify required parameter "timestamp" is set
        if (params["timestamp"] == null) {
            throw new Error("Missing required parameter timestamp when calling getStaticMovieScene");
        }
        var baseUrl = "/movies/{client_movie_id}/static/{timestamp}"
            .replace("{" + "client_movie_id" + "}", "" + params["clientMovieId"])
            .replace("{" + "timestamp" + "}", "" + params["timestamp"]);
        var urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "relations": params["relations"],
            "image_size": params["imageSize"],
        });
        var fetchOptions = assign({}, { method: "GET" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Authorization", params["authorization"]);fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);
        */
        fetchOptions.headers = assign({
            "Authorization": params["authorization"], "Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Add card like
    * Stores a card under current user&#39;s likes list
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Requested card ID
    * @param acceptLanguage Client locale, as language-country
    */
    postLikes: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling postLikes");
        }
        // verify required parameter "cardId" is set
        if (params["cardId"] == null) {
            throw new Error("Missing required parameter cardId when calling postLikes");
        }
        var baseUrl = "/likes/{card_id}"
            .replace("{" + "card_id" + "}", "" + params["cardId"]);
        var urlObj = url.parse(baseUrl, true);
        var fetchOptions = assign({}, { method: "POST" }, options);
        var contentTypeHeader = {};
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);fetchOptions.headers.append("Authorization", params["authorization"]);
        */
        fetchOptions.headers = assign({
            "Accept-Language": params["acceptLanguage"], "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
    * Token endpoint
    * The token endpoint is used to obtain access tokens which allow clients to make API requests
    * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
    * @param grantType Grant type used to obtain the token.
    * @param acceptLanguage Client locale, as language-country
    * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
    * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
    */
    postToken: function (params, options) {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling postToken");
        }
        // verify required parameter "grantType" is set
        if (params["grantType"] == null) {
            throw new Error("Missing required parameter grantType when calling postToken");
        }
        var baseUrl = "/token";
        var urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "grant_type": params["grantType"],
        });
        var fetchOptions = assign({}, { method: "POST" }, options);
        var contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "device_id": params["deviceId"],
            "refresh_token": params["refreshToken"],
        });
        /*
        fetchOptions.headers = new Headers();
        fetchOptions.headers.append("Authorization", params["authorization"]);fetchOptions.headers.append("Accept-Language", params["acceptLanguage"]);
        */
        fetchOptions.headers = assign({
            "Authorization": params["authorization"], "Accept-Language": params["acceptLanguage"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
* DefaultApi - functional programming interface
*/
exports.DefaultApiFp = {
    /**
    * Delete card like
    * Removes a card from current user&#39;s likes list
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Requested card ID
    * @param acceptLanguage Client locale, as language-country
    */
    deleteLikes: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.deleteLikes(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Full card detail
    * Retrieves a full card detail, with no relations or context
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Unique identifier for this card
    * @param acceptLanguage Client locale, as language-country
    * @param products Indicates if cards should contain commercial products when available (true) or not (false)
    * @param userData Indicates if cards should contain user data when available (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    getCard: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.getCard(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Full card detail with version
    * Retrieves a full card detail, and its relations to other cards in a given context (card version)
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Unique identifier for this card
    * @param version Version identifier, indicates the context where the card is being requested
    * @param acceptLanguage Client locale, as language-country
    * @param products Indicates if cards should contain commercial products when available (true) or not (false)
    * @param userData Indicates if cards should contain user data when available (true) or not (false)
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    getCardVersion: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.getCardVersion(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Movie catalog info
    * Retrieves a movie&#39;s full card by its client ID, including catalog and cast information
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieId Client movie ID being played
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    getCatalogMovie: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.getCatalogMovie(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Channel events grid
    * Returns the current and upcoming grid of TV events for the given channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    getChannelGrid: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.getChannelGrid(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Channel movie catalog info
    * Retrieves full card detail, including catalog and cast information, for the content currently being broadcasted on the channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    getChannelMovie: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.getChannelMovie(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Get card likes
    * Returns a paginated list of cards liked by current user
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    * @param paginateKey Paginate key
    * @param size Number of desired results
    */
    getLikes: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.getLikes(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Channel sync availability
    * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelIdList List of client channel IDs as a comma separated list
    * @param acceptLanguage Client locale, as language-country
    */
    getReadyChannels: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.getReadyChannels(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Movie sync availability
    * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
    * @param acceptLanguage Client locale, as language-country
    */
    getReadyMovies: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.getReadyMovies(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Static channel scene
    * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    getStaticChannelScene: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.getStaticChannelScene(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Static VOD scene
    * Retrieves the current list of cards related to the given movie scene
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieId Client movie ID being played
    * @param timestamp Current movie timestamp in seconds
    * @param acceptLanguage Client locale, as language-country
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    getStaticMovieScene: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.getStaticMovieScene(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Add card like
    * Stores a card under current user&#39;s likes list
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Requested card ID
    * @param acceptLanguage Client locale, as language-country
    */
    postLikes: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.postLikes(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
    /**
    * Token endpoint
    * The token endpoint is used to obtain access tokens which allow clients to make API requests
    * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
    * @param grantType Grant type used to obtain the token.
    * @param acceptLanguage Client locale, as language-country
    * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
    * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
    */
    postToken: function (params, options) {
        var fetchArgs = exports.DefaultApiFetchParamCreator.postToken(params, options);
        return function (fetch, basePath) {
            if (basePath === void 0) { basePath = BASE_PATH; }
            return fetch(basePath + fetchArgs.url, fetchArgs.options)
                .then(function (response) {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            })
                .catch(function (response) {
                throw response;
            });
        };
    },
};
/**
* DefaultApi - object-oriented interface
*/
var DefaultApi = /** @class */ (function (_super) {
    __extends(DefaultApi, _super);
    function DefaultApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
    * Delete card like
    * Removes a card from current user&#39;s likes list
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Requested card ID
    * @param acceptLanguage Client locale, as language-country
    */
    DefaultApi.prototype.deleteLikes = function (params, options) {
        return exports.DefaultApiFp.deleteLikes(params, options)(this.fetch, this.basePath);
    };
    /**
    * Full card detail
    * Retrieves a full card detail, with no relations or context
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Unique identifier for this card
    * @param acceptLanguage Client locale, as language-country
    * @param products Indicates if cards should contain commercial products when available (true) or not (false)
    * @param userData Indicates if cards should contain user data when available (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    DefaultApi.prototype.getCard = function (params, options) {
        return exports.DefaultApiFp.getCard(params, options)(this.fetch, this.basePath);
    };
    /**
    * Full card detail with version
    * Retrieves a full card detail, and its relations to other cards in a given context (card version)
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Unique identifier for this card
    * @param version Version identifier, indicates the context where the card is being requested
    * @param acceptLanguage Client locale, as language-country
    * @param products Indicates if cards should contain commercial products when available (true) or not (false)
    * @param userData Indicates if cards should contain user data when available (true) or not (false)
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    DefaultApi.prototype.getCardVersion = function (params, options) {
        return exports.DefaultApiFp.getCardVersion(params, options)(this.fetch, this.basePath);
    };
    /**
    * Movie catalog info
    * Retrieves a movie&#39;s full card by its client ID, including catalog and cast information
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieId Client movie ID being played
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    DefaultApi.prototype.getCatalogMovie = function (params, options) {
        return exports.DefaultApiFp.getCatalogMovie(params, options)(this.fetch, this.basePath);
    };
    /**
    * Channel events grid
    * Returns the current and upcoming grid of TV events for the given channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    DefaultApi.prototype.getChannelGrid = function (params, options) {
        return exports.DefaultApiFp.getChannelGrid(params, options)(this.fetch, this.basePath);
    };
    /**
    * Channel movie catalog info
    * Retrieves full card detail, including catalog and cast information, for the content currently being broadcasted on the channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    DefaultApi.prototype.getChannelMovie = function (params, options) {
        return exports.DefaultApiFp.getChannelMovie(params, options)(this.fetch, this.basePath);
    };
    /**
    * Get card likes
    * Returns a paginated list of cards liked by current user
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    * @param paginateKey Paginate key
    * @param size Number of desired results
    */
    DefaultApi.prototype.getLikes = function (params, options) {
        return exports.DefaultApiFp.getLikes(params, options)(this.fetch, this.basePath);
    };
    /**
    * Channel sync availability
    * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelIdList List of client channel IDs as a comma separated list
    * @param acceptLanguage Client locale, as language-country
    */
    DefaultApi.prototype.getReadyChannels = function (params, options) {
        return exports.DefaultApiFp.getReadyChannels(params, options)(this.fetch, this.basePath);
    };
    /**
    * Movie sync availability
    * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
    * @param acceptLanguage Client locale, as language-country
    */
    DefaultApi.prototype.getReadyMovies = function (params, options) {
        return exports.DefaultApiFp.getReadyMovies(params, options)(this.fetch, this.basePath);
    };
    /**
    * Static channel scene
    * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    DefaultApi.prototype.getStaticChannelScene = function (params, options) {
        return exports.DefaultApiFp.getStaticChannelScene(params, options)(this.fetch, this.basePath);
    };
    /**
    * Static VOD scene
    * Retrieves the current list of cards related to the given movie scene
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieId Client movie ID being played
    * @param timestamp Current movie timestamp in seconds
    * @param acceptLanguage Client locale, as language-country
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    DefaultApi.prototype.getStaticMovieScene = function (params, options) {
        return exports.DefaultApiFp.getStaticMovieScene(params, options)(this.fetch, this.basePath);
    };
    /**
    * Add card like
    * Stores a card under current user&#39;s likes list
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Requested card ID
    * @param acceptLanguage Client locale, as language-country
    */
    DefaultApi.prototype.postLikes = function (params, options) {
        return exports.DefaultApiFp.postLikes(params, options)(this.fetch, this.basePath);
    };
    /**
    * Token endpoint
    * The token endpoint is used to obtain access tokens which allow clients to make API requests
    * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
    * @param grantType Grant type used to obtain the token.
    * @param acceptLanguage Client locale, as language-country
    * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
    * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
    */
    DefaultApi.prototype.postToken = function (params, options) {
        return exports.DefaultApiFp.postToken(params, options)(this.fetch, this.basePath);
    };
    return DefaultApi;
}(BaseAPI));
exports.DefaultApi = DefaultApi;
;
/**
* DefaultApi - factory interface
*/
exports.DefaultApiFactory = function (fetch, basePath) {
    return {
        /**
        * Delete card like
        * Removes a card from current user&#39;s likes list
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param cardId Requested card ID
        * @param acceptLanguage Client locale, as language-country
        */
        deleteLikes: function (params, options) {
            return exports.DefaultApiFp.deleteLikes(params, options)(fetch, basePath);
        },
        /**
        * Full card detail
        * Retrieves a full card detail, with no relations or context
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param cardId Unique identifier for this card
        * @param acceptLanguage Client locale, as language-country
        * @param products Indicates if cards should contain commercial products when available (true) or not (false)
        * @param userData Indicates if cards should contain user data when available (true) or not (false)
        * @param imageSize Size of the images returned in the response
        */
        getCard: function (params, options) {
            return exports.DefaultApiFp.getCard(params, options)(fetch, basePath);
        },
        /**
        * Full card detail with version
        * Retrieves a full card detail, and its relations to other cards in a given context (card version)
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param cardId Unique identifier for this card
        * @param version Version identifier, indicates the context where the card is being requested
        * @param acceptLanguage Client locale, as language-country
        * @param products Indicates if cards should contain commercial products when available (true) or not (false)
        * @param userData Indicates if cards should contain user data when available (true) or not (false)
        * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
        * @param imageSize Size of the images returned in the response
        */
        getCardVersion: function (params, options) {
            return exports.DefaultApiFp.getCardVersion(params, options)(fetch, basePath);
        },
        /**
        * Movie catalog info
        * Retrieves a movie&#39;s full card by its client ID, including catalog and cast information
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param clientMovieId Client movie ID being played
        * @param acceptLanguage Client locale, as language-country
        * @param imageSize Size of the images returned in the response
        */
        getCatalogMovie: function (params, options) {
            return exports.DefaultApiFp.getCatalogMovie(params, options)(fetch, basePath);
        },
        /**
        * Channel events grid
        * Returns the current and upcoming grid of TV events for the given channel
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param channelId Client channel ID
        * @param acceptLanguage Client locale, as language-country
        * @param imageSize Size of the images returned in the response
        */
        getChannelGrid: function (params, options) {
            return exports.DefaultApiFp.getChannelGrid(params, options)(fetch, basePath);
        },
        /**
        * Channel movie catalog info
        * Retrieves full card detail, including catalog and cast information, for the content currently being broadcasted on the channel
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param channelId Client channel ID
        * @param acceptLanguage Client locale, as language-country
        * @param imageSize Size of the images returned in the response
        */
        getChannelMovie: function (params, options) {
            return exports.DefaultApiFp.getChannelMovie(params, options)(fetch, basePath);
        },
        /**
        * Get card likes
        * Returns a paginated list of cards liked by current user
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param acceptLanguage Client locale, as language-country
        * @param imageSize Size of the images returned in the response
        * @param paginateKey Paginate key
        * @param size Number of desired results
        */
        getLikes: function (params, options) {
            return exports.DefaultApiFp.getLikes(params, options)(fetch, basePath);
        },
        /**
        * Channel sync availability
        * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param channelIdList List of client channel IDs as a comma separated list
        * @param acceptLanguage Client locale, as language-country
        */
        getReadyChannels: function (params, options) {
            return exports.DefaultApiFp.getReadyChannels(params, options)(fetch, basePath);
        },
        /**
        * Movie sync availability
        * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
        * @param acceptLanguage Client locale, as language-country
        */
        getReadyMovies: function (params, options) {
            return exports.DefaultApiFp.getReadyMovies(params, options)(fetch, basePath);
        },
        /**
        * Static channel scene
        * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param channelId Client channel ID
        * @param acceptLanguage Client locale, as language-country
        * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
        * @param imageSize Size of the images returned in the response
        */
        getStaticChannelScene: function (params, options) {
            return exports.DefaultApiFp.getStaticChannelScene(params, options)(fetch, basePath);
        },
        /**
        * Static VOD scene
        * Retrieves the current list of cards related to the given movie scene
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param clientMovieId Client movie ID being played
        * @param timestamp Current movie timestamp in seconds
        * @param acceptLanguage Client locale, as language-country
        * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
        * @param imageSize Size of the images returned in the response
        */
        getStaticMovieScene: function (params, options) {
            return exports.DefaultApiFp.getStaticMovieScene(params, options)(fetch, basePath);
        },
        /**
        * Add card like
        * Stores a card under current user&#39;s likes list
        * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
        * @param cardId Requested card ID
        * @param acceptLanguage Client locale, as language-country
        */
        postLikes: function (params, options) {
            return exports.DefaultApiFp.postLikes(params, options)(fetch, basePath);
        },
        /**
        * Token endpoint
        * The token endpoint is used to obtain access tokens which allow clients to make API requests
        * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
        * @param grantType Grant type used to obtain the token.
        * @param acceptLanguage Client locale, as language-country
        * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
        * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
        */
        postToken: function (params, options) {
            return exports.DefaultApiFp.postToken(params, options)(fetch, basePath);
        },
    };
};
;
/**
* DiveAPI - extended object-oriented interface
*/
var DiveAPIClass = /** @class */ (function (_super) {
    __extends(DiveAPIClass, _super);
    function DiveAPIClass(params) {
        var _this = _super.call(this, "", params.fetch) || this;
        _this.environment = "PRO";
        _this.noAuthServices = ["postRegisterDevice", "postRegisterEmail", "postToken", "postVersion"];
        if (typeof params !== "object") {
            console.error("You should provide initialization params.");
            throw new Error("You should provide initialization params.");
        }
        _this.apiKey = params.apiKey;
        if (params.deviceId) {
            _this.setDeviceId(params.deviceId);
        }
        _this.eventNamespace = params.eventNamespace || "dive-external-api-";
        _this.setEnvironment(params.env);
        _this.storeTokenType = params.storeToken;
        return _this;
        // this.connectionFailedObservable = Rx.Observable.fromEvent(document, `${this.eventNamespace}-connection-failed`);
        // this.internalServerErrorObservable = Rx.Observable.fromEvent(document, `${this.eventNamespace}-internal-server-error`);
        // this.serviceTemporarilyUnavailableObservable = Rx.Observable.fromEvent(document, `${this.eventNamespace}-service-unavailable`);
        // this.unsupportedMediaTypeErrorObservable = Rx.Observable.fromEvent(document, `${this.eventNamespace}-unsupported-mediatype`);
        // this.unauthorizedObservable = Rx.Observable.fromEvent(document, `${this.eventNamespace}-unauthorized`);
        // this.unauthorizedRoleObservable = Rx.Observable.fromEvent(document, `${this.eventNamespace}-unauthorized-role`);
    }
    DiveAPIClass.prototype.setDeviceId = function (deviceId) {
        this.deviceId = deviceId;
    };
    DiveAPIClass.prototype.getSavedToken = function () {
        switch (this.storeTokenType) {
            case "cookies":
                return this.getTokenFromCookies();
            default:
                if (this.getTokenFromWebStorage()) {
                    return JSON.parse(this.getTokenFromWebStorage());
                }
                break;
        }
    };
    DiveAPIClass.prototype.setEnvironment = function (env) {
        this.environment = env;
        switch (env) {
            case "DEV":
                this.basePath = BASE_PATH.replace("https://", "https://dev-");
                break;
            case "PRE":
                this.basePath = BASE_PATH.replace("https://", "https://pre-");
                break;
            case "PRO":
            default:
                this.basePath = BASE_PATH;
                break;
        }
    };
    DiveAPIClass.prototype.setLocale = function (locale) {
        this.locale = locale;
    };
    DiveAPIClass.prototype.getLocale = function () {
        return this.locale;
    };
    DiveAPIClass.prototype.writeToken = function (newToken) {
        if (newToken) {
            switch (this.storeTokenType) {
                case "cookies":
                    this.writeTokenToCookie(newToken);
                    break;
                default:
                    this.writeTokenToWebStorage(newToken);
                    break;
            }
            if (this.diveTokenRefreshInterval) {
                window.clearInterval(this.diveTokenRefreshInterval);
                this.diveTokenRefreshInterval = undefined;
            }
            if (newToken.expires_in) {
                this.diveTokenRefreshInterval = window.setInterval(this.refreshToken.bind(this), (Math.max(10000, newToken.expires_in - 60) * 1000)); // 60 seconds before expiration (in ms)
            }
        }
    };
    DiveAPIClass.prototype.gatherCommonHeaders = function (params) {
        var newParams = {};
        if (!params) {
            params = {};
        }
        // newParams["User-Agent"] = "foo";
        if (params["connection"] == null) {
            newParams.connection = "keep-alive";
        }
        if (params["acceptEncoding"] == null) {
            newParams.acceptEncoding = "gzip, deflate";
        }
        if (params["authorization"] == null && this.getSavedToken()) {
            newParams.authorization = "" + this.getSavedToken().token_type.substring(0, 1).toUpperCase() + this.getSavedToken().token_type.substring(1) + " " + this.getSavedToken().access_token;
        }
        else {
            newParams.authorization = "Basic " + this.apiKey;
        }
        if (params["acceptLanguage"] == null && this.locale !== null) {
            newParams.acceptLanguage = this.locale;
        }
        return __assign({}, newParams, params);
    };
    DiveAPIClass.prototype.deleteSavedToken = function () {
        switch (this.storeTokenType) {
            case "cookies":
                this.deleteTokenFromCookies();
                break;
            default:
                this.deleteTokenFromWebStorage();
                break;
        }
    };
    DiveAPIClass.prototype.initializeToken = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.refreshToken()
                .then(function () {
                resolve();
            })
                .catch(function (e) {
                reject(e);
            });
        });
    };
    DiveAPIClass.prototype.postTokenAndSave = function (params, options) {
        var _this = this;
        this.deleteSavedToken();
        return new Promise(function (resolve, reject) {
            var newParams = __assign({}, _this.gatherCommonHeaders(params), { deviceId: _this.deviceId });
            var request = _this.postToken(newParams, options);
            request.then(function (newToken) {
                _this.writeToken(newToken);
                resolve();
            })
                .catch(reject);
        });
    };
    DiveAPIClass.prototype.syncWithMovieVOD = function (params) {
        if (!params) {
            throw new Error("Error, missing parameters object");
        }
        if (!params.movieId) {
            throw new Error("Error, missing movieId parameter");
        }
        if (!params.timestamp) {
            throw new Error("Error, missing timestamp parameter");
        }
        this.syncWithMovie({ movieId: params.movieId, timestamp: params.timestamp, callbacks: params.callbacks });
    };
    DiveAPIClass.prototype.syncWithMovieStreaming = function (params) {
        if (!params) {
            throw new Error("Error, missing parameters object");
        }
        if (!params.channelId) {
            throw new Error("Error, missing channelId parameter");
        }
        this.syncWithMovie({ channelId: params.channelId, protocol: params.protocol, callbacks: params.callbacks });
    };
    DiveAPIClass.prototype.syncWithMovie = function (params) {
        var _this = this;
        if (!params) {
            throw new Error("Error, missing parameters object");
        }
        var protocol = params.protocol || "https";
        var url = "stream.dive.tv";
        var syncType = "channels";
        // let query: any = {token: `${this.getSavedToken().access_token}`};
        var query = {};
        switch (this.environment) {
            case "DEV":
                url = protocol + "://dev-" + url;
                break;
            case "PRE":
                url = protocol + "://pre-" + url;
                break;
            default:
                url = protocol + "://" + url;
        }
        if (!params.channelId && params.movieId && params.timestamp) {
            syncType = "movies";
            query.movie_id = params.movieId;
            query.timestamp = params.timestamp;
        }
        else {
            query.channel_id = params.channelId;
        }
        url += "/" + syncType;
        this.socket = io(url, {
            path: "/v1/stream",
            multiplex: false,
            reconnection: true,
            query: query,
            // forceNew: true,
            // rejectUnauthorized: false,
            // secure: true,
            transports: ["websocket"],
            extraHeaders: {
                'Accept-Language': this.locale,
            },
        });
        this.socket.on('connect', function () {
            _this.socket.emit('authenticate', { token: _this.getSavedToken().access_token })
                .on('authenticated', function () {
                console.log("authorized");
            })
                .on('unauthorized', function (msg) {
                console.log("unauthorized: " + JSON.stringify(msg.data));
                throw new Error(msg.data.type);
            })
                .on('error', function (error) {
                console.log("SOCKET error", error);
                if (params.callbacks && params.callbacks.onError instanceof Function) {
                    params.callbacks.onError(error);
                }
            })
                .on('movie_start', function (movie) {
                console.log("SOCKET movie_start", movie);
                if (params.callbacks && params.callbacks.onMovieStart instanceof Function) {
                    params.callbacks.onMovieStart(movie);
                }
            })
                .on('movie_end', function () {
                console.log("SOCKET movie_end");
                if (params.callbacks && params.callbacks.onMovieEnd instanceof Function) {
                    params.callbacks.onMovieEnd();
                }
            })
                .on('scene_start', function (scene) {
                console.log("SOCKET scene_start", scene);
                if (params.callbacks && params.callbacks.onSceneStart instanceof Function) {
                    params.callbacks.onSceneStart(scene);
                }
            })
                .on('scene_update', function (scene) {
                console.log("SOCKET scene_update", scene);
                if (params.callbacks && params.callbacks.onSceneUpdate instanceof Function) {
                    params.callbacks.onSceneUpdate(scene);
                }
            })
                .on('scene_end', function () {
                console.log("SOCKET scene_end");
                if (params.callbacks && params.callbacks.onSceneEnd instanceof Function) {
                    params.callbacks.onSceneEnd();
                }
            })
                .on('pause_start', function () {
                console.log("SOCKET pause_start");
                if (params.callbacks && params.callbacks.onPauseStart instanceof Function) {
                    params.callbacks.onPauseStart();
                }
            })
                .on('pause_end', function () {
                console.log("SOCKET pause_end");
                if (params.callbacks && params.callbacks.onPauseEnd instanceof Function) {
                    params.callbacks.onPauseEnd();
                }
            });
        });
    };
    DiveAPIClass.prototype.clearSocket = function () {
        if (this.socket) {
            if (this.socket.connected) {
                this.socket.disconnect(true);
            }
        }
        this.socket = undefined;
    };
    /**
    * Delete card like
    * Removes a card from current user&#39;s likes list
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Requested card ID
    * @param acceptLanguage Client locale, as language-country
    */
    DiveAPIClass.prototype.deleteLikes = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.deleteLikes(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - deleteLikes", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("deleteLikes")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.deleteLikes(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Full card detail
    * Retrieves a full card detail, with no relations or context
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Unique identifier for this card
    * @param acceptLanguage Client locale, as language-country
    * @param products Indicates if cards should contain commercial products when available (true) or not (false)
    * @param userData Indicates if cards should contain user data when available (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    DiveAPIClass.prototype.getCard = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.getCard(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - getCard", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("getCard")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.getCard(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Full card detail with version
    * Retrieves a full card detail, and its relations to other cards in a given context (card version)
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Unique identifier for this card
    * @param version Version identifier, indicates the context where the card is being requested
    * @param acceptLanguage Client locale, as language-country
    * @param products Indicates if cards should contain commercial products when available (true) or not (false)
    * @param userData Indicates if cards should contain user data when available (true) or not (false)
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    DiveAPIClass.prototype.getCardVersion = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.getCardVersion(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - getCardVersion", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("getCardVersion")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.getCardVersion(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Movie catalog info
    * Retrieves a movie&#39;s full card by its client ID, including catalog and cast information
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieId Client movie ID being played
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    DiveAPIClass.prototype.getCatalogMovie = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.getCatalogMovie(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - getCatalogMovie", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("getCatalogMovie")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.getCatalogMovie(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Channel events grid
    * Returns the current and upcoming grid of TV events for the given channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    DiveAPIClass.prototype.getChannelGrid = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.getChannelGrid(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - getChannelGrid", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("getChannelGrid")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.getChannelGrid(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Channel movie catalog info
    * Retrieves full card detail, including catalog and cast information, for the content currently being broadcasted on the channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    */
    DiveAPIClass.prototype.getChannelMovie = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.getChannelMovie(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - getChannelMovie", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("getChannelMovie")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.getChannelMovie(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Get card likes
    * Returns a paginated list of cards liked by current user
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param acceptLanguage Client locale, as language-country
    * @param imageSize Size of the images returned in the response
    * @param paginateKey Paginate key
    * @param size Number of desired results
    */
    DiveAPIClass.prototype.getLikes = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.getLikes(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - getLikes", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("getLikes")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.getLikes(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Channel sync availability
    * Checks if a list of client channel identifiers are currently broadcasting synchronizable content
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelIdList List of client channel IDs as a comma separated list
    * @param acceptLanguage Client locale, as language-country
    */
    DiveAPIClass.prototype.getReadyChannels = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.getReadyChannels(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - getReadyChannels", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("getReadyChannels")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.getReadyChannels(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Movie sync availability
    * Checks whether a list of client movie identifiers (Video On Demand) are available to be synchronized using the Dive API
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieIdList List of client movie IDs, provided as a comma separated list
    * @param acceptLanguage Client locale, as language-country
    */
    DiveAPIClass.prototype.getReadyMovies = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.getReadyMovies(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - getReadyMovies", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("getReadyMovies")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.getReadyMovies(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Static channel scene
    * Retrieves the list of cards related to the content currently being broadcasted in the provided channel
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param channelId Client channel ID
    * @param acceptLanguage Client locale, as language-country
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    DiveAPIClass.prototype.getStaticChannelScene = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.getStaticChannelScene(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - getStaticChannelScene", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("getStaticChannelScene")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.getStaticChannelScene(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Static VOD scene
    * Retrieves the current list of cards related to the given movie scene
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param clientMovieId Client movie ID being played
    * @param timestamp Current movie timestamp in seconds
    * @param acceptLanguage Client locale, as language-country
    * @param relations Indicates if cards should contain the scene hierarchy (true) or not (false)
    * @param imageSize Size of the images returned in the response
    */
    DiveAPIClass.prototype.getStaticMovieScene = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.getStaticMovieScene(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - getStaticMovieScene", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("getStaticMovieScene")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.getStaticMovieScene(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Add card like
    * Stores a card under current user&#39;s likes list
    * @param authorization Authorization token (&#39;Bearer &lt;token&gt;&#39;)
    * @param cardId Requested card ID
    * @param acceptLanguage Client locale, as language-country
    */
    DiveAPIClass.prototype.postLikes = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.postLikes(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - postLikes", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("postLikes")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.postLikes(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    /**
    * Token endpoint
    * The token endpoint is used to obtain access tokens which allow clients to make API requests
    * @param authorization Basic authorization token (&#39;Basic &lt;client_key&gt;&#39;)
    * @param grantType Grant type used to obtain the token.
    * @param acceptLanguage Client locale, as language-country
    * @param deviceId Device identifier, must uniquely identify the user or device accessing the API. Required only for \&quot;device_credentials\&quot; grant type
    * @param refreshToken Refresh token, used to issue a new token without resending client credentials. Required only for \&quot;refresh_token\&quot; grant type
    */
    DiveAPIClass.prototype.postToken = function (params, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var newParams = _this.gatherCommonHeaders(params);
            exports.DefaultApiFp.postToken(newParams, options)(_this.fetch, _this.basePath)
                .then(function (result) {
                resolve(result);
            })
                .catch(function (error) {
                if (error) {
                    console.log("%c REST error - postToken", "background: black; color: #FE2EF7; padding: 0 10px;", error);
                }
                if (error.status === 401 && _this.serviceRequiresToken("postToken")) {
                    _this.refreshToken()
                        .catch(function (error) {
                        return _this.postTokenAndSave({ grantType: "device_credentials", deviceId: _this.deviceId });
                    })
                        .then(function () {
                        newParams = _this.gatherCommonHeaders(params);
                        return exports.DefaultApiFp.postToken(newParams, options)(_this.fetch, _this.basePath);
                    })
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (errorRefreshingToken) {
                        reject(errorRefreshingToken);
                    });
                }
                else {
                    reject(error);
                }
            });
        });
    };
    DiveAPIClass.prototype.serviceRequiresToken = function (methodName) {
        return this.noAuthServices.indexOf(methodName) === -1;
    };
    DiveAPIClass.prototype.writeTokenToCookie = function (newToken) {
        return this.setCookie("dive_token", JSON.stringify(newToken), newToken.expires_in);
    };
    DiveAPIClass.prototype.writeTokenToWebStorage = function (newToken) {
        if (window.localStorage) {
            window.localStorage.setItem("dive_token", JSON.stringify(newToken));
        }
    };
    DiveAPIClass.prototype.refreshToken = function () {
        var currToken = this.getSavedToken();
        var auth = "Basic " + this.apiKey;
        if (currToken && currToken.refresh_token) {
            return this.postTokenAndSave({ grantType: "refresh_token", refreshToken: currToken.refresh_token });
        }
        else {
            return this.postTokenAndSave({ grantType: "device_credentials", deviceId: this.deviceId });
        }
    };
    DiveAPIClass.prototype.setCookie = function (cname, cvalue, exdays) {
        var d = new Date();
        d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toUTCString();
        document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
    };
    DiveAPIClass.prototype.getCookie = function (cname) {
        var name = cname + "=";
        var decodedCookie = decodeURIComponent(document.cookie);
        var ca = decodedCookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    };
    DiveAPIClass.prototype.getTokenFromCookies = function () {
        var token = this.getCookie("dive_token");
        if (token) {
            try {
                return JSON.parse(token);
            }
            catch (e) {
                return undefined;
            }
        }
        else {
            return undefined;
        }
    };
    DiveAPIClass.prototype.getTokenFromWebStorage = function () {
        if (window.localStorage) {
            try {
                return window.localStorage.getItem("dive_token");
            }
            catch (e) {
                return undefined;
            }
        }
    };
    DiveAPIClass.prototype.deleteTokenFromWebStorage = function () {
        if (window.localStorage) {
            window.localStorage.removeItem("dive_token");
        }
    };
    DiveAPIClass.prototype.deleteTokenFromCookies = function () {
        var name = "dive_token";
        document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;';
    };
    return DiveAPIClass;
}(DefaultApi));
exports.DiveAPIClass = DiveAPIClass;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(35);
var util = __webpack_require__(36);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(13);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)(module), __webpack_require__(0)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
__webpack_require__(38);
module.exports = self.fetch.bind(self);


/***/ }),
/* 38 */
/***/ (function(module, exports) {

(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1])
      }, this)
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = String(input)
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var url = __webpack_require__(40);
var parser = __webpack_require__(6);
var Manager = __webpack_require__(18);
var debug = __webpack_require__(1)('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = __webpack_require__(18);
exports.Socket = __webpack_require__(23);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module dependencies.
 */

var parseuri = __webpack_require__(15);
var debug = __webpack_require__(1)('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 41 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(43);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 43 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),
/* 44 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = __webpack_require__(46);
var isBuf = __webpack_require__(17);
var toString = Object.prototype.toString;
var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 46 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(48);


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(49);

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = __webpack_require__(3);


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module dependencies.
 */

var transports = __webpack_require__(19);
var Emitter = __webpack_require__(2);
var debug = __webpack_require__(1)('engine.io-client:socket');
var index = __webpack_require__(22);
var parser = __webpack_require__(3);
var parseuri = __webpack_require__(15);
var parsejson = __webpack_require__(61);
var parseqs = __webpack_require__(4);

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (global.location && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // other options for Node.js client
  var freeGlobal = typeof global === 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = __webpack_require__(8);
Socket.transports = __webpack_require__(19);
Socket.parser = __webpack_require__(3);

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0)
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 50 */
/***/ (function(module, exports) {


/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module requirements.
 */

var XMLHttpRequest = __webpack_require__(7);
var Polling = __webpack_require__(20);
var Emitter = __webpack_require__(2);
var inherit = __webpack_require__(5);
var debug = __webpack_require__(1)('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname !== global.location.hostname ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          var contentType;
          try {
            contentType = xhr.getResponseHeader('Content-Type');
          } catch (e) {}
          if (contentType === 'application/octet-stream') {
            xhr.responseType = 'arraybuffer';
          }
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (global.document) {
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 52 */
/***/ (function(module, exports) {


/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};


/***/ }),
/* 53 */
/***/ (function(module, exports) {

/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};


/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/utf8js v2.1.2 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint, strict) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			if (strict) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
			return false;
		}
		return true;
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint, strict) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			if (!checkScalarValue(codePoint, strict)) {
				codePoint = 0xFFFD;
			}
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;

		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint, strict);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol(strict) {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;

		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol(strict)) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.1.2',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return utf8;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)(module), __webpack_require__(0)))

/***/ }),
/* 56 */
/***/ (function(module, exports) {

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module requirements.
 */

var Polling = __webpack_require__(20);
var inherit = __webpack_require__(5);

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module dependencies.
 */

var Transport = __webpack_require__(8);
var parser = __webpack_require__(3);
var parseqs = __webpack_require__(4);
var inherit = __webpack_require__(5);
var yeast = __webpack_require__(21);
var debug = __webpack_require__(1)('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
var NodeWebSocket;
if (typeof window === 'undefined') {
  try {
    NodeWebSocket = __webpack_require__(60);
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  WebSocket = NodeWebSocket;
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocket = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 60 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}


/***/ }),
/* 63 */
/***/ (function(module, exports) {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(65);
module.exports = __webpack_require__(26).Object.assign;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(66);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(76) });


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(9);
var core = __webpack_require__(26);
var ctx = __webpack_require__(67);
var hide = __webpack_require__(69);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(68);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(70);
var createDesc = __webpack_require__(75);
module.exports = __webpack_require__(11) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(71);
var IE8_DOM_DEFINE = __webpack_require__(72);
var toPrimitive = __webpack_require__(74);
var dP = Object.defineProperty;

exports.f = __webpack_require__(11) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(10);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(11) && !__webpack_require__(12)(function () {
  return Object.defineProperty(__webpack_require__(73)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(10);
var document = __webpack_require__(9).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(10);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(77);
var gOPS = __webpack_require__(88);
var pIE = __webpack_require__(89);
var toObject = __webpack_require__(90);
var IObject = __webpack_require__(28);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(12)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(78);
var enumBugKeys = __webpack_require__(87);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(79);
var toIObject = __webpack_require__(27);
var arrayIndexOf = __webpack_require__(81)(false);
var IE_PROTO = __webpack_require__(84)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 79 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 80 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(27);
var toLength = __webpack_require__(82);
var toAbsoluteIndex = __webpack_require__(83);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(30);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(30);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(85)('keys');
var uid = __webpack_require__(86);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(9);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 86 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 87 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 88 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 89 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(29);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ })
/******/ ]);
});

/***/ }),

/***/ 312:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(313);


/***/ }),

/***/ 313:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var ReactDOM = __webpack_require__(91);
var react_redux_1 = __webpack_require__(52);
var history_1 = __webpack_require__(235);
var react_shadow_1 = __webpack_require__(437);
var store_1 = __webpack_require__(438);
var Containers_1 = __webpack_require__(99);
var api_typescript_library_1 = __webpack_require__(276);
var history = history_1.createBrowserHistory();
exports.init = function (params) {
    if ((typeof params === "undefined" ? "undefined" : _typeof(params)) !== "object") {
        console.error("You should provide initialization parameters as an object.");
        throw new Error("You should provide initialization parameters as an object.");
    }
    if (typeof params.apiKey !== "string") {
        console.error("You should provide a Dive API KEY in the initialization parameter 'apiKey");
        throw new Error("You should provide a Dive API KEY in the initialization parameter 'apiKey");
    }
    if (typeof params.deviceId !== "string") {
        console.error("You should provide a unique client id in order to authenticate him,\n      provide it through the initialization parameter 'clientId'");
        throw new Error("You should provide a unique client id in order to authenticate him,\n      provide it through the initialization parameter 'clientId'");
    }
    var APIinstance = new api_typescript_library_1.DiveAPIClass({ env: "PRE", storeToken: "cookies", apiKey: params.apiKey, deviceId: params.deviceId });
    APIinstance.setLocale("es-ES");
    window.DiveAPI = APIinstance;
    APIinstance.postTokenAndSave({ deviceId: _this.deviceId, grantType: "device_credentials" }).then(function (response) {
        console.log("Authorized!");
        window.DiveAPI = APIinstance;
        console.log("DiveAPI generated, available through DiveSDK.API or window.DiveAPI (global)");
        if (typeof params.selector !== "string") {
            console.error("You should provide a selector that resolves to an existing DOM Element\n        in the initialization parameter 'selector'");
            throw new Error("You should provide a selector that resolves to an existing DOM Element\n        in the initialization parameter 'selector'");
        }
    }).then(function () {
        ReactDOM.render(React.createElement(react_shadow_1.default, { include: 'styles.css' }, React.createElement("div", { className: "diveContainer" }, React.createElement(react_redux_1.Provider, { store: store_1.store }, React.createElement(Containers_1.App, null)))), document.querySelector(params.selector));
    }).catch(function (error) {
        console.error("CARDS FROM MOVIE ERROR", error);
    });
};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "main.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 33:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(553));
__export(__webpack_require__(554));
__export(__webpack_require__(276));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "index.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 438:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var redux_1 = __webpack_require__(80);
var redux_thunk_1 = __webpack_require__(439);
var socket_middleware_1 = __webpack_require__(440);
var Reducers_1 = __webpack_require__(517);
var windowIfDefined = typeof window === 'undefined' ? null : window;
var composeEnhancers = windowIfDefined.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || redux_1.compose;
var getMiddlewares = function getMiddlewares() {
    return redux_1.applyMiddleware(redux_thunk_1.default, socket_middleware_1.default());
};
exports.store = redux_1.createStore(redux_1.combineReducers({
    nav: Reducers_1.NavReducer,
    carousel: Reducers_1.SyncReducer,
    ui: Reducers_1.UIReducer
}), composeEnhancers(getMiddlewares()));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "store.ts" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 440:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Actions_1 = __webpack_require__(61);
var io = __webpack_require__(487);
var Constants_1 = __webpack_require__(266);
var socketMiddleware = function socketMiddleware() {
    var socket;
    var onOpen = function onOpen(socketIo, store, channel) {
        return function (evt) {
            store.dispatch(Actions_1.SocketActions.socketConnected());
            if (socket !== undefined) {
                socket.on('channelStatus', onMessage(socket, store));
                socket.emit('tuneChannel', channel);
            }
        };
    };
    var onClose = function onClose(socketIo, store) {
        return function (evt) {
            if (socket !== undefined) {
                socket.close();
            }
            store.dispatch(Actions_1.SocketActions.socketDisconnected());
        };
    };
    var onEnd = function onEnd(socketIo, store) {
        return function (evt) {
            if (socket !== undefined) {
                socket.close();
            }
            store.dispatch(Actions_1.SocketActions.socketDisconnected());
        };
    };
    var onError = function onError(socketIo, store) {
        return function (evt) {
            if (socket !== undefined) {
                socket.close();
            }
            store.dispatch(Actions_1.SocketActions.socketDisconnected());
        };
    };
    var onTimeout = function onTimeout(socketIo, store) {
        return function (evt) {
            if (socket !== undefined) {
                socket.close();
            }
            store.dispatch(Actions_1.SocketActions.socketDisconnected());
        };
    };
    var onMessage = function onMessage(socketIo, store) {
        return function (evt) {
            var next = store.dispatch;
            var data = evt;
            var status = data.status;
            switch (status) {
                case "authenticated":
                    store.dispatch(Actions_1.SocketActions.authReceived());
                    break;
                case "unauthorized":
                    store.dispatch(Actions_1.SocketActions.unauthReceived({ message: data.message, code: data.code, type: data.type }));
                    break;
                case "error":
                    store.dispatch(Actions_1.SocketActions.errorReceived({ status: data.status, description: data.description }));
                    break;
                case "movie_start":
                    store.dispatch(Actions_1.SocketActions.movieStartReceived({ movie_id: data.movie_id }));
                    break;
                case "movie_end":
                    store.dispatch(Actions_1.SocketActions.movieEndRecieved());
                    break;
                case "scene_start":
                    store.dispatch(Actions_1.SocketActions.sceneStartReceived({ cards: data.cards }));
                    break;
                case "scene_update":
                    store.dispatch(Actions_1.SocketActions.sceneUpdateReceived({ cards: data.cards }));
                    break;
                case "scene_end":
                    store.dispatch(Actions_1.SocketActions.sceneEndReceived());
                    break;
                default:
                    break;
            }
        };
    };
    var getUrl = function getUrl(env) {
        var socketPath = 'stream.dive.tv';
        switch (env) {
            case "DEV":
                return "https://dev-" + socketPath;
            case "PRE":
                return "https://pre-" + socketPath;
            case "PRO":
            default:
                return 'https://' + socketPath;
        }
    };
    var handler = function handler(store) {
        return function (next) {
            return function (action) {
                switch (action.type) {
                    case 'CONNECT':
                        if (socket !== undefined) {
                            socket.close();
                        }
                        store.dispatch(Actions_1.SocketActions.socketConnecting());
                        var diveToken = DiveAPI.getSavedToken();
                        if (diveToken === undefined) {
                            console.error("No token present while trying to connect the socket");
                            throw new Error("No token present while trying to connect the socket");
                        }
                        var url = action.payload.url !== undefined ? action.payload.url : getUrl(Constants_1.DIVE_ENVIRONMENT);
                        socket = io.connect(url, {
                            forceNew: true,
                            query: "token=" + diveToken.access_token,
                            rejectUnauthorized: false,
                            secure: true,
                            transports: ["websocket", "xhr-polling", "polling", "htmlfile"]
                        });
                        var channel = action.payload.channelId;
                        socket.on('connect', onOpen(socket, store, channel));
                        socket.on('connect_error', onError(socket, store));
                        socket.on('error', onError(socket, store));
                        socket.on('connect_timeout', onTimeout(socket, store));
                        socket.on('disconnect', onClose(socket, store));
                        socket.on('end', onEnd(socket, store));
                        break;
                    case 'DISCONNECT':
                        if (socket !== undefined) {
                            socket.close();
                        }
                        socket = undefined;
                        store.dispatch(Actions_1.SocketActions.socketDisconnected());
                        break;
                    default:
                        return next(action);
                }
            };
        };
    };
    return handler;
};
exports.default = socketMiddleware;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "socket.middleware.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 441:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var redux_actions_1 = __webpack_require__(96);
exports.uiCreateAction = function (type, payload) {
    return redux_actions_1.createAction(type, payload);
};
exports.UIActions = {
    goBack: exports.uiCreateAction("UI/UI_BACK", function () {
        return 0;
    }),
    setDivider: exports.uiCreateAction("UI/SET_DIVIDER", function (divider) {
        return divider;
    }),
    openCard: function openCard(cardId, relations) {
        return function (dispatch) {
            if (cardId && cardId.length > 0) {
                dispatch(exports.UIActions.performOpenCard());
            }
            DiveAPI.getCard({ cardId: cardId }).then(function (card) {
                dispatch(exports.UIActions.performOpenCard(card));
            }).catch(function (error) {
                console.error("Error getting card", error);
            });
        };
    },
    performOpenCard: exports.uiCreateAction("UI/OPEN_CARD", function (card) {
        return card;
    }),
    openSync: exports.uiCreateAction("UI/OPEN_SYNC"),
    open: function open(group) {
        return function (dispatch) {
            dispatch(exports.UIActions.performOpen(group));
        };
    },
    performOpen: exports.uiCreateAction("UI/OPEN", function (group) {
        return group;
    }),
    addTestCards: exports.uiCreateAction("UI/ADD_TEST_CARDS", function (cards) {
        return cards;
    })
};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "ui.actions.ts" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 483:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var redux_actions_1 = __webpack_require__(96);
exports.navCreateAction = function (type, payload) {
    return redux_actions_1.createAction(type, payload);
};
exports.NavActions = {
    addNode: exports.navCreateAction('NAV/ADD_NODE', function (nav) {
        return nav;
    }),
    setLastKey: exports.navCreateAction('NAV/KEY', function (key) {
        return key;
    }),
    setSelected: exports.navCreateAction('NAV/SELECTED', function (id) {
        return id;
    }),
    setLeaf: exports.navCreateAction('NAV/SELECT_LEAF', function (id) {
        return id;
    }),
    setActivated: exports.navCreateAction('NAV/ACTIVATED', function (id) {
        return id;
    }),
    moveHorizontal: exports.navCreateAction('NAV/MOVE_HORIZONTAL', function (id) {
        return id;
    }),
    moveVertical: exports.navCreateAction('NAV/MOVE_VERTICAL', function (id) {
        return id;
    }),
    deleteNode: exports.navCreateAction('NAV/DELETE_NODE', function (id) {
        return id;
    }),
    setNodeByName: exports.navCreateAction('NAV/SELECT_BY_NAME', function (name) {
        return name;
    }),
    setNodeById: exports.navCreateAction('NAV/SELECT_BY_ID', function (id) {
        return id;
    })
};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "nav.actions.ts" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 484:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var redux_actions_1 = __webpack_require__(96);
;
exports.syncCreateAction = function (type, payload) {
    return redux_actions_1.createAction(type, payload);
};
exports.SyncActions = {
    openCard: exports.syncCreateAction("SYNC/OPEN_CARD", function (cardId) {
        return cardId;
    }),
    setMovie: exports.syncCreateAction("SYNC/SET_MOVIE", function (movieId) {
        return movieId;
    }),
    setChunkStatus: exports.syncCreateAction("SYNC/SET_CHUNK_STATUS", function (chunkStatus) {
        return chunkStatus;
    }),
    setSyncType: exports.syncCreateAction("SYNC/SET_SYNC_TYPE", function (syncType) {
        return syncType;
    }),
    setSelectedOnSceneChange: exports.syncCreateAction("SYNC/SET_SELECTED_ON_SCENE_CHANGE", function (val) {
        return val;
    }),
    syncChannel: function syncChannel(tvEvent) {
        return function (dispatch) {
            console.log("[SOCKET]");
            dispatch(exports.SyncActions.setSyncType("SOCKET"));
            DiveAPI.syncWithMovieStreaming({
                channelId: "la2", callbacks: {
                    onError: function onError() {
                        console.log("[SOCKET] onError");
                    },
                    onMovieStart: function onMovieStart(movie) {
                        if (movie && movie.movie_id) {
                            dispatch(exports.SyncActions.setMovie(movie.movie_id));
                        }
                    },
                    onMovieEnd: function onMovieEnd() {
                        console.log("[SOCKET] onMovieEnd");
                    },
                    onSceneStart: function onSceneStart(scene) {
                        console.log("[SOCKET] onSceneStart", scene);
                        if (scene && scene.cards) {
                            dispatch(exports.SyncActions.startScene(scene.cards));
                        }
                    },
                    onSceneUpdate: function onSceneUpdate(scene) {
                        console.log("[SOCKET] onSceneUpdate", scene);
                        if (scene) {
                            dispatch(exports.SyncActions.updateScene(scene));
                        }
                    },
                    onSceneEnd: function onSceneEnd() {
                        console.log("[SOCKET] onSceneEnd");
                    },
                    onPauseStart: function onPauseStart() {
                        console.log("[SOCKET] onPauseStart");
                    },
                    onPauseEnd: function onPauseEnd() {
                        console.log("[SOCKET] onPauseEnd");
                    }
                }
            });
        };
    },
    dataSync: function dataSync(movieId) {
        return function (dispatch) {
            dispatch(exports.SyncActions.setChunkStatus("LOADING"));
        };
    },
    startScene: exports.syncCreateAction("SYNC/START_SCENE", function (cards) {
        return cards;
    }),
    updateScene: exports.syncCreateAction("SYNC/UPDATE_SCENE", function (cards) {
        return cards;
    }),
    endScene: exports.syncCreateAction("SYNC/END_SCENE", function (cards) {
        return cards;
    }),
    setTime: exports.syncCreateAction("SYNC/SET_TIME", function (time) {
        return time;
    })
};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "sync.actions.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 485:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var redux_actions_1 = __webpack_require__(96);
function socketCreateAction(type, payload) {
    return redux_actions_1.createAction(type, payload);
}
exports.SocketActions = {
    authReceived: socketCreateAction("SOCKET/AUTHENTICATED"),
    unauthReceived: socketCreateAction("SOCKET/UNAUTHORIZED", function (payload) {
        return payload;
    }),
    errorReceived: socketCreateAction("SOCKET/ERROR", function (payload) {
        return payload;
    }),
    movieStartReceived: socketCreateAction("SOCKET/MOVIE_START", function (payload) {
        return payload;
    }),
    movieEndReceived: socketCreateAction("SOCKET/MOVIE_END"),
    sceneStartReceived: socketCreateAction("SOCKET/SCENE_START", function (payload) {
        return payload;
    }),
    sceneUpdateReceived: socketCreateAction("SOCKET/SCENE_UPDATE", function (payload) {
        return payload;
    }),
    sceneEndReceived: socketCreateAction("SOCKET/SCENE_END")
};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "socket.actions.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 486:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var redux_actions_1 = __webpack_require__(96);
exports.userCreateAction = function (type, payload) {
    return redux_actions_1.createAction(type, payload);
};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "user.actions.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 513:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 517:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(518));
__export(__webpack_require__(519));
__export(__webpack_require__(520));
__export(__webpack_require__(521));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "index.ts" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 518:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NavReducer = function (state, action) {
    if (state === void 0) {
        state = exports.initialNavState;
    }
    switch (action.type) {
        case 'NAV/ADD_NODE':
            var nav = action.payload;
            if (nav.parentId !== -1) {
                var parentState = state.navigation.get(nav.parentId);
                if (parentState === undefined) {
                    state.navigation.set(nav.parentId, { parentId: -1, id: nav.parentId, children: [[nav.id]], columns: 1 });
                } else {
                    var lastChildrenTuplaIndex = parentState.children.length - 1;
                    var lastChildrenTuplaLength = parentState.children[lastChildrenTuplaIndex].length;
                    if (nav.columns !== undefined && nav.columns === lastChildrenTuplaLength) {
                        parentState.children = parentState.children.concat([[nav.id]]);
                    } else {
                        if (nav.forceOrder !== undefined) {
                            var arr = parentState.children[lastChildrenTuplaIndex].slice();
                            arr.splice(nav.forceOrder, 0, nav.id);
                            parentState.children[lastChildrenTuplaIndex] = arr;
                        } else {
                            parentState.children[lastChildrenTuplaIndex] = parentState.children[lastChildrenTuplaIndex].concat([nav.id]);
                        }
                    }
                    state.navigation.set(parentState.id, parentState);
                }
            }
            var navState = state.navigation.get(nav.id);
            if (navState === undefined) {
                state.navigation.set(nav.id, nav);
            } else {
                state.navigation.set(nav.id, __assign({}, nav, navState, { parentId: nav.parentId }));
            }
            if (nav.name !== undefined) {
                state.navNames.set(nav.name, nav.id);
            }
            return state;
        case 'NAV/DELETE_NODE':
            var deleteNav = state.navigation.get(action.payload);
            if (deleteNav !== undefined && deleteNav.parentId >= 0) {
                var deleteNavParent = state.navigation.get(deleteNav.parentId);
                if (deleteNavParent !== undefined) {
                    for (var i = 0; i < deleteNavParent.children.length; i++) {
                        var index = indexOf(deleteNavParent.children[i], action.payload);
                        if (index >= 0) {
                            var children = deleteNavParent.children[i].slice();
                            children.splice(index, 1);
                            if (children.length >= 0) {
                                deleteNavParent.children[i] = children;
                            } else if (i > 0) {
                                deleteNavParent.children.splice(i, 1);
                            }
                            break;
                        }
                    }
                    state.navigation.set(deleteNavParent.id, deleteNavParent);
                }
            }
            if (deleteNav !== undefined) {
                state.navigation.delete(deleteNav.id);
            }
            return state;
        case 'NAV/KEY':
            return __assign({}, state, { lastKey: action.payload });
        case 'NAV/SELECTED':
            if (isOutOfModal(state.navigation, state.selected, action.payload)) {
                return state;
            }
            return __assign({}, state, { lastSelected: state.selected, selected: action.payload, selectedNav: state.navigation.get(action.payload) });
        case 'NAV/SELECT_LEAF':
            var id = getFirstLeaf(state, action.payload);
            return __assign({}, state, { lastSelected: state.selected, selected: id, selectedNav: state.navigation.get(id) });
        case 'NAV/ACTIVATED':
            return __assign({}, state, { lastActivated: state.activated, activated: action.payload });
        case 'NAV/MOVE_HORIZONTAL':
            var newSelected = state.selected;
            var loopSelected = state.selected;
            var current = state.navigation.get(state.selected);
            if (current !== undefined && current.parentId >= 0) {
                var parent_1 = state.navigation.get(current.parentId);
                var looping = true;
                loopWhile: while (looping) {
                    looping = false;
                    if (parent_1 === undefined) {
                        continue;
                    }
                    loop1: for (var _i = 0, _a = parent_1.children; _i < _a.length; _i++) {
                        var list = _a[_i];
                        for (var j = 0; j < list.length; j++) {
                            var num = list[j];
                            if (num === loopSelected) {
                                if (state.navigation.get(loopSelected).modal) {
                                    return state;
                                }
                                if (action.payload === 1 && j < list.length - 1) {
                                    newSelected = getFirstLeaf(state, list[j + 1]);
                                    break loopWhile;
                                } else if (action.payload === -1 && j > 0) {
                                    newSelected = getLastLeaf(state, list[j - 1]);
                                    break loopWhile;
                                } else {
                                    if (parent_1.parentId >= 0) {
                                        loopSelected = parent_1.id;
                                        parent_1 = state.navigation.get(parent_1.parentId);
                                        looping = true;
                                        break loop1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return __assign({}, state, { lastSelected: state.selected, selected: newSelected, selectedNav: state.navigation.get(newSelected) });
        case 'NAV/MOVE_VERTICAL':
            var newSelected2 = state.selected;
            var loopSelected2 = state.selected;
            var current2 = state.navigation.get(state.selected);
            if (current2 !== undefined && current2.parentId >= 0) {
                var parent_2 = state.navigation.get(current2.parentId);
                var looping = true;
                loopWhile: while (looping) {
                    looping = false;
                    if (parent_2 === undefined) {
                        continue;
                    }
                    loop1: for (var j = 0; j < parent_2.children.length; j++) {
                        if (parent_2.children[j].length > 0) {
                            var index = indexOf(parent_2.children[j], loopSelected2);
                            if (index < 0) {
                                continue;
                            }
                            var num = parent_2.children[j][index];
                            if (num === loopSelected2) {
                                if (state.navigation.get(loopSelected2).modal) {
                                    return state;
                                }
                                if (action.payload === 1 && j < parent_2.children.length - 1) {
                                    newSelected2 = getFirstLeaf(state, parent_2.children[j + 1][0]);
                                    break loopWhile;
                                } else if (action.payload === -1 && j > 0) {
                                    newSelected2 = getLastLeaf(state, parent_2.children[j - 1][0]);
                                    break loopWhile;
                                } else {
                                    if (parent_2.parentId >= 0) {
                                        loopSelected2 = parent_2.id;
                                        parent_2 = state.navigation.get(parent_2.parentId);
                                        looping = true;
                                        break loop1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return __assign({}, state, { lastSelected: state.selected, selected: newSelected2, selectedNav: state.navigation.get(newSelected2) });
        case 'NAV/SELECT_BY_NAME':
            var name_1 = action.payload;
            var selectionByName = getFirstLeaf(state, state.navNames.get(name_1));
            if (selectionByName !== undefined) {
                return __assign({}, state, { lastSelected: state.selected, selected: selectionByName, selectedNav: state.navigation.get(selectionByName) });
            } else {
                return state;
            }
        case 'NAV/SELECT_BY_ID':
            var selectionById = getFirstLeaf(state, action.payload);
            if (selectionById !== undefined) {
                return __assign({}, state, { lastSelected: state.selected, selected: selectionById, selectedNav: state.navigation.get(selectionById) });
            } else {
                return state;
            }
        default:
            return state;
    }
};
var getRecursiveChildren = function getRecursiveChildren(navigation, id) {
    var before = [];
    var node = navigation.get(id);
    if (node !== undefined) {
        for (var i = 0; i < node.children.length; i++) {
            for (var j = 0; j < node.children[i].length; j++) {
                before = before.concat([node.children[i][j]]);
                before = before.concat(getRecursiveChildren(navigation, node.children[i][j]));
            }
        }
    }
    return before;
};
var getFirstLeaf = function getFirstLeaf(state, id) {
    var current = state.navigation.get(id);
    var looping = true;
    while (current !== undefined && looping) {
        if (current.children[0].length > 0) {
            current = state.navigation.get(current.children[0][0]);
        } else {
            looping = false;
        }
    }
    if (current !== undefined) {
        return current.id;
    } else {
        return id;
    }
};
var getLastLeaf = function getLastLeaf(state, id) {
    var current = state.navigation.get(id);
    var looping = true;
    while (current !== undefined && looping) {
        if (current.forceFirst === true && current.children[0].length > 0) {
            current = state.navigation.get(current.children[0][0]);
        } else if (current.children[current.children.length - 1].length > 0) {
            var pos = current.children[current.children.length - 1][current.children[0].length - 1];
            current = state.navigation.get(pos);
        } else {
            looping = false;
        }
    }
    if (current !== undefined) {
        return current.id;
    } else {
        return id;
    }
};
var indexOf = function indexOf(array, num) {
    for (var i = 0; i < array.length; i++) {
        if (array[i] === num) {
            return i;
        }
    }
    return -1;
};
var isOutOfModal = function isOutOfModal(navigation, id, newId) {
    var idModal = -1;
    var nav;
    do {
        nav = navigation.get(id);
        if (nav === undefined) {
            break;
        }
        if (nav.modal === true) {
            idModal = nav.id;
        }
        id = nav.parentId;
    } while (idModal < 0 && id !== undefined);
    if (idModal === -1) {
        return false;
    }
    if (idModal >= 0) {
        do {
            nav = navigation.get(newId);
            if (nav.id === idModal) {
                return false;
            }
            id = nav.parentId;
        } while (idModal < 0 && id !== undefined);
    }
    return true;
};
exports.initialNavState = {
    navigation: new Map(),
    lastKey: '',
    selected: 3,
    selectedNav: undefined,
    activated: -1,
    lastSelected: -1,
    lastActivated: -1,
    navNames: new Map()
};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "nav.reducer.ts" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 519:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
;
exports.UIReducer = function (state, action) {
    if (state === void 0) {
        state = exports.initialUIState;
    }
    console.log("UIReducer: ", action);
    switch (action.type) {
        case "UI/SET_DIVIDER":
            console.log("UI/SET_DIVIDER", action.payload);
            if (action.payload === state.divider) {
                return state;
            }
            return __assign({}, state, { divider: action.payload });
        case 'UI/OPEN_SYNC':
            var newContainers = state.containers.slice();
            newContainers[1].component = 'CAROUSEL';
            return __assign({}, state, { divider: 60, containers: newContainers });
        case 'UI/OPEN':
            var newContainers2 = [{ component: action.payload.top }, { component: action.payload.bottom }];
            var dividerVal = 100;
            if (["GRID", "CAROUSEL", "HOME", "CARDS", "CARD", "PROFILE", "HELP"].indexOf(action.payload.bottom) >= 0) {
                dividerVal = 60;
            }
            if (dividerVal !== state.divider || state.containers[0].component !== newContainers2[0].component || state.containers[0].component !== newContainers2[1].component) {
                return __assign({}, state, { divider: dividerVal, containers: newContainers2 });
            } else {
                return state;
            }
        case 'UI/OPEN_CARD':
            var newContainers3 = [state.containers[0], { component: "CARD" }];
            return __assign({}, state, { divider: 60, containers: newContainers3, card: action.payload });
        case 'UI/ADD_TEST_CARDS':
            return __assign({}, state, { testCards: state.testCards.concat([action.payload]) });
        default:
            return state;
    }
};
exports.initialUIState = {
    containers: [{
        component: "EMPTY"
    }, {
        component: "CAROUSEL"
    }],
    card: undefined,
    testCards: [{ card_id: "28e7cb52-01a2-3e95-a71f-4fc2d3e46f86", version: "0jOeUIeLCaOcSI4FSebNj4+E7VZ" }, { card_id: "bd4f26ba-0c2a-3a16-bb7b-79aa066abf44" }, { card_id: "e0143d7b-1e76-11e6-97ac-0684985cbbe3" }, { "card_id": "df5b9dd1-1e76-11e6-97ac-0684985cbbe3", "version": "0jOeUIeLCaOcSI4FSebNj4+E7VZ" }, { "card_id": "f266ee0a-1e76-11e6-97ac-0684985cbbe3", "version": "0jOeUIeLCaOcSI4FSebNj4+E7VZ" }, { "card_id": "de57c239-1e76-11e6-97ac-0684985cbbe3", "version": "0jOeUIeLCaOcSI4FSebNj4+E7VZ" }, { "card_id": "f0913395-1e76-11e6-97ac-0684985cbbe3", "version": "0jOeUIeLCaOcSI4FSebNj4+E7VZ" }],
    divider: 60
};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "ui.reducer.ts" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 520:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncReducer = function (state, action) {
    if (state === void 0) {
        state = exports.initialSyncState;
    }
    switch (action.type) {
        case 'SYNC/SET_MOVIE':
            return __assign({}, state, { movieId: action.payload, cards: [] });
        case 'SYNC/UPDATE_TIME':
            return __assign({}, state, { currentTime: calcTime(state, Date.now()), lastUpdatedTime: Date.now() });
        case 'SYNC/START_SCENE':
            if (state.cards instanceof Array && action.payload instanceof Array && state.cards.length !== action.payload.length) {
                return __assign({}, state, { cards: action.payload });
            } else {
                return state;
            }
        case 'SYNC/UPDATE_SCENE':
            if (action.payload instanceof Array && action.payload.length) {
                return __assign({}, state, { cards: state.cards.concat(action.payload) });
            } else {
                return state;
            }
        case 'SYNC/END_SCENE':
            return __assign({}, state, { cards: [] });
        case 'SYNC/SET_TRAILER':
            return __assign({}, state, { demo: action.payload });
        case 'SYNC/SET_SYNC_TYPE':
            return __assign({}, state, { type: action.payload, socketStatus: 'INIT', timeMovieSynced: exports.initialSyncState.timeMovieSynced, currentTime: exports.initialSyncState.currentTime, lastUpdatedTime: exports.initialSyncState.lastUpdatedTime });
        case 'SYNC/SET_SELECTED_ON_SCENE_CHANGE':
            return __assign({}, state, { selectedOnSceneChange: action.payload });
        default:
            return state;
    }
};
var calcTime = function calcTime(state, time) {
    return (state.timeMovie + (time - state.timeMovieSynced) * state.timeRatio) / 1000;
};
exports.initialSyncState = {
    selectedOnSceneChange: true,
    socketStatus: 'INIT',
    movieId: "m00001",
    cards: [],
    demo: "",
    currentTime: 0,
    timeMovie: 0,
    timeMovieSynced: 0,
    timeRatio: 1,
    lastUpdatedTime: 0
};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "sync.reducer.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 521:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UserReducer = function (state, action) {
    if (state === void 0) {
        state = exports.initialUserState;
    }
    switch (action.type) {
        case "USER/SET_USER":
            return action.payload;
        default:
            return state;
    }
};
exports.initialUserState = {};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "user.reducer.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 522:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var react_redux_1 = __webpack_require__(52);
var Containers_1 = __webpack_require__(99);
var Actions_1 = __webpack_require__(61);
var HOC_1 = __webpack_require__(17);
var LayoutClass = function (_super) {
    __extends(LayoutClass, _super);
    function LayoutClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LayoutClass.prototype.render = function () {
        console.log("[LayoutClass] Render ", this.props.ui);
        if (this.props && this.props.ui) {
            console.log("[LayoutClass] Render OK");
            var topType = this.props.ui.containers[0].component;
            var topStyle = { height: this.props.ui.divider + "%" };
            var bottomType = this.props.ui.containers[1].component;
            var bottomStyle = { height: 100 - this.props.ui.divider + "%" };
            return React.createElement("div", { className: "containerLayout" }, React.createElement("div", { className: "layoutTop", style: topStyle }, this.getTop(topType)), React.createElement("div", { className: "layoutBottom", style: bottomStyle }, this.getBottom(bottomType)));
        } else {
            return null;
        }
    };
    LayoutClass.prototype.getTop = function (componentType) {
        return null;
    };
    LayoutClass.prototype.getBottom = function (componentType) {
        var _this = this;
        switch (componentType) {
            case 'CAROUSEL':
                return React.createElement(Containers_1.Carousel, { key: "carousel#" + this.lastTimeMenuClicked, parent: this, columns: 1, name: "CAROUSEL", groupName: "CAROUSEL", isDefault: true });
            case 'CARD':
                return this.props.ui.testCards.map(function (card, idx) {
                    return React.createElement(Containers_1.CardDetailContainer, { cardId: card.card_id, version: card.version, key: "cardDetail_" + idx, navClass: "cardDetailNav", parent: _this, columns: 1, isDefault: true });
                });
            default:
                return null;
        }
    };
    LayoutClass.prototype.componentWillMount = function () {
        console.log("[Layout] componentWillMount:", this.props);
        this.props.setDivider(this.props.ui.divider);
    };
    LayoutClass.prototype.componentWillUpdate = function (nextProps, nextState) {
        this.lastTimeMenuClicked = Date.now();
    };
    return LayoutClass;
}(React.PureComponent);
exports.LayoutClass = LayoutClass;
var mapStateToProps = function mapStateToProps(state) {
    return { ui: state.ui };
};
exports.Layout = HOC_1.navigable(react_redux_1.connect(mapStateToProps, Actions_1.UIActions)(LayoutClass));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "layout.container.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 523:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
var __rest = this && this.__rest || function (s, e) {
    var t = {};
    for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
    }return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var ReactDOM = __webpack_require__(91);
var classNames = __webpack_require__(100);
var react_redux_1 = __webpack_require__(52);
var Actions_1 = __webpack_require__(61);
window.currentNavId = 0;
var NavigableClass = function NavigableClass(InnerComponent) {
    var Navigable = function (_super) {
        __extends(Navigable, _super);
        function Navigable(props) {
            var _this = _super.call(this, props) || this;
            _this.navId = 0;
            _this.focusTracked = false;
            _this.getNewId = function () {
                return ++window.currentNavId;
            };
            _this.onMouseEnter = function () {
                var thisId = _this.getId();
                var nav = _this.props.navigation.get(thisId);
                if (nav !== undefined && nav.children[0].length === 0) {
                    _this.props.setSelected(thisId);
                    if (thisId === _this.props.selected) {
                        _this.wrapper.focus();
                    }
                }
            };
            _this.onClick = function (e) {
                e.stopPropagation();
                e.preventDefault();
                if (e.buttons !== 1 && !e.keyCode) {
                    return;
                }
                var nav = _this.props.navigation.get(_this.getId());
                var eventConsumed = false;
                if (nav !== undefined && nav.children[0].length === 0) {
                    _this.props.setActivated(nav.id);
                    eventConsumed = true;
                }
                if (_this.props.clickAction) {
                    _this.props.clickAction();
                    eventConsumed = true;
                }
                return eventConsumed;
            };
            _this.onFocus = function (e) {
                var id = _this.getId();
                var nav = _this.props.navigation.get(id);
                if (_this.props.selectedNav !== undefined) {
                    if (_this.props.selectedNav.id === id) {
                        _this.doSelfScroll(true);
                    }
                }
                if (_this.props.onFocusCallback !== undefined && (!_this.focusTracked || _this.props.onFocusCallbackRepeat)) {
                    _this.focusTracked = true;
                    _this.props.onFocusCallback();
                }
                if (nav !== undefined && nav.children[0].length === 0) {
                    return true;
                }
                e.stopPropagation();
                e.preventDefault();
            };
            _this.getId = function () {
                return _this.navId;
            };
            _this.onKeyPress = function (e) {
                e.preventDefault();
                return false;
            };
            _this.onKeyPressDown = function (e) {
                e.preventDefault();
                e.stopPropagation();
                if (e.keyCode === 13) {
                    ReactDOM.findDOMNode(_this.refComponent).click();
                    _this.onClick(e);
                }
                switch (e.key) {
                    case 'ArrowUp':
                        _this.props.moveVertical(-1);
                        break;
                    case 'ArrowRight':
                        _this.props.moveHorizontal(1);
                        break;
                    case 'ArrowLeft':
                        _this.props.moveHorizontal(-1);
                        break;
                    case 'ArrowDown':
                        _this.props.moveVertical(1);
                        break;
                    default:
                        break;
                }
                return false;
            };
            _this.isScrollable = function () {
                if (_this.isSelected()) {
                    var nav = _this.props.selectedNav;
                    do {
                        if (nav !== undefined && nav.parentId !== -1) {
                            if (nav && nav.isScrollable === true) {
                                return true;
                            }
                            nav = _this.props.navigation.get(nav.parentId);
                        } else {
                            nav = undefined;
                        }
                    } while (nav !== undefined);
                }
                return true;
            };
            _this.isSelected = function () {
                return _this.props.selected === _this.getId();
            };
            _this.getScrollableElement = function () {
                var element = _this.wrapper;
                if (element != null && element.closest instanceof Function) {
                    return element.closest('.scrollable');
                }
                return null;
            };
            _this.calculateScroll = function (HTMLList, HTMLScrollable) {
                if (_this.isScrollable() !== true) {
                    return -1;
                }
                if (document !== null && HTMLScrollable !== null) {
                    var HTMLList_1 = ReactDOM.findDOMNode(HTMLScrollable).parentElement;
                    if (HTMLList_1 !== null) {
                        var margin = 100;
                        if (_this.props.scrollPadding !== undefined) {
                            margin = _this.props.scrollPadding;
                        }
                        var left = HTMLScrollable.offsetLeft;
                        var right = HTMLScrollable.offsetWidth + HTMLScrollable.offsetLeft;
                        var width = HTMLScrollable.offsetWidth;
                        var parentLeft = HTMLList_1.offsetLeft;
                        var parentRight = HTMLList_1.offsetWidth + HTMLList_1.offsetLeft;
                        var parentWidth = HTMLList_1.offsetWidth;
                        var val = 0;
                        if (right + margin > parentRight + HTMLList_1.scrollLeft) {
                            val = right - parentWidth + margin;
                        } else if (left - margin < HTMLList_1.scrollLeft + parentLeft) {
                            val = left - margin;
                            if (val < 0) {
                                val = 0;
                            }
                        } else {
                            val = HTMLList_1.scrollLeft;
                        }
                        return val;
                    }
                }
                return -1;
            };
            _this.doSelfScroll = function (async, callback) {
                var callbackOk = callback === undefined ? function () {
                    return 0;
                } : callback;
                var HTMLItem = _this.getScrollableElement();
                var HTMLList = HTMLItem ? ReactDOM.findDOMNode(HTMLItem).parentElement : null;
                var scroll = _this.calculateScroll(HTMLList, HTMLItem);
                if (scroll >= 0 && HTMLList != null) {
                    if (async === true) {
                        setTimeout(function () {
                            HTMLList.scrollLeft = scroll;
                            return callbackOk();
                        }, 10);
                    } else {
                        HTMLList.scrollLeft = scroll;
                        return callbackOk();
                    }
                }
                return callbackOk();
            };
            _this.navId = _this.getNewId();
            return _this;
        }
        Navigable.prototype.componentDidUpdate = function () {
            var _this = this;
            if (this.getId() === this.props.selected) {
                if (this.wrapper) {
                    this.doSelfScroll(true, function () {
                        setTimeout(function () {
                            _this.wrapper.focus();
                        }, 10);
                    });
                }
            }
        };
        Navigable.prototype.componentDidMount = function () {
            var thisId = this.getId();
            var parentComponent = this.props.parent;
            var parentId = -1;
            if (parentComponent && parentComponent.props && parentComponent.props.idx !== undefined) {
                parentId = parentComponent.props.idx;
            }
            var obj = {
                parentId: parentId,
                children: [[]],
                id: thisId,
                columns: this.props.columns,
                groupName: this.props.groupName,
                forceFirst: this.props.forceFirst,
                forceOrder: this.props.forceOrder,
                modal: this.props.modal,
                isScrollable: this.props.isScrollable
            };
            this.props.addNode(obj);
            if (thisId === this.props.selected) {
                this.wrapper.focus();
            }
            if (this.props.isDefault === true) {
                this.props.setNodeById(thisId);
            } else if (this.props.selectedNav !== undefined) {
                var navSelected = this.props.selectedNav;
                var nav = this.props.navigation.get(thisId);
                if (navSelected.id === nav.parentId && navSelected.children[0][0] === thisId) {
                    this.props.setNodeById(thisId);
                }
            }
            this.forceUpdate();
        };
        Navigable.prototype.componentWillUnmount = function () {
            var thisId = this.getId();
            if (this.props.onBeforeUnmount !== undefined) {
                this.props.onBeforeUnmount(this.props.selectedNav);
            }
            if (this.props.selectedNav !== undefined) {
                var navSelected = this.props.selectedNav;
                var nav = this.props.navigation.get(thisId);
                if (navSelected.id === thisId) {
                    this.props.setNodeById(nav.parentId);
                }
            }
            this.props.deleteNode(thisId);
        };
        Navigable.prototype.render = function () {
            var _this = this;
            var thisId = this.getId();
            var off = this.props.selectedNav === undefined || this.props.groupName !== this.props.selectedNav.groupName;
            var active = thisId === this.props.activated;
            var classes = {
                navigable: true,
                navActive: active
            };
            if (this.props.navClass) {
                classes[this.props.navClass] = true;
            }
            if (this.props.focusChainClass && this.props.focusChainClass.length && this.props.selectedNav) {
                classes[this.props.focusChainClass] = this.inFocusChain(this.props.selectedNav);
            }
            if (this.props.activeGroupClass && this.props.activeGroupClass.length && !off) {
                classes[this.props.activeGroupClass] = true;
            }
            var classesApplied = classNames(classes);
            var _a = this.props,
                idx = _a.idx,
                columns = _a.columns,
                tabIndex = _a.tabIndex,
                clickAction = _a.clickAction,
                isDefault = _a.isDefault,
                onFocusCallback = _a.onFocusCallback,
                onFocusCallbackRepeat = _a.onFocusCallbackRepeat,
                forceFirst = _a.forceFirst,
                forceOrder = _a.forceOrder,
                modal = _a.modal,
                onBeforeUnmount = _a.onBeforeUnmount,
                focusChainClass = _a.focusChainClass,
                navClass = _a.navClass,
                noNavOwnProps = __rest(_a, ["idx", "columns", "tabIndex", "clickAction", "isDefault", "onFocusCallback", "onFocusCallbackRepeat", "forceFirst", "forceOrder", "modal", "onBeforeUnmount", "focusChainClass", "navClass"]);
            var navigation = noNavOwnProps.navigation,
                lastKey = noNavOwnProps.lastKey,
                selected = noNavOwnProps.selected,
                selectedNav = noNavOwnProps.selectedNav,
                lastSelected = noNavOwnProps.lastSelected,
                activated = noNavOwnProps.activated,
                lastActivated = noNavOwnProps.lastActivated,
                navNames = noNavOwnProps.navNames,
                childProps = __rest(noNavOwnProps, ["navigation", "lastKey", "selected", "selectedNav", "lastSelected", "activated", "lastActivated", "navNames"]);
            var ChildComponent = InnerComponent;
            return React.createElement("div", { ref: function ref(el) {
                    if (el) {
                        _this.wrapper = el;
                    }
                }, className: classesApplied, tabIndex: -1, key: this.props.key ? this.props.key + '_Nav' : "", onKeyUp: this.onKeyPress, onKeyDown: this.onKeyPressDown, onMouseEnter: this.onMouseEnter, onMouseDown: this.onClick, onFocus: function onFocus(e) {
                    _this.onFocus(e);
                    return false;
                }, id: thisId.toString() }, React.createElement(ChildComponent, __assign({ ref: function ref(refComponent) {
                    if (refComponent) {
                        _this.refComponent = refComponent;
                    }
                } }, childProps, { idx: thisId })));
        };
        Navigable.prototype.inFocusChain = function (navigation) {
            var nav = navigation;
            var myId = this.getId();
            if (nav) {
                if (nav.id === myId || nav.parentId === myId) {
                    return true;
                } else if (nav.parentId !== -1) {
                    return this.inFocusChain(this.props.navigation.get(nav.parentId));
                }
            }
            return false;
        };
        return Navigable;
    }(React.PureComponent);
    var mapIUIStateToProps = function mapIUIStateToProps(state) {
        return state.nav;
    };
    var connected = react_redux_1.connect(mapIUIStateToProps, Actions_1.NavActions, undefined, { withRef: true })(Navigable);
    return connected;
};
exports.navigable = NavigableClass;
exports.default = exports.navigable;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "navigable.HOC.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 524:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function statics(a) {
    return function (b) {
        return Object.assign(b, a);
    };
}
exports.statics = statics;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "statics.HOC.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 525:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var react_redux_1 = __webpack_require__(52);
var Containers_1 = __webpack_require__(99);
var Actions_1 = __webpack_require__(61);
var AppClass = function (_super) {
    __extends(AppClass, _super);
    function AppClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AppClass.prototype.componentWillMount = function () {};
    AppClass.prototype.render = function () {
        return React.createElement("div", { className: "app" }, React.createElement(Containers_1.Layout, { columns: 1, parent: this }));
    };
    return AppClass;
}(React.Component);
exports.AppClass = AppClass;
function mapStateToProps(state) {
    return {};
}
function mapDispatchToProps(dispatch) {
    return __assign({}, Actions_1.UIActions);
}
function mergeProps(stateProps, dispatchProps, ownProps) {
    return __assign({}, stateProps, ownProps, dispatchProps);
}
exports.App = react_redux_1.connect(mapStateToProps, mapDispatchToProps, mergeProps)(AppClass);

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "app.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 526:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var CardModules_1 = __webpack_require__(267);
var HOC_1 = __webpack_require__(17);
var Components_1 = __webpack_require__(20);
var CardModuleList = function (_super) {
    __extends(CardModuleList, _super);
    function CardModuleList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CardModuleList.prototype.render = function () {
        return React.createElement("div", { className: "cardModulesContainer" }, this.props.card ? this.decideModules(this.props.card) : React.createElement(Components_1.Loading, null));
    };
    CardModuleList.prototype.decideModules = function (card) {
        var _this = this;
        var modules = [];
        var moduleList = [];
        var cardModuleOrder = CardModules_1.cardModuleConfig[card.type];
        if (card.type && cardModuleOrder && cardModuleOrder.sections && cardModuleOrder.sections[0] && cardModuleOrder.sections[0].modules instanceof Array) {
            cardModuleOrder.sections[0].modules.map(function (cardModule, idx) {
                if (cardModule.type && cardModule.type !== "") {
                    var candidate = CardModules_1.cardModuleClasses[cardModule.type];
                    if (CardModules_1.isValidatable(candidate)) {
                        if (candidate) {
                            console.warn("Instantiating", cardModule.type);
                            var moduleInstance = candidate.validate(card, cardModule.type, _this, {
                                isScrollable: true,
                                scrollPadding: 300
                            });
                            if (moduleInstance) {
                                console.warn("Instantiating because validated", cardModule.type);
                                var navClass = candidate.moduleName ? candidate.moduleName.toLocaleLowerCase() + "-container cardModule-container scrollable" : "container";
                                moduleList.push(React.createElement("div", { className: navClass, key: card.card_id + "_module_" + idx }, moduleInstance));
                            }
                        } else {
                            console.warn("No existe el módulo o no ha validado", cardModule.type);
                        }
                    } else {
                        console.warn("No existe el módulo", cardModule.type);
                    }
                }
                return undefined;
            });
        }
        return moduleList;
    };
    return CardModuleList;
}(React.PureComponent);
exports.CardModuleList = CardModuleList;
exports.NavigableCardModuleList = HOC_1.navigable(CardModuleList);

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "cardModuleList.container.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 527:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var artConfig = __webpack_require__(528);
var businessConfig = __webpack_require__(529);
var chapterConfig = __webpack_require__(530);
var fashionConfig = __webpack_require__(531);
var fauna_floraConfig = __webpack_require__(532);
var food_drinkConfig = __webpack_require__(533);
var health_beautyConfig = __webpack_require__(534);
var historicConfig = __webpack_require__(535);
var homeConfig = __webpack_require__(536);
var leisure_sportConfig = __webpack_require__(537);
var locationConfig = __webpack_require__(538);
var lookConfig = __webpack_require__(539);
var movieConfig = __webpack_require__(540);
var ostConfig = __webpack_require__(541);
var personConfig = __webpack_require__(542);
var characterConfig = __webpack_require__(543);
var referenceConfig = __webpack_require__(544);
var serieConfig = __webpack_require__(545);
var songConfig = __webpack_require__(546);
var technologyConfig = __webpack_require__(547);
var triviaConfig = __webpack_require__(548);
var vehicleConfig = __webpack_require__(549);
var weaponConfig = __webpack_require__(550);
var cardDetailConfig = {
    artConfig: artConfig,
    businessConfig: businessConfig,
    chapterConfig: chapterConfig,
    fashionConfig: fashionConfig,
    fauna_floraConfig: fauna_floraConfig,
    food_drinkConfig: food_drinkConfig,
    health_beautyConfig: health_beautyConfig,
    historicConfig: historicConfig,
    homeConfig: homeConfig,
    leisure_sportConfig: leisure_sportConfig,
    locationConfig: locationConfig,
    lookConfig: lookConfig,
    movieConfig: movieConfig,
    ostConfig: ostConfig,
    personConfig: personConfig,
    characterConfig: characterConfig,
    referenceConfig: referenceConfig,
    serieConfig: serieConfig,
    songConfig: songConfig,
    technologyConfig: technologyConfig,
    triviaConfig: triviaConfig,
    vehicleConfig: vehicleConfig,
    weaponConfig: weaponConfig
};
exports.cardModuleConfig = {
    art: cardDetailConfig.artConfig,
    business: cardDetailConfig.businessConfig,
    chapter: cardDetailConfig.chapterConfig,
    fashion: cardDetailConfig.fashionConfig,
    fauna_flora: cardDetailConfig.fauna_floraConfig,
    food_drink: cardDetailConfig.food_drinkConfig,
    health_beauty: cardDetailConfig.health_beautyConfig,
    historic: cardDetailConfig.historicConfig,
    home: cardDetailConfig.homeConfig,
    leisure_sport: cardDetailConfig.leisure_sportConfig,
    location: cardDetailConfig.locationConfig,
    look: cardDetailConfig.lookConfig,
    movie: cardDetailConfig.movieConfig,
    ost: cardDetailConfig.ostConfig,
    person: cardDetailConfig.personConfig,
    character: cardDetailConfig.characterConfig,
    reference: cardDetailConfig.referenceConfig,
    serie: cardDetailConfig.serieConfig,
    song: cardDetailConfig.songConfig,
    technology: cardDetailConfig.technologyConfig,
    trivia: cardDetailConfig.triviaConfig,
    vehicle: cardDetailConfig.vehicleConfig,
    weapon: cardDetailConfig.weaponConfig
};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "cardDetail.config.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 528:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Specifications"},{"type":"MapModule"},{"type":"Gallery"},{"type":"Curiosities"},{"type":"AppearsIn"},{"type":"AppearsInSingle"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 529:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Specifications"},{"type":"Gallery"},{"type":"Curiosities"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 530:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"MovieHeader"},{"type":"MovieHeaderSmall"},{"type":"Overview"},{"type":"BasicInfo"},{"type":"Trailer"},{"type":"Cast"},{"type":"BelongToSingle"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Curiosities"},{"type":"PlacesShown"},{"type":"Vehicles"},{"type":"MovieSoundtrack"},{"type":"Highlights"},{"type":"DiveInModule"},{"type":"Recommended"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 531:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"ButtonHeader"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Specifications"},{"type":"Gallery"},{"type":"Fashion"},{"type":"Curiosities"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 532:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Specifications"},{"type":"Gallery"},{"type":"Curiosities"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 533:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Specifications"},{"type":"Gallery"},{"type":"Video"},{"type":"Curiosities"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 534:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Specifications"},{"type":"Gallery"},{"type":"Curiosities"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 535:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"MapModule"},{"type":"Gallery"},{"type":"Curiosities"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 536:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"ButtonHeader"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Specifications"},{"type":"Gallery"},{"type":"Home"},{"type":"CompleteTheDeco"},{"type":"Curiosities"},{"type":"AppearsIn"},{"type":"AppearsInSingle"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 537:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Specifications"},{"type":"Gallery"},{"type":"Curiosities"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 538:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"BasicInfo"},{"type":"Gallery"},{"type":"MapModule"},{"type":"Curiosities"},{"type":"AppearsInLocation"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 539:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"ButtonHeader"},{"type":"Description"},{"type":"Specifications"},{"type":"Gallery"},{"type":"Look"},{"type":"Carry"},{"type":"MoreLooks"},{"type":"Curiosities"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 540:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"MovieHeader"},{"type":"MovieHeaderSmall"},{"type":"Overview"},{"type":"BasicInfo"},{"type":"Trailer"},{"type":"Cast"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Curiosities"},{"type":"PlacesShown"},{"type":"Vehicles"},{"type":"MovieSoundtrack"},{"type":"Highlights"},{"type":"DiveInModule"},{"type":"Recommended"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 541:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Soundtrack"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"SoundsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 542:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Biography"},{"type":"BasicInfo"},{"type":"Gallery"},{"type":"AwardsModuleList"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Curiosities"},{"type":"Filmography"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 543:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Biography"},{"type":"Shop"},{"type":"TravelShop"},{"type":"BasicInfo"},{"type":"Gallery"},{"type":"Video"},{"type":"Curiosities"},{"type":"Highligts"},{"type":"InterpretedBySingle"},{"type":"InterpretedBy"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 544:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Reference"},{"type":"Gallery"},{"type":"Video"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 545:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"MovieHeader"},{"type":"MovieHeaderSmall"},{"type":"Overview"},{"type":"Seasons"},{"type":"Trailer"},{"type":"BasicInfo"},{"type":"Gallery"},{"type":"AwardsModuleList"},{"type":"Cast"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Recommended"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 546:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"MusicShop"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Curiosities"},{"type":"SongBelongToSingle"},{"type":"SongBelongTo"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 547:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Specifications"},{"type":"Gallery"},{"type":"Video"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 548:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"FullCuriosity"},{"type":"Gallery"},{"type":"Video"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 549:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Specifications"},{"type":"Gallery"},{"type":"Video"},{"type":"Curiosities"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 550:
/***/ (function(module, exports) {

module.exports = {"sections":[{"title":"main","main":true,"modules":[{"type":"Header"},{"type":"Description"},{"type":"Shop"},{"type":"TravelShop"},{"type":"Specifications"},{"type":"Gallery"},{"type":"Curiosities"},{"type":"AppearsInSingle"},{"type":"AppearsIn"},{"type":"BackToHome"}]}]}

/***/ }),

/***/ 551:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function isValidatable(object) {
    return object && 'validate' in object;
}
exports.isValidatable = isValidatable;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "cardModule.base.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 552:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var Services_1 = __webpack_require__(33);
var Components_1 = __webpack_require__(20);
var HOC_1 = __webpack_require__(17);
var Header = function (_super) {
    __extends(Header, _super);
    function Header() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Header_1 = Header;
    Header.prototype.getSubtitle = function () {
        if (this.props.navigableSubtitle && this.props.subtitle) {
            return React.createElement("div", { className: "subtitle" }, React.createElement(Components_1.NavigationContainer, { parent: this, columns: 1 }, this.props.subtitle));
        } else if (this.props.subtitle) {
            return React.createElement("div", { className: "subtitle" }, this.props.subtitle);
        } else {
            return null;
        }
    };
    Header.prototype.render = function () {
        var subtitle = this.getSubtitle();
        return React.createElement("div", { className: "header cardModule" }, React.createElement(Components_1.CardAndCategory, { card: this.props.card }), React.createElement("div", { className: "rightPart" }, React.createElement("div", { className: "info" }, React.createElement("div", { className: "titleContainer" }, React.createElement("p", { className: "title" }, this.props.title), this.props.titleParenthesis ? React.createElement("div", { className: "titleParenthesis" }, " (", this.props.titleParenthesis, ")") : null), subtitle, this.props.categories ? React.createElement("div", { className: "categories" }, this.props.categories) : null, this.props.time ? React.createElement("div", { className: "time" }, React.createElement("i", { className: "clock" }), React.createElement("span", null, this.props.time)) : null, React.createElement("div", { className: "headerButtons" }, React.createElement(Components_1.NavigationContainer, { parent: this, columns: 1, isDefault: true, className: "likeButton genericBtn" }, React.createElement("div", { className: "centeredContent" }, React.createElement("i", { className: "icon like" }), React.createElement("span", null, Services_1.Localize("CAROUSEL_CARD_SAVE"))))))));
    };
    Header = Header_1 = __decorate([HOC_1.statics({
        moduleName: "header",
        validate: function validate(card, moduleType, parent, props) {
            var title = card.title;
            var subtitle = card.subtitle && card.subtitle !== "" ? card.subtitle : null;
            var time = null;
            var titleParenthesis = null;
            var categories = null;
            var navigableSubtitle = false;
            switch (card.type) {
                case "movie":
                case "serie":
                case "chapter":
                    var catalogInfo = Services_1.Helper.getContainer(card, "catalog");
                    if (catalogInfo && catalogInfo.data && catalogInfo.data[0]) {
                        var mediaData = catalogInfo.data[0];
                        if (mediaData.runtime) {
                            var currentTimeInSecs = mediaData.runtime;
                            var hours = Math.floor(currentTimeInSecs / 3600);
                            currentTimeInSecs %= 3600;
                            var minutes = Math.floor(currentTimeInSecs / 60);
                            time = minutes + " m";
                            if (hours > 0) {
                                time = hours + " h " + time;
                            }
                        }
                        if (mediaData.year) {
                            titleParenthesis = "" + catalogInfo.data[0].year;
                        }
                        if (mediaData.genres && mediaData.genres.length > 0) {
                            categories = mediaData.genres.join(", ");
                        }
                        if (mediaData.director && mediaData.director !== "") {
                            subtitle = mediaData.director;
                            navigableSubtitle = true;
                        }
                    }
                    break;
            }
            var Instantiated = HOC_1.navigable(Header_1);
            return React.createElement(Instantiated, __assign({ parent: parent, isScrollable: true, card: card, moduleType: moduleType, title: title, subtitle: subtitle, navigableSubtitle: navigableSubtitle, time: time, titleParenthesis: titleParenthesis, categories: categories }, props));
        }
    })], Header);
    return Header;
    var Header_1;
}(React.PureComponent);
exports.Header = Header;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "header.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 553:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var HelperClass = function () {
    function HelperClass() {
        this.getContainer = function (card, type) {
            return card.info ? card.info.filter(function (el) {
                return el.type === type;
            })[0] : undefined;
        };
        this.getRelation = function (relations, value, field) {
            if (field === void 0) {
                field = 'type';
            }
            return relations ? relations.filter(function (el) {
                return el[field] === value;
            })[0] : undefined;
        };
        this.cutText = function (text, count) {
            if (text.length > count) {
                if (count + 3 >= text.length) {
                    count -= 2;
                }
                return text.substring(0, count) + '...';
            } else {
                return text;
            }
        };
    }
    return HelperClass;
}();
exports.Helper = new HelperClass();

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "helper.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 554:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var memoizee = __webpack_require__(555);
var ES = __webpack_require__(611);
var EN = __webpack_require__(612);
var DE = __webpack_require__(613);
var LocalizeService = function () {
    function LocalizeService() {
        this.language = "EN";
        this.texts = {
            EN: EN,
            ES: ES,
            DE: DE
        };
    }
    LocalizeService.prototype.setLanguage = function (lang) {
        this.language = lang;
    };
    LocalizeService.prototype.getLanguage = function () {
        return this.language;
    };
    LocalizeService.prototype.getLiteral = function (id) {
        var _this = this;
        var substitutions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            substitutions[_i - 1] = arguments[_i];
        }
        if (typeof id === "string") {
            var baseText = this.getLiteralWithLanguage(id, this.language) || "";
            var textBlockArray = baseText.split("\\n");
            for (var i = 0, write = 1, length_1 = textBlockArray.length; i < length_1 - 1; i++) {
                textBlockArray.splice(write, 0, React.createElement("br", { key: i }));
                write += 2;
            }
            var resultArray_1 = [];
            textBlockArray.map(function (textBlock) {
                if (typeof textBlock === "string") {
                    var textArray = textBlock.split(/%[\d]+\$s/);
                    var maxLoop = Math.min(textArray.length - 1, substitutions.length);
                    for (var i = 0, write = 1; i < maxLoop; i++) {
                        var text = "";
                        if (substitutions[i]) {
                            text = _this.getLiteral(substitutions[i]) || "";
                        }
                        textArray.splice(write, 0, React.createElement("span", { className: "substitution substitution-" + (i + 1) + " " + id + "-" + substitutions[i], "data-index": "" + i }, text));
                        write += 2;
                    }
                    resultArray_1.push(textArray);
                } else {
                    resultArray_1.push(textBlock);
                }
            });
            return resultArray_1;
        } else {
            return "";
        }
    };
    LocalizeService.prototype.getLiteralWithLanguage = function (id, language) {
        try {
            var text = this.texts[language][id];
            if (!text) {
                console.error("Missing literal in " + language + ", " + id);
                throw new Error("Missing literal in " + language + ", " + id);
            }
            return text;
        } catch (e) {
            var text = this.texts.EN[id];
            if (text) {
                return text;
            } else {
                return "Missing literal";
            }
        }
    };
    LocalizeService.prototype.textToMarkupWithLineBreaks = function (text, separator) {
        if (separator === void 0) {
            separator = "\\n";
        }
        if (typeof text === "string") {
            return text.split(separator).map(function (item, key) {
                return React.createElement("p", { key: key }, item);
            });
        }
    };
    return LocalizeService;
}();
exports.Localized = new LocalizeService();
exports.Localize = memoizee(exports.Localized.getLiteral.bind(exports.Localized));
window.Localized = exports.Localized;
window.Localize = exports.Localized.getLiteral.bind(exports.Localized);

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "localized_texts.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 61:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(441));
__export(__webpack_require__(483));
__export(__webpack_require__(484));
__export(__webpack_require__(485));
__export(__webpack_require__(486));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "index.ts" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 611:
/***/ (function(module, exports) {

module.exports = {"VERSION_OUTDATED_TITLE":"","VERSION_OUTDATED_TEXT":"","VERSION_DEPRECATED_TITLE":"","VERSION_DEPRECATED_TEXT":"","GOT_IT":"","NOW_TITLE":"","NOW_SUBTITLE":"","UPCOMING_TITLE":"","GRID_NO_DATA_TEXT":"","TRY_DEMO":"","MENU_SETTINGS":"","MENU_DEMO":"DEMO","MENU_PROFILE":"PERFIL","MENU_CARDS":"MIS CARDS","MENU_SYNC":"DIVE IN","SEE_INFO":"","TVGRID_BROADCAST_TITLE1":"Ahora en TV","TVGRID_BROADCAST_TITLE2":"Test de traducción","TVGRID_UPCOMING_TITLE":"","TVGRID_BROADCAST_NO_CONTENT":"","TVGRID_BROADCAST_NO_CONTENT_TRY_DEMO":"","TVGRID_UPCOMING_NO_CONTENT":"","TVGRID_UPCOMING_NO_CONTENT_TRY_DEMO":"","GENERIC_ERROR_TITLE":"","GENERIC_ERROR_TEXT":"","EXIT_TITLE":"","EXIT_TEXT":"","EXIT_BUTTON_OK":"","NETWORK_ERROR_TITLE":"","NETWORK_ERROR_TEXT":"","TVGRID_EMPTY_BROADCAST_TITLE1":"","TVGRID_EMPTY_BROADCAST_TITLE2":"","TVGRID_EMPTY_UPCOMING_TXT1":"","TVGRID_EMPTY_UPCOMING_TXT2":"","TVGRID_EMPTY_WATCH_OUR_DEMO":"","SELECTOR_ALL_CATEGORIES":"","SELECTOR_CAST_CHARACTER":"","SELECTOR_FASHION_BEAUTY":"","SELECTOR_MUSIC":"","SELECTOR_PLACES_TRAVEL":"","SELECTOR_CARS_MORE":"","SELECTOR_FUN_FACTS":"","SELECTOR_OTHER_CATEGORIES":"","BIOGRAPHY":"Biografía","COMEDY":"Comedia","CRIME":"Crimen","ACTION":"Acción","THRILLER":"Suspense","ADVENTURE":"Aventuras","SCI_FI":"Ciencia ficción","FANTASY":"Fantasía","DRAMA":"Drama","ROMANCE":"Romántica","TERROR":"Terror","HISTORY":"Histórica","WESTERN":"Western","WAR":"Bélicas","MISTERY":"Misterio","FAMILY":"Familar","SPORT":"Deporte","MUSIC":"Música","MUSICAL":"Musical","ANIMATION":"Animación","DOCUMENTARY":"Documental","FILM_NOIR":"Cine negro","NEWS":"Noticias","KIDS":"Infantil","TALK_SHOW":"Entrevistas","CURRENT_SCENE":"","PIZZA_OR_POP_CORN":"","WE_RECOMMEND":"","MAKE_POP_CORN":"","LIGHTS_CAMERA":"","WE_ARE_LOADING":"","EVERYTHING_END":"","MOVIE_OFF":"","MOVIE_ENDED":"","OKAY":"","CAROUSEL_CARD_SAVE":"","CAROUSEL_CARD_SAVED":"","CAROUSEL_NEW_CARD_ADDED":"","CAROUSEL_NEW_CARDS_ADDED":"","TVGRID_COMMERCIAL_TXT":"","TVGRID_TODAY":"","TVGRID_TOMORROW":"","EXIT_BUTTON_CANCEL":"","ERROR_SCAN_CHANNELS_TITLE":"","ERROR_SCAN_CHANNELS_TEXT":"","ERROR_SCAN_CHANNELS_BTN_SCAN":"","SCAN_FIRST_TIME_TITLE":"","SCAN_FIRST_TIME_TEXT":"","SCAN_FIRST_TIME_BTN":"","SCAN_HELP_RESCAN_TITLE":"","SCAN_HELP_RESCAN_TEXT":"","SCAN_HELP_RESCAN_BTN":"","SCAN_HELP_TITLE_1":"","SCAN_HELP_TITLE_2":"","SCAN_HELP_SUGGESTION":"","SCAN_HELP_PLEASE_CONTACT":"","SCAN_HELP_EMAIL":"","SCAN_HELP_SUBJECT":"","SCAN_HELP_VERSION":"","REGION_SET_TITLE":"","REGION_SET_TEXT":"","REGION_SET_SPAIN":"","REGION_SET_GERMANY":"","REGION_SET_USA":"","TVGRID_CHANGE_CHANNEL_TITLE":"","TVGRID_CHANGE_CHANNEL_TEXT":"","TVGRID_CHANGE_CHANNEL_BTN":"","CAROUSEL_ALIAS_MOVIE":"","CAROUSEL_ALIAS_SERIE":"","CAROUSEL_ALIAS_PERSON":"","CAROUSEL_ALIAS_CHARACTER":"","CAROUSEL_ALIAS_VEHICLE":"","CAROUSEL_ALIAS_FASHION":"","CAROUSEL_ALIAS_LOCATION":"","CAROUSEL_ALIAS_HISTORIC":"","CAROUSEL_ALIAS_TRIVIA":"","CAROUSEL_ALIAS_QUOTE":"","CAROUSEL_ALIAS_OST":"","CAROUSEL_ALIAS_HOME":"","CAROUSEL_ALIAS_TECHNOLOGY":"","CAROUSEL_ALIAS_ART":"","CAROUSEL_ALIAS_SONG":"","CAROUSEL_ALIAS_LOOK":"","CAROUSEL_ALIAS_TRAILER":"","CAROUSEL_ALIAS_WEAPON":"","CAROUSEL_ALIAS_LEISURE_SPORT":"","CAROUSEL_ALIAS_HEALTH_BEAUTY":"","CAROUSEL_ALIAS_FOOD_DRINK":"","CAROUSEL_ALIAS_FAUNA_FLORA":"","CAROUSEL_ALIAS_BUSINESS":"","CAROUSEL_ALIAS_REFERENCE":"","CAROUSEL_ALIAS_VIDEOCLIP":"","CAROUSEL_ALIAS_CHAPTER":"","CAROUSEL_ALIAS_ACTION_EMOTION":"","CAROUSEL_ALIAS_SEE_MORE":"","SOURCE":"","SPECS":"","BASIC_DATA":"","AWARDS":"","WINNER_SINGULAR":"Premio","WINNER_PLURAL":"Premios","NOMINEE_SINGULAR":"Nominación","NOMINEE_PLURAL":"Nominaciones","POCKET_TITLE_1":"","POCKET_TITLE_2":"","POCKET_NO_CARDS_TITLE":"","POCKET_NO_CARDS_TXT":"","GALLERY":"Galería","LOCATION":"Localización","CURIOSITY_TITLE":"","OVERVIEW":""}

/***/ }),

/***/ 612:
/***/ (function(module, exports) {

module.exports = {"VERSION_OUTDATED_TITLE":"Warning","VERSION_OUTDATED_TEXT":"The version you've installed is outdated.\\nYou need to upgrade now to the latest version in order to continue enjoying Dive.","VERSION_DEPRECATED_TITLE":"Warning","VERSION_DEPRECATED_TEXT":"The version you've installed is outdated.\\nA new version of Dive is available for you.\\nYou can update or continue with an old version of Dive.","GOT_IT":"GOT IT","NOW_TITLE":"NOW ON TV","NOW_SUBTITLE":"What will you discover?","UPCOMING_TITLE":"UPCOMING","GRID_NO_DATA_TEXT":"At the moment, there is nothing available to sync with Dive. Have you tried the demo?","TRY_DEMO":"TRY DEMO","MENU_SETTINGS":"SETTINGS","MENU_DEMO":"DEMO","MENU_PROFILE":"PROFILE","MENU_CARDS":"MY CARDS","MENU_SYNC":"DIVE IN","SEE_INFO":"SEE INFO","TVGRID_BROADCAST_TITLE1":"Now on TV","TVGRID_BROADCAST_TITLE2":"What will you discover?","TVGRID_UPCOMING_TITLE":"Upcoming…","TVGRID_BROADCAST_NO_CONTENT":"At the moment, there is nothing available to sync with Dive. Have you tried the demo?","TVGRID_BROADCAST_NO_CONTENT_TRY_DEMO":"Try demo","TVGRID_UPCOMING_NO_CONTENT":"No content available on our guide. Try again later or try our demo.","TVGRID_UPCOMING_NO_CONTENT_TRY_DEMO":"Try demo","GENERIC_ERROR_TITLE":"¡HOUSTON! WE’VE A PROBLEM…","GENERIC_ERROR_TEXT":"Were having some issues with the app. We’re working on it to fix it, please try again or come back again in a few minutes.","EXIT_TITLE":"PLEASE, DON’T GO.","EXIT_TEXT":"You\\'re about to leave Dive.\\nAre you sure you want to exit?","EXIT_BUTTON_OK":"YES, EXIT","NETWORK_ERROR_TITLE":"INTERNET CONNECTION REQUIRED","NETWORK_ERROR_TEXT":"No connection detected. \\nGo to settings and verify if your Internet is working.","TVGRID_EMPTY_BROADCAST_TITLE1":"This is awkward","TVGRID_EMPTY_BROADCAST_TITLE2":"What can I do?","TVGRID_EMPTY_UPCOMING_TXT1":"There's no content right now.\\nCheck later or enjoy %1$s.","TVGRID_EMPTY_UPCOMING_TXT2":"Dive on your phone","TVGRID_EMPTY_WATCH_OUR_DEMO":"Watch\\nour\\ndemo","SELECTOR_ALL_CATEGORIES":"All categories","SELECTOR_CAST_CHARACTER":"Cast & Character","SELECTOR_FASHION_BEAUTY":"Fashion & Beauty","SELECTOR_MUSIC":"Music","SELECTOR_PLACES_TRAVEL":"Places & Travel","SELECTOR_CARS_MORE":"Cars & More","SELECTOR_FUN_FACTS":"Fun facts","SELECTOR_OTHER_CATEGORIES":"Categories","BIOGRAPHY":"Biography","COMEDY":"Comedy","CRIME":"Crime","ACTION":"Action","THRILLER":"Thriller","ADVENTURE":"Adventure","SCI_FI":"Sci-Fi","FANTASY":"Fantasy","DRAMA":"Drama","ROMANCE":"Romance","TERROR":"Horror","HISTORY":"History","WESTERN":"Western","WAR":"War","MISTERY":"Mystery","FAMILY":"Family","SPORT":"Sport","MUSIC":"Music","MUSICAL":"Musical","ANIMATION":"Animation","DOCUMENTARY":"Documentary","FILM_NOIR":"Film-Noir","NEWS":"News","KIDS":"Kids","TALK_SHOW":"Talk-Show","CURRENT_SCENE":"Current Scene","PIZZA_OR_POP_CORN":"PIZZA OR POP CORN?","WE_RECOMMEND":"The show you’re watching is on advertising, we recommend:","MAKE_POP_CORN":"1. Make more Pop Corn.\n2. And browse the content while we’re on a break","LIGHTS_CAMERA":"LIGHTS, CAMERA AND ACTION","WE_ARE_LOADING":"We're loading the content you're watching on TV.","EVERYTHING_END":"EVERYTHING HAS AN END","MOVIE_OFF":"The broadcast has been interrupted.","MOVIE_ENDED":"The movie has ended","OKAY":"OKAY","CAROUSEL_CARD_SAVE":"Save for later","CAROUSEL_CARD_SAVED":"Saved","CAROUSEL_NEW_CARD_ADDED":"1 new card has been added!","CAROUSEL_NEW_CARDS_ADDED":"%1$d new cards have been added!","TVGRID_COMMERCIAL_TXT":"Enjoy Dive on your phone","TVGRID_TODAY":"Today","TVGRID_TOMORROW":"Tomorrow","EXIT_BUTTON_CANCEL":"NO, I DON'T WANT TO","ERROR_SCAN_CHANNELS_TITLE":"RE-SCAN TV CHANNELS","ERROR_SCAN_CHANNELS_TEXT":"This channel is not set yet, please re-scan to add the new channels.\\nWe need this to set the TV signal.","ERROR_SCAN_CHANNELS_BTN_SCAN":"OK, START SCAN","SCAN_FIRST_TIME_TITLE":"LET’S SET THE TV SIGNAL","SCAN_FIRST_TIME_TEXT":"We need to scan the channels to set the TV signal.\\nYou’ll be able to re-scan the channels in your menu if you want to add more.","SCAN_FIRST_TIME_BTN":"OK, START SCAN","SCAN_HELP_RESCAN_TITLE":"RE-SCAN TV CHANNELS","SCAN_HELP_RESCAN_TEXT":"Re-scan to add new channels.\\nWe need this to set the TV signal.","SCAN_HELP_RESCAN_BTN":"OK, START SCAN","SCAN_HELP_TITLE_1":"SETTINGS","SCAN_HELP_TITLE_2":"Set your Dive experience","SCAN_HELP_SUGGESTION":"Something wrong? Any suggestions?","SCAN_HELP_PLEASE_CONTACT":"For customer support please contact:","SCAN_HELP_EMAIL":"support@dive.tv","SCAN_HELP_SUBJECT":"Write TV in the subject line and we will contact you as soon as possible.","SCAN_HELP_VERSION":"DIVE v%1$s","REGION_SET_TITLE":"FIRST THINGS, FIRST…","REGION_SET_TEXT":"We need to know where you are to show you the TV contents available to sync with.","REGION_SET_SPAIN":"SPAIN","REGION_SET_GERMANY":"GERMANY","REGION_SET_USA":"USA","TVGRID_CHANGE_CHANNEL_TITLE":"CHANNEL CHANGE","TVGRID_CHANGE_CHANNEL_TEXT":"Please confirm that you\\'ve changed the channel so that we can load the content of %1$s.","TVGRID_CHANGE_CHANNEL_BTN":"CONFIRM","CAROUSEL_ALIAS_MOVIE":"Movie","CAROUSEL_ALIAS_SERIE":"Serie","CAROUSEL_ALIAS_PERSON":"Person","CAROUSEL_ALIAS_CHARACTER":"Character","CAROUSEL_ALIAS_VEHICLE":"Vehicle","CAROUSEL_ALIAS_FASHION":"Fashion","CAROUSEL_ALIAS_LOCATION":"Location","CAROUSEL_ALIAS_HISTORIC":"Historic","CAROUSEL_ALIAS_TRIVIA":"Trivia","CAROUSEL_ALIAS_QUOTE":"Quote","CAROUSEL_ALIAS_OST":"OST","CAROUSEL_ALIAS_HOME":"Home","CAROUSEL_ALIAS_TECHNOLOGY":"Technology","CAROUSEL_ALIAS_ART":"Art","CAROUSEL_ALIAS_SONG":"Song","CAROUSEL_ALIAS_LOOK":"Look","CAROUSEL_ALIAS_TRAILER":"Trailer","CAROUSEL_ALIAS_WEAPON":"Weapon","CAROUSEL_ALIAS_LEISURE_SPORT":"Leisure Sport","CAROUSEL_ALIAS_HEALTH_BEAUTY":"Health & Beauty","CAROUSEL_ALIAS_FOOD_DRINK":"Food & Drink","CAROUSEL_ALIAS_FAUNA_FLORA":"Fauna & Flora","CAROUSEL_ALIAS_BUSINESS":"Business","CAROUSEL_ALIAS_REFERENCE":"Reference","CAROUSEL_ALIAS_VIDEOCLIP":"Videoclip","CAROUSEL_ALIAS_CHAPTER":"Chapter","CAROUSEL_ALIAS_ACTION_EMOTION":"Action & Emotion","CAROUSEL_ALIAS_SEE_MORE":"Explore More","SOURCE":"Source","SPECS":"Specs","BASIC_DATA":"Basic Data","AWARDS":"Awards","WINNER_SINGULAR":"","WINNER_PLURAL":"","NOMINEE_SINGULAR":"","NOMINEE_PLURAL":"","POCKET_TITLE_1":"MY CARDS","POCKET_TITLE_2":"The content you\\'ve liked","POCKET_NO_CARDS_TITLE":"NO SAVED CARDS YET","POCKET_NO_CARDS_TXT":"Save every card you like by pressing on the heart icon or activate your account to see the cards saved from your Dive mobile version.","GALLERY":"Gallery","LOCATION":"Location","CURIOSITY_TITLE":"Did you know...?","OVERVIEW":"Synopsis"}

/***/ }),

/***/ 613:
/***/ (function(module, exports) {

module.exports = {"VERSION_OUTDATED_TITLE":"","VERSION_OUTDATED_TEXT":"","VERSION_DEPRECATED_TITLE":"","VERSION_DEPRECATED_TEXT":"","GOT_IT":"","NOW_TITLE":"","NOW_SUBTITLE":"","UPCOMING_TITLE":"","GRID_NO_DATA_TEXT":"","TRY_DEMO":"","MENU_SETTINGS":"","MENU_DEMO":"","MENU_PROFILE":"","MENU_CARDS":"","MENU_SYNC":"","SEE_INFO":"","TVGRID_BROADCAST_TITLE1":"","TVGRID_BROADCAST_TITLE2":"","TVGRID_UPCOMING_TITLE":"","TVGRID_BROADCAST_NO_CONTENT":"","TVGRID_BROADCAST_NO_CONTENT_TRY_DEMO":"","TVGRID_UPCOMING_NO_CONTENT":"","TVGRID_UPCOMING_NO_CONTENT_TRY_DEMO":"","GENERIC_ERROR_TITLE":"","GENERIC_ERROR_TEXT":"","EXIT_TITLE":"","EXIT_TEXT":"","EXIT_BUTTON_OK":"","NETWORK_ERROR_TITLE":"","NETWORK_ERROR_TEXT":"","TVGRID_EMPTY_BROADCAST_TITLE1":"","TVGRID_EMPTY_BROADCAST_TITLE2":"","TVGRID_EMPTY_UPCOMING_TXT1":"","TVGRID_EMPTY_UPCOMING_TXT2":"","TVGRID_EMPTY_WATCH_OUR_DEMO":"","SELECTOR_ALL_CATEGORIES":"","SELECTOR_CAST_CHARACTER":"","SELECTOR_FASHION_BEAUTY":"","SELECTOR_MUSIC":"","SELECTOR_PLACES_TRAVEL":"","SELECTOR_CARS_MORE":"","SELECTOR_FUN_FACTS":"","SELECTOR_OTHER_CATEGORIES":"","BIOGRAPHY":"Biographie","COMEDY":"Comedy","CRIME":"Krimi","ACTION":"Action","THRILLER":"Thriller","ADVENTURE":"Abenteuer","SCI_FI":"Sci-Fi","FANTASY":"Fantasy","DRAMA":"Drama","ROMANCE":"Romance","TERROR":"Horror","HISTORY":"Geschichte","WESTERN":"Western","WAR":"Krieg","MISTERY":"Mystery","FAMILY":"Familie","SPORT":"Sport","MUSIC":"Musik","MUSICAL":"Musical","ANIMATION":"Animation","DOCUMENTARY":"Dokumentar","FILM_NOIR":"Film noir","NEWS":"News","KIDS":"Kinder","TALK_SHOW":"Talkshow","CURRENT_SCENE":"","PIZZA_OR_POP_CORN":"","WE_RECOMMEND":"","MAKE_POP_CORN":"","LIGHTS_CAMERA":"","WE_ARE_LOADING":"","EVERYTHING_END":"","MOVIE_OFF":"","MOVIE_ENDED":"","OKAY":"","CAROUSEL_CARD_SAVE":"","CAROUSEL_CARD_SAVED":"","CAROUSEL_NEW_CARD_ADDED":"","CAROUSEL_NEW_CARDS_ADDED":"","TVGRID_COMMERCIAL_TXT":"","TVGRID_TODAY":"","TVGRID_TOMORROW":"","EXIT_BUTTON_CANCEL":"","ERROR_SCAN_CHANNELS_TITLE":"","ERROR_SCAN_CHANNELS_TEXT":"","ERROR_SCAN_CHANNELS_BTN_SCAN":"","SCAN_FIRST_TIME_TITLE":"","SCAN_FIRST_TIME_TEXT":"","SCAN_FIRST_TIME_BTN":"","SCAN_HELP_RESCAN_TITLE":"","SCAN_HELP_RESCAN_TEXT":"","SCAN_HELP_RESCAN_BTN":"","SCAN_HELP_TITLE_1":"","SCAN_HELP_TITLE_2":"","SCAN_HELP_SUGGESTION":"","SCAN_HELP_PLEASE_CONTACT":"","SCAN_HELP_EMAIL":"","SCAN_HELP_SUBJECT":"","SCAN_HELP_VERSION":"","REGION_SET_TITLE":"","REGION_SET_TEXT":"","REGION_SET_SPAIN":"","REGION_SET_GERMANY":"","REGION_SET_USA":"","TVGRID_CHANGE_CHANNEL_TITLE":"","TVGRID_CHANGE_CHANNEL_TEXT":"","TVGRID_CHANGE_CHANNEL_BTN":"","CAROUSEL_ALIAS_MOVIE":"","CAROUSEL_ALIAS_SERIE":"","CAROUSEL_ALIAS_PERSON":"","CAROUSEL_ALIAS_CHARACTER":"","CAROUSEL_ALIAS_VEHICLE":"","CAROUSEL_ALIAS_FASHION":"","CAROUSEL_ALIAS_LOCATION":"","CAROUSEL_ALIAS_HISTORIC":"","CAROUSEL_ALIAS_TRIVIA":"","CAROUSEL_ALIAS_QUOTE":"","CAROUSEL_ALIAS_OST":"","CAROUSEL_ALIAS_HOME":"","CAROUSEL_ALIAS_TECHNOLOGY":"","CAROUSEL_ALIAS_ART":"","CAROUSEL_ALIAS_SONG":"","CAROUSEL_ALIAS_LOOK":"","CAROUSEL_ALIAS_TRAILER":"","CAROUSEL_ALIAS_WEAPON":"","CAROUSEL_ALIAS_LEISURE_SPORT":"","CAROUSEL_ALIAS_HEALTH_BEAUTY":"","CAROUSEL_ALIAS_FOOD_DRINK":"","CAROUSEL_ALIAS_FAUNA_FLORA":"","CAROUSEL_ALIAS_BUSINESS":"","CAROUSEL_ALIAS_REFERENCE":"","CAROUSEL_ALIAS_VIDEOCLIP":"","CAROUSEL_ALIAS_CHAPTER":"","CAROUSEL_ALIAS_ACTION_EMOTION":"","CAROUSEL_ALIAS_SEE_MORE":"","SOURCE":"","SPECS":"","BASIC_DATA":"","AWARDS":"","WINNER_SINGULAR":"","WINNER_PLURAL":"","NOMINEE_SINGULAR":"","NOMINEE_PLURAL":"","POCKET_TITLE_1":"","POCKET_TITLE_2":"","POCKET_NO_CARDS_TITLE":"","POCKET_NO_CARDS_TXT":"","GALLERY":"","LOCATION":"","CURIOSITY_TITLE":"","OVERVIEW":""}

/***/ }),

/***/ 614:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
var __rest = this && this.__rest || function (s, e) {
    var t = {};
    for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
    }return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var HOC_1 = __webpack_require__(17);
var NavigationContainerClass = function (_super) {
    __extends(NavigationContainerClass, _super);
    function NavigationContainerClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NavigationContainerClass.prototype.render = function () {
        var _a = this.props,
            accept = _a.accept,
            acceptCharset = _a.acceptCharset,
            action = _a.action,
            allowFullScreen = _a.allowFullScreen,
            allowTransparency = _a.allowTransparency,
            alt = _a.alt,
            async = _a.async,
            autoComplete = _a.autoComplete,
            autoFocus = _a.autoFocus,
            autoPlay = _a.autoPlay,
            capture = _a.capture,
            cellPadding = _a.cellPadding,
            cellSpacing = _a.cellSpacing,
            charSet = _a.charSet,
            challenge = _a.challenge,
            checked = _a.checked,
            cite = _a.cite,
            classID = _a.classID,
            cols = _a.cols,
            colSpan = _a.colSpan,
            content = _a.content,
            controls = _a.controls,
            coords = _a.coords,
            crossOrigin = _a.crossOrigin,
            data = _a.data,
            dateTime = _a.dateTime,
            defer = _a.defer,
            disabled = _a.disabled,
            download = _a.download,
            encType = _a.encType,
            form = _a.form,
            formAction = _a.formAction,
            formEncType = _a.formEncType,
            formMethod = _a.formMethod,
            formNoValidate = _a.formNoValidate,
            formTarget = _a.formTarget,
            frameBorder = _a.frameBorder,
            headers = _a.headers,
            height = _a.height,
            high = _a.high,
            href = _a.href,
            hrefLang = _a.hrefLang,
            htmlFor = _a.htmlFor,
            httpEquiv = _a.httpEquiv,
            integrity = _a.integrity,
            keyParams = _a.keyParams,
            keyType = _a.keyType,
            kind = _a.kind,
            label = _a.label,
            list = _a.list,
            loop = _a.loop,
            low = _a.low,
            manifest = _a.manifest,
            marginHeight = _a.marginHeight,
            marginWidth = _a.marginWidth,
            max = _a.max,
            maxLength = _a.maxLength,
            media = _a.media,
            mediaGroup = _a.mediaGroup,
            method = _a.method,
            min = _a.min,
            minLength = _a.minLength,
            multiple = _a.multiple,
            muted = _a.muted,
            name = _a.name,
            nonce = _a.nonce,
            noValidate = _a.noValidate,
            open = _a.open,
            optimum = _a.optimum,
            pattern = _a.pattern,
            placeholder = _a.placeholder,
            playsInline = _a.playsInline,
            poster = _a.poster,
            preload = _a.preload,
            readOnly = _a.readOnly,
            rel = _a.rel,
            required = _a.required,
            reversed = _a.reversed,
            rows = _a.rows,
            rowSpan = _a.rowSpan,
            sandbox = _a.sandbox,
            scope = _a.scope,
            scoped = _a.scoped,
            scrolling = _a.scrolling,
            seamless = _a.seamless,
            selected = _a.selected,
            shape = _a.shape,
            size = _a.size,
            sizes = _a.sizes,
            span = _a.span,
            src = _a.src,
            srcDoc = _a.srcDoc,
            srcLang = _a.srcLang,
            srcSet = _a.srcSet,
            start = _a.start,
            step = _a.step,
            summary = _a.summary,
            target = _a.target,
            type = _a.type,
            useMap = _a.useMap,
            value = _a.value,
            width = _a.width,
            wmode = _a.wmode,
            wrap = _a.wrap,
            defaultChecked = _a.defaultChecked,
            defaultValue = _a.defaultValue,
            suppressContentEditableWarning = _a.suppressContentEditableWarning,
            accessKey = _a.accessKey,
            contentEditable = _a.contentEditable,
            contextMenu = _a.contextMenu,
            dir = _a.dir,
            draggable = _a.draggable,
            hidden = _a.hidden,
            id = _a.id,
            lang = _a.lang,
            spellCheck = _a.spellCheck,
            style = _a.style,
            tabIndex = _a.tabIndex,
            title = _a.title,
            inputMode = _a.inputMode,
            is = _a.is,
            radioGroup = _a.radioGroup,
            role = _a.role,
            about = _a.about,
            datatype = _a.datatype,
            inlist = _a.inlist,
            prefix = _a.prefix,
            property = _a.property,
            resource = _a.resource,
            vocab = _a.vocab,
            autoCapitalize = _a.autoCapitalize,
            autoCorrect = _a.autoCorrect,
            autoSave = _a.autoSave,
            color = _a.color,
            itemProp = _a.itemProp,
            itemScope = _a.itemScope,
            itemType = _a.itemType,
            itemID = _a.itemID,
            itemRef = _a.itemRef,
            results = _a.results,
            security = _a.security,
            unselectable = _a.unselectable,
            children = _a.children,
            dangerouslySetInnerHTML = _a.dangerouslySetInnerHTML,
            onCopy = _a.onCopy,
            onCopyCapture = _a.onCopyCapture,
            onCut = _a.onCut,
            onCutCapture = _a.onCutCapture,
            onPaste = _a.onPaste,
            onPasteCapture = _a.onPasteCapture,
            onCompositionEnd = _a.onCompositionEnd,
            onCompositionEndCapture = _a.onCompositionEndCapture,
            onCompositionStart = _a.onCompositionStart,
            onCompositionStartCapture = _a.onCompositionStartCapture,
            onCompositionUpdate = _a.onCompositionUpdate,
            onCompositionUpdateCapture = _a.onCompositionUpdateCapture,
            onFocus = _a.onFocus,
            onFocusCapture = _a.onFocusCapture,
            onBlur = _a.onBlur,
            onBlurCapture = _a.onBlurCapture,
            onChange = _a.onChange,
            onChangeCapture = _a.onChangeCapture,
            onInput = _a.onInput,
            onInputCapture = _a.onInputCapture,
            onReset = _a.onReset,
            onResetCapture = _a.onResetCapture,
            onSubmit = _a.onSubmit,
            onSubmitCapture = _a.onSubmitCapture,
            onInvalid = _a.onInvalid,
            onInvalidCapture = _a.onInvalidCapture,
            onLoad = _a.onLoad,
            onLoadCapture = _a.onLoadCapture,
            onError = _a.onError,
            onErrorCapture = _a.onErrorCapture,
            onKeyDown = _a.onKeyDown,
            onKeyDownCapture = _a.onKeyDownCapture,
            onKeyPress = _a.onKeyPress,
            onKeyPressCapture = _a.onKeyPressCapture,
            onKeyUp = _a.onKeyUp,
            onKeyUpCapture = _a.onKeyUpCapture,
            onAbort = _a.onAbort,
            onAbortCapture = _a.onAbortCapture,
            onCanPlay = _a.onCanPlay,
            onCanPlayCapture = _a.onCanPlayCapture,
            onCanPlayThrough = _a.onCanPlayThrough,
            onCanPlayThroughCapture = _a.onCanPlayThroughCapture,
            onDurationChange = _a.onDurationChange,
            onDurationChangeCapture = _a.onDurationChangeCapture,
            onEmptied = _a.onEmptied,
            onEmptiedCapture = _a.onEmptiedCapture,
            onEncrypted = _a.onEncrypted,
            onEncryptedCapture = _a.onEncryptedCapture,
            onEnded = _a.onEnded,
            onEndedCapture = _a.onEndedCapture,
            onLoadedData = _a.onLoadedData,
            onLoadedDataCapture = _a.onLoadedDataCapture,
            onLoadedMetadata = _a.onLoadedMetadata,
            onLoadedMetadataCapture = _a.onLoadedMetadataCapture,
            onLoadStart = _a.onLoadStart,
            onLoadStartCapture = _a.onLoadStartCapture,
            onPause = _a.onPause,
            onPauseCapture = _a.onPauseCapture,
            onPlay = _a.onPlay,
            onPlayCapture = _a.onPlayCapture,
            onPlaying = _a.onPlaying,
            onPlayingCapture = _a.onPlayingCapture,
            onProgress = _a.onProgress,
            onProgressCapture = _a.onProgressCapture,
            onRateChange = _a.onRateChange,
            onRateChangeCapture = _a.onRateChangeCapture,
            onSeeked = _a.onSeeked,
            onSeekedCapture = _a.onSeekedCapture,
            onSeeking = _a.onSeeking,
            onSeekingCapture = _a.onSeekingCapture,
            onStalled = _a.onStalled,
            onStalledCapture = _a.onStalledCapture,
            onSuspend = _a.onSuspend,
            onSuspendCapture = _a.onSuspendCapture,
            onTimeUpdate = _a.onTimeUpdate,
            onTimeUpdateCapture = _a.onTimeUpdateCapture,
            onVolumeChange = _a.onVolumeChange,
            onVolumeChangeCapture = _a.onVolumeChangeCapture,
            onWaiting = _a.onWaiting,
            onWaitingCapture = _a.onWaitingCapture,
            onClick = _a.onClick,
            onClickCapture = _a.onClickCapture,
            onContextMenu = _a.onContextMenu,
            onContextMenuCapture = _a.onContextMenuCapture,
            onDoubleClick = _a.onDoubleClick,
            onDoubleClickCapture = _a.onDoubleClickCapture,
            onDrag = _a.onDrag,
            onDragCapture = _a.onDragCapture,
            onDragEnd = _a.onDragEnd,
            onDragEndCapture = _a.onDragEndCapture,
            onDragEnter = _a.onDragEnter,
            onDragEnterCapture = _a.onDragEnterCapture,
            onDragExit = _a.onDragExit,
            onDragExitCapture = _a.onDragExitCapture,
            onDragLeave = _a.onDragLeave,
            onDragLeaveCapture = _a.onDragLeaveCapture,
            onDragOver = _a.onDragOver,
            onDragOverCapture = _a.onDragOverCapture,
            onDragStart = _a.onDragStart,
            onDragStartCapture = _a.onDragStartCapture,
            onDrop = _a.onDrop,
            onDropCapture = _a.onDropCapture,
            onMouseDown = _a.onMouseDown,
            onMouseDownCapture = _a.onMouseDownCapture,
            onMouseEnter = _a.onMouseEnter,
            onMouseLeave = _a.onMouseLeave,
            onMouseMove = _a.onMouseMove,
            onMouseMoveCapture = _a.onMouseMoveCapture,
            onMouseOut = _a.onMouseOut,
            onMouseOutCapture = _a.onMouseOutCapture,
            onMouseOver = _a.onMouseOver,
            onMouseOverCapture = _a.onMouseOverCapture,
            onMouseUp = _a.onMouseUp,
            onMouseUpCapture = _a.onMouseUpCapture,
            onSelect = _a.onSelect,
            onSelectCapture = _a.onSelectCapture,
            onTouchCancel = _a.onTouchCancel,
            onTouchCancelCapture = _a.onTouchCancelCapture,
            onTouchEnd = _a.onTouchEnd,
            onTouchEndCapture = _a.onTouchEndCapture,
            onTouchMove = _a.onTouchMove,
            onTouchMoveCapture = _a.onTouchMoveCapture,
            onTouchStart = _a.onTouchStart,
            onTouchStartCapture = _a.onTouchStartCapture,
            onScroll = _a.onScroll,
            onScrollCapture = _a.onScrollCapture,
            onWheel = _a.onWheel,
            onWheelCapture = _a.onWheelCapture,
            onAnimationStart = _a.onAnimationStart,
            onAnimationStartCapture = _a.onAnimationStartCapture,
            onAnimationEnd = _a.onAnimationEnd,
            onAnimationEndCapture = _a.onAnimationEndCapture,
            onAnimationIteration = _a.onAnimationIteration,
            onAnimationIterationCapture = _a.onAnimationIterationCapture,
            onTransitionEnd = _a.onTransitionEnd,
            onTransitionEndCapture = _a.onTransitionEndCapture,
            key = _a.key,
            childrenProps = __rest(_a, ["accept", "acceptCharset", "action", "allowFullScreen", "allowTransparency", "alt", "async", "autoComplete", "autoFocus", "autoPlay", "capture", "cellPadding", "cellSpacing", "charSet", "challenge", "checked", "cite", "classID", "cols", "colSpan", "content", "controls", "coords", "crossOrigin", "data", "dateTime", "defer", "disabled", "download", "encType", "form", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "headers", "height", "high", "href", "hrefLang", "htmlFor", "httpEquiv", "integrity", "keyParams", "keyType", "kind", "label", "list", "loop", "low", "manifest", "marginHeight", "marginWidth", "max", "maxLength", "media", "mediaGroup", "method", "min", "minLength", "multiple", "muted", "name", "nonce", "noValidate", "open", "optimum", "pattern", "placeholder", "playsInline", "poster", "preload", "readOnly", "rel", "required", "reversed", "rows", "rowSpan", "sandbox", "scope", "scoped", "scrolling", "seamless", "selected", "shape", "size", "sizes", "span", "src", "srcDoc", "srcLang", "srcSet", "start", "step", "summary", "target", "type", "useMap", "value", "width", "wmode", "wrap", "defaultChecked", "defaultValue", "suppressContentEditableWarning", "accessKey", "contentEditable", "contextMenu", "dir", "draggable", "hidden", "id", "lang", "spellCheck", "style", "tabIndex", "title", "inputMode", "is", "radioGroup", "role", "about", "datatype", "inlist", "prefix", "property", "resource", "vocab", "autoCapitalize", "autoCorrect", "autoSave", "color", "itemProp", "itemScope", "itemType", "itemID", "itemRef", "results", "security", "unselectable", "children", "dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture", "key"]);
        var className = this.props.className;
        className = className ? "navigableContainer " + className : "navigableContainer";
        className = "fillParent " + className;
        var divProps = { accept: accept, acceptCharset: acceptCharset, action: action, allowFullScreen: allowFullScreen, allowTransparency: allowTransparency, alt: alt, async: async, autoComplete: autoComplete, autoFocus: autoFocus, autoPlay: autoPlay, capture: capture, cellPadding: cellPadding, cellSpacing: cellSpacing, charSet: charSet, challenge: challenge, checked: checked, cite: cite, classID: classID, cols: cols, colSpan: colSpan, content: content, controls: controls, coords: coords, crossOrigin: crossOrigin, data: data, dateTime: dateTime, defer: defer, disabled: disabled, download: download, encType: encType, form: form, formAction: formAction, formEncType: formEncType, formMethod: formMethod, formNoValidate: formNoValidate, formTarget: formTarget, frameBorder: frameBorder, headers: headers, height: height, high: high, href: href, hrefLang: hrefLang, htmlFor: htmlFor, httpEquiv: httpEquiv, integrity: integrity, keyParams: keyParams, keyType: keyType, kind: kind, label: label, list: list, loop: loop, low: low, manifest: manifest, marginHeight: marginHeight, marginWidth: marginWidth, max: max, maxLength: maxLength, media: media, mediaGroup: mediaGroup, method: method, min: min, minLength: minLength, multiple: multiple, muted: muted, name: name, nonce: nonce, noValidate: noValidate, open: open, optimum: optimum, pattern: pattern, placeholder: placeholder, playsInline: playsInline, poster: poster, preload: preload, readOnly: readOnly, rel: rel, required: required, reversed: reversed, rows: rows, rowSpan: rowSpan, sandbox: sandbox, scope: scope, scoped: scoped, scrolling: scrolling, seamless: seamless, selected: selected, shape: shape, size: size, sizes: sizes, span: span, src: src, srcDoc: srcDoc, srcLang: srcLang, srcSet: srcSet, start: start, step: step, summary: summary, target: target, type: type, useMap: useMap, value: value, width: width, wmode: wmode, wrap: wrap, defaultChecked: defaultChecked, defaultValue: defaultValue, suppressContentEditableWarning: suppressContentEditableWarning, accessKey: accessKey, className: className, contentEditable: contentEditable, contextMenu: contextMenu, dir: dir, draggable: draggable, hidden: hidden, id: id, lang: lang, spellCheck: spellCheck, style: style, tabIndex: tabIndex, title: title, inputMode: inputMode, is: is, radioGroup: radioGroup, role: role, about: about, datatype: datatype, inlist: inlist, prefix: prefix, property: property, resource: resource, vocab: vocab, autoCapitalize: autoCapitalize, autoCorrect: autoCorrect, autoSave: autoSave, color: color, itemProp: itemProp, itemScope: itemScope, itemType: itemType, itemID: itemID, itemRef: itemRef, results: results, security: security, unselectable: unselectable, children: children, dangerouslySetInnerHTML: dangerouslySetInnerHTML, onCopy: onCopy, onCopyCapture: onCopyCapture, onCut: onCut, onCutCapture: onCutCapture, onPaste: onPaste, onPasteCapture: onPasteCapture, onCompositionEnd: onCompositionEnd, onCompositionEndCapture: onCompositionEndCapture, onCompositionStart: onCompositionStart, onCompositionStartCapture: onCompositionStartCapture, onCompositionUpdate: onCompositionUpdate, onCompositionUpdateCapture: onCompositionUpdateCapture, onFocus: onFocus, onFocusCapture: onFocusCapture, onBlur: onBlur, onBlurCapture: onBlurCapture, onChange: onChange, onChangeCapture: onChangeCapture, onInput: onInput, onInputCapture: onInputCapture, onReset: onReset, onResetCapture: onResetCapture, onSubmit: onSubmit, onSubmitCapture: onSubmitCapture, onInvalid: onInvalid, onInvalidCapture: onInvalidCapture, onLoad: onLoad, onLoadCapture: onLoadCapture, onError: onError, onErrorCapture: onErrorCapture, onKeyDown: onKeyDown, onKeyDownCapture: onKeyDownCapture, onKeyPress: onKeyPress, onKeyPressCapture: onKeyPressCapture, onKeyUp: onKeyUp, onKeyUpCapture: onKeyUpCapture, onAbort: onAbort, onAbortCapture: onAbortCapture, onCanPlay: onCanPlay, onCanPlayCapture: onCanPlayCapture, onCanPlayThrough: onCanPlayThrough, onCanPlayThroughCapture: onCanPlayThroughCapture, onDurationChange: onDurationChange, onDurationChangeCapture: onDurationChangeCapture, onEmptied: onEmptied, onEmptiedCapture: onEmptiedCapture, onEncrypted: onEncrypted, onEncryptedCapture: onEncryptedCapture, onEnded: onEnded, onEndedCapture: onEndedCapture, onLoadedData: onLoadedData, onLoadedDataCapture: onLoadedDataCapture, onLoadedMetadata: onLoadedMetadata, onLoadedMetadataCapture: onLoadedMetadataCapture, onLoadStart: onLoadStart, onLoadStartCapture: onLoadStartCapture, onPause: onPause, onPauseCapture: onPauseCapture, onPlay: onPlay, onPlayCapture: onPlayCapture, onPlaying: onPlaying, onPlayingCapture: onPlayingCapture, onProgress: onProgress, onProgressCapture: onProgressCapture, onRateChange: onRateChange, onRateChangeCapture: onRateChangeCapture, onSeeked: onSeeked, onSeekedCapture: onSeekedCapture, onSeeking: onSeeking, onSeekingCapture: onSeekingCapture, onStalled: onStalled, onStalledCapture: onStalledCapture, onSuspend: onSuspend, onSuspendCapture: onSuspendCapture, onTimeUpdate: onTimeUpdate, onTimeUpdateCapture: onTimeUpdateCapture, onVolumeChange: onVolumeChange, onVolumeChangeCapture: onVolumeChangeCapture, onWaiting: onWaiting, onWaitingCapture: onWaitingCapture, onClick: onClick, onClickCapture: onClickCapture, onContextMenu: onContextMenu, onContextMenuCapture: onContextMenuCapture, onDoubleClick: onDoubleClick, onDoubleClickCapture: onDoubleClickCapture, onDrag: onDrag, onDragCapture: onDragCapture, onDragEnd: onDragEnd, onDragEndCapture: onDragEndCapture, onDragEnter: onDragEnter, onDragEnterCapture: onDragEnterCapture, onDragExit: onDragExit, onDragExitCapture: onDragExitCapture, onDragLeave: onDragLeave, onDragLeaveCapture: onDragLeaveCapture, onDragOver: onDragOver, onDragOverCapture: onDragOverCapture, onDragStart: onDragStart, onDragStartCapture: onDragStartCapture, onDrop: onDrop, onDropCapture: onDropCapture, onMouseDown: onMouseDown, onMouseDownCapture: onMouseDownCapture, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onMouseMove: onMouseMove, onMouseMoveCapture: onMouseMoveCapture, onMouseOut: onMouseOut, onMouseOutCapture: onMouseOutCapture, onMouseOver: onMouseOver, onMouseOverCapture: onMouseOverCapture, onMouseUp: onMouseUp, onMouseUpCapture: onMouseUpCapture, onSelect: onSelect, onSelectCapture: onSelectCapture, onTouchCancel: onTouchCancel, onTouchCancelCapture: onTouchCancelCapture, onTouchEnd: onTouchEnd, onTouchEndCapture: onTouchEndCapture, onTouchMove: onTouchMove, onTouchMoveCapture: onTouchMoveCapture, onTouchStart: onTouchStart, onTouchStartCapture: onTouchStartCapture, onScroll: onScroll, onScrollCapture: onScrollCapture, onWheel: onWheel, onWheelCapture: onWheelCapture, onAnimationStart: onAnimationStart, onAnimationStartCapture: onAnimationStartCapture, onAnimationEnd: onAnimationEnd, onAnimationEndCapture: onAnimationEndCapture, onAnimationIteration: onAnimationIteration, onAnimationIterationCapture: onAnimationIterationCapture, onTransitionEnd: onTransitionEnd, onTransitionEndCapture: onTransitionEndCapture, key: key };
        return React.createElement("div", __assign({}, divProps), this.props.children ? this.recursiveCloneChildren(this.props.children) : null);
    };
    NavigationContainerClass.prototype.recursiveCloneChildren = function (children) {
        var _this = this;
        return this.props.propagateParent ? React.Children.map(children, function (child, idx) {
            if (!child) return child;
            var childProps = __assign({}, child.props);
            var foundNav = false;
            if (child.props == undefined) {
                return child;
            } else if (child.type && childProps.parent) {
                childProps = __assign({}, childProps, { parent: _this });
                foundNav = true;
            } else {
                return child;
            }
            if (child.props && child.props.children) {
                if (!foundNav) {
                    childProps.children = _this.recursiveCloneChildren(child.props.children);
                }
            }
            return React.cloneElement(child, __assign({}, childProps));
        }) : children;
    };
    return NavigationContainerClass;
}(React.Component);
NavigationContainerClass.defaultProps = {
    propagateParent: false
};
exports.NavigationContainer = HOC_1.navigable(NavigationContainerClass);

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "navigationContainer.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 615:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var redux_1 = __webpack_require__(80);
var react_redux_1 = __webpack_require__(52);
var Components_1 = __webpack_require__(20);
var Actions_1 = __webpack_require__(61);
var HOC_1 = __webpack_require__(17);
var Containers_1 = __webpack_require__(99);
exports.cardDetailInitialState = {
    status: "LOADING"
};
var CardDetailClass = function (_super) {
    __extends(CardDetailClass, _super);
    function CardDetailClass(props) {
        var _this = _super.call(this, props) || this;
        _this.cardModules = [];
        _this.state = exports.cardDetailInitialState;
        return _this;
    }
    CardDetailClass.prototype.render = function () {
        return React.createElement("div", { className: "cardDetail fillParent" }, React.createElement("div", { className: "bottomContainerTopButtons" }, React.createElement("div", { className: "cardDetailBtn" }, React.createElement(Components_1.NavigationContainer, { key: "carouselClose", className: "bctButton close", parent: this, clickAction: function clickAction() {
                return "";
            }, columns: 1 }))), this.props.card ? React.createElement(Containers_1.NavigableCardModuleList, { isDefault: true, parent: this, columns: 1, card: this.props.card, forceFirst: true }) : React.createElement(Components_1.Loading, null));
    };
    CardDetailClass.prototype.closeAllCards = function () {
        console.log("CLOSE ALL CARDS");
        this.props.uiActions.openSync();
    };
    CardDetailClass.prototype.componentDidUpdate = function () {
        if (this.props.card && this.state.status !== "DONE") {
            this.setState(__assign({}, this.state, { status: "DONE" }));
        }
    };
    CardDetailClass.prototype.addToArrayIfExists = function (targetArray, candidate) {
        if (candidate) {
            targetArray.push(candidate);
        }
    };
    return CardDetailClass;
}(React.PureComponent);
exports.CardDetailClass = CardDetailClass;
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        uiActions: redux_1.bindActionCreators(Actions_1.UIActions, dispatch)
    };
};
var mergeProps = function mergeProps(stateProps, dispatchProps, ownProps) {
    return __assign({}, stateProps, ownProps, dispatchProps);
};
exports.CardDetail = HOC_1.navigable(react_redux_1.connect(undefined, mapDispatchToProps, mergeProps)(CardDetailClass));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "cardDetail.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 616:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var Services_1 = __webpack_require__(33);
var CardAndCategory = function (_super) {
    __extends(CardAndCategory, _super);
    function CardAndCategory() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CardAndCategory.prototype.render = function () {
        var card = this.props.card;
        if (card) {
            var showImage = false;
            if (card.image && card.image.thumb) {
                showImage = true;
            }
            var showIcon = !showImage;
            var showTitle = false;
            var showSubtitle = false;
            switch (card.type) {
                case 'ost':
                case 'song':
                    showImage = false;
                    showIcon = true;
                    showTitle = true;
                    showSubtitle = true;
                    break;
                case 'quote':
                case 'reference':
                case 'trivia':
                    showImage = false;
                    showIcon = false;
                    showTitle = true;
                    break;
            }
            var category = Services_1.Localize("CAROUSEL_ALIAS_" + card.type.toUpperCase()) || card.type;
            return React.createElement("div", { className: "cardAndCategory" }, React.createElement("div", { className: "image " + card.type, style: showImage ? {
                    backgroundImage: "url(" + card.image.thumb + ")",
                    backgroundPosition: card.image.anchor_x + "% " + card.image.anchor_y + "%"
                } : undefined }, showIcon ? React.createElement("div", { className: "icon" }) : null, showTitle ? React.createElement("div", { className: "title" }, card.title) : null, showSubtitle && !showIcon ? React.createElement("div", { className: "subtitle" }, card.subtitle) : null), React.createElement("div", { className: "category" }, category));
        }
        return null;
    };
    CardAndCategory.defaultProps = {
        card: null
    };
    return CardAndCategory;
}(React.PureComponent);
exports.CardAndCategory = CardAndCategory;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "cardAndCategory.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 617:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var classNames = __webpack_require__(100);
var Services_1 = __webpack_require__(33);
var Components_1 = __webpack_require__(20);
var HOC_1 = __webpack_require__(17);
var VerticalScrollClass = function (_super) {
    __extends(VerticalScrollClass, _super);
    function VerticalScrollClass() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.downAction = function () {
            _this.scrollBox.scrollTop += _this.scrollBox.offsetHeight;
        };
        _this.upAction = function () {
            _this.scrollBox.scrollTop -= _this.scrollBox.offsetHeight;
        };
        return _this;
    }
    VerticalScrollClass.prototype.render = function () {
        var _this = this;
        var full = this.props.source !== undefined && this.props.source.name !== undefined && this.props.source.name !== '';
        var classes = classNames({
            full: full,
            scrollBox: true
        });
        var source = this.props.source && this.props.source.name ? this.props.source.name : this.props.source && this.props.source.url ? this.props.source.url : null;
        return React.createElement("div", { className: "verticalScroll" }, React.createElement("div", { className: "scrollBox", ref: function ref(el) {
                if (el) {
                    _this.scrollBox = el;
                }
            } }, this.props.children), source ? React.createElement("div", { className: "source" }, React.createElement("label", { className: "label" }, Services_1.Localize('SOURCE'), ": "), React.createElement("label", { className: "text" }, source)) : null, React.createElement("div", { className: "btns" }, React.createElement(Components_1.DirectionButtonList, { parent: this, template: "horizontal", btns: [{ direction: 'up', action: this.upAction }, { direction: 'down', action: this.downAction }] })));
    };
    return VerticalScrollClass;
}(React.PureComponent);
exports.VerticalScrollClass = VerticalScrollClass;
exports.VerticalScroll = HOC_1.navigable(VerticalScrollClass);

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "verticalScroll.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 618:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var Components_1 = __webpack_require__(20);
var HOC_1 = __webpack_require__(17);
var HorizontalScrollClass = function (_super) {
    __extends(HorizontalScrollClass, _super);
    function HorizontalScrollClass() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.offset = 0;
        _this.showElements = function () {
            var elements = [];
            if (_this.props.children instanceof Array) {
                for (var i = _this.offset; i < _this.props.itemsShown + _this.offset && i < _this.props.children.length; i++) {
                    elements.push(_this.props.children[i]);
                }
            }
            return elements;
        };
        _this.leftAction = function () {
            _this.offset -= _this.props.itemsShown;
            if (_this.offset < 0) {
                _this.offset = 0;
            }
            _this.forceUpdate();
        };
        _this.rightAction = function () {
            _this.offset += _this.props.itemsShown;
            if (_this.props.children instanceof Array && _this.offset + _this.props.itemsShown >= _this.props.children.length) {
                _this.offset = _this.props.children.length - _this.props.itemsShown;
            }
            _this.forceUpdate();
        };
        return _this;
    }
    HorizontalScrollClass.prototype.render = function () {
        var _this = this;
        return React.createElement("div", { className: "horizontalScroll" }, React.createElement("div", { className: "scrollBox", ref: function ref(el) {
                if (el) {
                    _this.scrollBox = el;
                }
            } }, React.createElement(Components_1.NavigationContainer, { parent: this, propagateParent: true, className: "scrollBoxContent" }, this.showElements())), React.createElement("div", { className: "btns" }, React.createElement(Components_1.DirectionButtonList, { parent: this, template: "vertical", btns: [{ direction: 'right', action: this.rightAction }, { direction: 'left', action: this.leftAction }] })));
    };
    return HorizontalScrollClass;
}(React.PureComponent);
exports.HorizontalScrollClass = HorizontalScrollClass;
exports.HorizontalScroll = HOC_1.navigable(HorizontalScrollClass);

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "horizontalScroll.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 619:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var HOC_1 = __webpack_require__(17);
var Components_1 = __webpack_require__(20);
var DirectionButtonListClass = function (_super) {
    __extends(DirectionButtonListClass, _super);
    function DirectionButtonListClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DirectionButtonListClass.prototype.render = function () {
        var _this = this;
        return React.createElement("ul", { className: 'directionButtonList ' + this.props.template }, this.props.btns.map(function (btn, i) {
            return React.createElement("li", { className: "btn", key: i }, React.createElement(Components_1.DirectionButton, { direction: btn.direction, clickAction: btn.action, parent: _this, columns: _this.props.template !== 'vertical' ? _this.props.btns.length : 1 }));
        }));
    };
    return DirectionButtonListClass;
}(React.PureComponent);
exports.DirectionButtonListClass = DirectionButtonListClass;
exports.DirectionButtonList = HOC_1.navigable(DirectionButtonListClass);

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "directionButtonList.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 620:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var classNames = __webpack_require__(100);
var HOC_1 = __webpack_require__(17);
var DirectionButtonClass = function (_super) {
    __extends(DirectionButtonClass, _super);
    function DirectionButtonClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DirectionButtonClass.prototype.render = function () {
        var classes = classNames('directionButton', this.props.direction);
        return React.createElement("div", { className: classes });
    };
    return DirectionButtonClass;
}(React.PureComponent);
exports.DirectionButtonClass = DirectionButtonClass;
exports.DirectionButton = HOC_1.navigable(DirectionButtonClass);

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "directionButton.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 621:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var classNames = __webpack_require__(100);
var HOC_1 = __webpack_require__(17);
var Services_1 = __webpack_require__(33);
var MiniCardButtonClass = function (_super) {
    __extends(MiniCardButtonClass, _super);
    function MiniCardButtonClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MiniCardButtonClass.prototype.render = function () {
        switch (this.props.type) {
            case 'MORE':
                return React.createElement("div", { className: "miniCardButton fillParent more", onClick: this.props.clickAction }, "+");
            case 'SAVE':
                var classesApplied = classNames({
                    icon: true,
                    like: this.props.liked ? false : true,
                    liked: this.props.liked ? true : false
                });
                return React.createElement("div", { className: "miniCardButton fillParent", onClick: this.props.clickAction }, React.createElement("span", { className: classesApplied }), this.props.liked ? Services_1.Localize('CAROUSEL_CARD_SAVED') : Services_1.Localize('CAROUSEL_CARD_SAVE'));
            default:
                return React.createElement("div", { className: "miniCardButton fillParent", onClick: this.props.clickAction });
        }
    };
    return MiniCardButtonClass;
}(React.PureComponent);
exports.MiniCardButtonClass = MiniCardButtonClass;
exports.MiniCardButton = HOC_1.navigable(MiniCardButtonClass);

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "miniCardButton.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 622:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var ReactDOM = __webpack_require__(91);
var redux_1 = __webpack_require__(80);
var react_redux_1 = __webpack_require__(52);
var HOC_1 = __webpack_require__(17);
var Components_1 = __webpack_require__(20);
var Actions_1 = __webpack_require__(61);
var MiniCardListClass = function (_super) {
    __extends(MiniCardListClass, _super);
    function MiniCardListClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MiniCardListClass.prototype.shouldComponentUpdate = function (nextProps) {
        if (_typeof(this.props.elements) !== _typeof(nextProps.elements)) {
            return true;
        } else if (nextProps.elements && nextProps.elements.length !== this.props.elements.length) {
            return true;
        }
        return false;
    };
    MiniCardListClass.prototype.componentWillUpdate = function (nextProps) {
        if (this.props.wasSelectedOnChangeScene) {
            if (this.props.setNodeById && this.props.idx) {
                this.props.setNodeById(this.props.idx);
            }
            if (this.props.setSelectedOnSceneChange !== undefined && this.props.elements.length > 0) {
                this.props.setSelectedOnSceneChange(false);
            }
        }
    };
    MiniCardListClass.prototype.render = function () {
        var _this = this;
        return React.createElement("ul", { className: "miniCardList" }, this.props.elements.map(function (sceneCard, i, sceneCards) {
            return _this.element({
                el: sceneCard,
                key: sceneCard.card_id + '#' + sceneCard.version,
                count: sceneCards.length,
                relations: sceneCard.relations,
                index: i,
                parent: parent
            });
        }));
    };
    MiniCardListClass.prototype.componentWillUnmount = function () {
        if (ReactDOM.findDOMNode(this).querySelector(".childFocused")) {
            this.props.setSelectedOnSceneChange(true);
        }
    };
    MiniCardListClass.prototype.element = function (params) {
        var el = params.el,
            key = params.key,
            count = params.count,
            relations = params.relations,
            index = params.index,
            parent = params.parent;
        var card = params.el;
        return React.createElement(Components_1.MiniCard, { focusChainClass: "childFocused", activeGroupClass: "activeGroup", groupName: (el.card_id + '' + el.version).toString(), element: card, relations: relations, parent: this, forceFirst: true, forceOrder: index, clickActionMore: this.clickActionMore.bind(this)(card), clickActionLike: this.clickActionLike.bind(this)(card), onFocusCallback: this.onFocusCallback.bind(this)(card), key: key, id: "" + key, isScrollable: true, navClass: "scrollable" });
    };
    MiniCardListClass.prototype.clickActionLike = function (originalCard) {
        var _this = this;
        return function (paramCard) {
            var card = paramCard || originalCard;
            if (!card) {
                return;
            }
            console.log("LIKE", card.card_id);
            _this.props.userActions.likeCard(card).then(function () {
                console.log("Liked success");
            });
        };
    };
    MiniCardListClass.prototype.clickActionMore = function (originalCard) {
        var _this = this;
        return function (paramCard) {
            var card = paramCard || originalCard;
            if (!card) {
                return;
            }
            console.log("Card clicked", card);
            _this.props.uiActions.openCard(card.card_id, "offmovie");
        };
    };
    MiniCardListClass.prototype.onFocusCallback = function (originalCard) {
        return function (paramCard) {
            var card = paramCard || originalCard;
        };
    };
    return MiniCardListClass;
}(React.Component);
exports.MiniCardListClass = MiniCardListClass;
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return {
        uiActions: redux_1.bindActionCreators(Actions_1.UIActions, dispatch)
    };
};
var mergeProps = function mergeProps(stateProps, dispatchProps, ownProps) {
    return __assign({}, stateProps, ownProps, dispatchProps);
};
exports.MiniCardList = react_redux_1.connect(undefined, mapDispatchToProps, mergeProps, { withRef: true })(HOC_1.navigable(MiniCardListClass));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "miniCardList.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 623:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var HOC_1 = __webpack_require__(17);
var Services_1 = __webpack_require__(33);
var Components_1 = __webpack_require__(20);
var classNames = __webpack_require__(100);
var MiniCardClass = function (_super) {
    __extends(MiniCardClass, _super);
    function MiniCardClass() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.miniCard = function () {
            return React.createElement("div", { className: "cardLeft", onMouseOver: function onMouseOver() {
                    return _this.props.setNodeById(_this.props.idx);
                } }, React.createElement(Components_1.CardAndCategory, { card: _this.props.element }));
        };
        _this.expandedInfo = function () {
            var text = _this.expandedInfoText();
            return React.createElement("div", { className: "expandedInfoContainer" }, React.createElement("div", { className: "expandedInfo" }, React.createElement("div", { className: "expandedInfoInside" }, React.createElement("div", { className: "text" }, text), React.createElement("div", { className: "btn" }, _this.button('MORE')), React.createElement("div", { className: "btn" }, _this.button('SAVE')))));
        };
        _this.expandedInfoText = function () {
            var box;
            var text = '';
            var textContainer = Services_1.Helper.getContainer(_this.props.element, 'text');
            if (textContainer !== undefined && textContainer.data.length > 0) {
                text = textContainer.data[0].text;
            }
            switch (_this.props.element.type) {
                case 'quote':
                case 'reference':
                    box = React.createElement("div", { className: "text alone" }, text);
                    break;
                case 'character':
                    var relation = Services_1.Helper.getRelation(_this.props.relations, 'played_by');
                    var duple = relation;
                    if (duple.data instanceof Array && duple.data.length > 0) {
                        var person = duple.data[0].from;
                        var title = _this.props.element.title;
                        if (person !== undefined) {
                            _this.openCard = person;
                            if (person.title !== undefined) {
                                title = person.title + ' as ' + title;
                            }
                            var textPersonContainer = Services_1.Helper.getContainer(person, 'text');
                            if (textPersonContainer !== undefined && textPersonContainer.data.length > 0) {
                                text = textPersonContainer.data[0].text;
                            }
                        }
                        box = React.createElement("div", { className: "text" }, React.createElement("div", { className: "title" }, title), React.createElement("div", { className: "desc" }, text));
                        break;
                    }
                case 'song':
                    box = React.createElement("div", { className: "text" });
                    break;
                default:
                    box = React.createElement("div", { className: "text" }, React.createElement("div", { className: "title" }, _this.props.element.title), React.createElement("div", { className: "desc" }, text));
                    break;
            }
            return box;
        };
        _this.button = function (type) {
            var actionWhenMore = function actionWhenMore() {
                _this.props.clickActionMore(_this.openCard);
            };
            var actionWhenLike = function actionWhenLike() {
                _this.props.clickActionLike(_this.openCard);
            };
            return React.createElement(Components_1.MiniCardButton, { clickAction: type === 'SAVE' ? actionWhenLike : actionWhenMore, parent: _this, columns: 1, groupName: _this.props.groupName, type: type });
        };
        return _this;
    }
    MiniCardClass.prototype.render = function () {
        var isRelation = false;
        var classes = classNames({
            minicard: true,
            relation: isRelation
        });
        return React.createElement("li", { id: this.props.id }, React.createElement("div", { className: classes }, isRelation ? React.createElement("div", { className: "relationBar" }) : '', this.miniCard(), this.expandedInfo()));
    };
    MiniCardClass.prototype.componentWillMount = function () {
        this.openCard = this.props.element;
    };
    return MiniCardClass;
}(React.PureComponent);
exports.MiniCardClass = MiniCardClass;
exports.MiniCard = HOC_1.navigable(MiniCardClass);

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "miniCard.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 624:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var Loading = function (_super) {
    __extends(Loading, _super);
    function Loading() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Loading.prototype.render = function () {
        return React.createElement("div", { className: "fillParent", style: { position: "relative" } }, React.createElement("div", { className: "spinner" }));
    };
    return Loading;
}(React.PureComponent);
exports.Loading = Loading;
;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "loading.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 625:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var HOC_1 = __webpack_require__(17);
var Services_1 = __webpack_require__(33);
var Components_1 = __webpack_require__(20);
var Text = function (_super) {
    __extends(Text, _super);
    function Text() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Text_1 = Text;
    Text.prototype.render = function () {
        var textTitle = this.getTitle();
        return React.createElement("div", { className: "cardModuleText cardModule" }, React.createElement("div", { className: "container" }, React.createElement(Components_1.VerticalScroll, { source: this.props.textData ? this.props.textData.source : undefined, parent: this }, textTitle ? React.createElement("div", { className: "cardTitle" }, textTitle) : null, React.createElement("div", { className: "cardText" }, this.props.textData.text))));
    };
    Text.prototype.getTitle = function () {
        if (this.props.container === undefined) {
            return '';
        }
        switch (this.props.container.content_type) {
            case 'biography':
                return Services_1.Localize('BIOGRAPHY');
            case 'overview':
                return Services_1.Localize('OVERVIEW');
            case 'curiosity':
            case 'reference':
                return Services_1.Localize('CURIOSITY_TITLE');
            case 'quote':
            case 'reference':
            case 'description':
            default:
                return null;
        }
    };
    Text = Text_1 = __decorate([HOC_1.statics({
        moduleName: "text",
        validate: function validate(card, moduleType, parent, props) {
            var container = Services_1.Helper.getContainer(card, 'text');
            if (container !== undefined && container.data !== undefined && container.data.length > 0) {
                var Instantiated = HOC_1.navigable(Text_1);
                return React.createElement(Instantiated, __assign({ container: container, textData: container.data[0], parent: parent, isScrollable: true, card: card, moduleType: moduleType }, props));
            }
            return null;
        }
    })], Text);
    return Text;
    var Text_1;
}(React.PureComponent);
exports.Text = Text;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "text.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 626:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var Services_1 = __webpack_require__(33);
var Components_1 = __webpack_require__(20);
var HOC_1 = __webpack_require__(17);
var Table = function (_super) {
    __extends(Table, _super);
    function Table() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.getTitle = function () {
            switch (_this.props.container.content_type) {
                case 'specs':
                    return Services_1.Localize('SPECS');
                case 'basic_data':
                default:
                    return Services_1.Localize('BASIC_DATA');
            }
        };
        return _this;
    }
    Table_1 = Table;
    Table.prototype.render = function () {
        return React.createElement("div", { className: "cardModuleTable cardModule" }, React.createElement("div", { className: "container" }, React.createElement(Components_1.VerticalScroll, { parent: this }, React.createElement("div", { className: "cardTitle" }, this.getTitle()), React.createElement("div", { className: "table" }, React.createElement("table", null, React.createElement("tbody", null, this.props.container.data.map(function (listItem, idx) {
            return React.createElement("tr", { key: idx }, React.createElement("td", null, listItem.text), React.createElement("td", null, listItem.value));
        })))))));
    };
    Table = Table_1 = __decorate([HOC_1.statics({
        moduleName: "table",
        validate: function validate(card, moduleType, parent, props) {
            var container = Services_1.Helper.getContainer(card, 'listing');
            if (container && container.data && container.data.length > 0) {
                var Instantiated = HOC_1.navigable(Table_1);
                return React.createElement(Instantiated, { container: container, parent: parent, isScrollable: true, card: card, moduleType: moduleType });
            }
            return null;
        }
    })], Table);
    return Table;
    var Table_1;
}(React.PureComponent);
exports.Table = Table;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "table.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 627:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var Services_1 = __webpack_require__(33);
var Components_1 = __webpack_require__(20);
var HOC_1 = __webpack_require__(17);
;
var List = function (_super) {
    __extends(List, _super);
    function List() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.getList = function () {
            var type = _this.props.moduleType;
            switch (type) {
                case 'Gallery':
                    return _this.getGalleryList();
                case 'Shop':
                case 'TravelShop':
                    return _this.getShopList();
                case 'Filmography':
                    return _this.getFilmographyList();
                case 'Cast':
                    return _this.getCastList();
                case 'AppearsInLocation':
                case 'CompleteTheDeco':
                    return _this.getRelSingleList();
                case 'Seasons':
                    return _this.getSeasonList();
            }
        };
        _this.getGalleryList = function () {
            if (_this.props.container) {
                var elements = _this.props.container.data.map(function (el, i) {
                    return React.createElement(Components_1.NavigationContainer, { key: _this.props.container.content_type + '_show_' + i, parent: _this, forceOrder: i % _this.props.itemsShown, columns: 2, className: "horizontalElement listElement focusable" }, React.createElement("img", { src: el.thumb }));
                });
                return elements;
            }
            return null;
        };
        _this.getShopList = function () {
            if (_this.props.container) {
                var elements = _this.props.container.data.map(function (el, i) {
                    return _this.getGenericElement(el.price.toString() + el.currency, el.image, i);
                });
                return elements;
            }
            return null;
        };
        _this.getFilmographyList = function () {
            if (_this.props.container) {
                var elements = _this.props.container.data.map(function (el, i) {
                    return _this.getGenericElement(el.from.title, el.from.image ? el.from.image.thumb : null, i);
                });
                return elements;
            }
            return null;
        };
        _this.getCastList = function () {
            if (_this.props.container) {
                var elements = _this.props.container.data.filter(function (el) {
                    return el.rel_type == 'plays' && el.from.image !== null;
                }).map(function (el, i) {
                    return _this.getGenericElement(el.from.title, el.from.image.thumb, i);
                });
                return elements;
            }
            return null;
        };
        _this.getRelSingleList = function () {
            if (_this.props.container) {
                var elements = _this.props.container.data.map(function (el, i) {
                    return _this.getGenericElement(el.title, el.image.thumb, i);
                });
                return elements;
            }
            return null;
        };
        _this.getSeasonList = function () {
            if (_this.props.container) {
                var elements = _this.props.container.data.map(function (el, i) {
                    return _this.getGenericElement('Season ' + el.season_index, el.image.thumb, i);
                });
                return elements;
            }
            return null;
        };
        _this.getGenericElement = function (title, image, order) {
            return React.createElement(Components_1.NavigationContainer, { key: _this.props.container.content_type + '_show_' + order, parent: _this, forceOrder: order % _this.props.itemsShown, columns: 2, className: "horizontalElement listElement" }, React.createElement("div", { className: "image focusable" }, React.createElement("img", { src: image })), React.createElement("div", { className: "title focusable" }, title));
        };
        _this.getTitle = function () {
            switch (_this.props.container.content_type) {
                case 'gallery':
                    return Services_1.Localize('GALLERY');
                default:
                    return null;
            }
        };
        return _this;
    }
    List_1 = List;
    List.getContainer = function (card, moduleType) {
        console.log("Filmography card: ", card);
        switch (moduleType) {
            case 'Gallery':
                return Services_1.Helper.getContainer(card, 'image');
            case 'Shop':
                var obj = {
                    content_type: 'products',
                    data: card.products,
                    type: 'listing'
                };
                return obj;
            case 'TravelShop':
                var obj2 = {
                    content_type: 'products',
                    data: card.products,
                    type: 'listing'
                };
                return obj2;
            case 'Filmography':
                return Services_1.Helper.getRelation(card.relations, 'filmography', 'content_type');
            case 'Cast':
                return Services_1.Helper.getRelation(card.relations, 'casting', 'content_type');
            case 'Seasons':
                return Services_1.Helper.getContainer(card, 'seasons');
            case 'AppearsInLocation':
                return Services_1.Helper.getRelation(card.relations, 'filmed_in', 'content_type');
            case 'CompleteTheDeco':
                return Services_1.Helper.getRelation(card.relations, 'home_deco', 'content_type');
            default:
                return undefined;
        }
    };
    List.prototype.render = function () {
        var textTitle = this.getTitle();
        return React.createElement("div", { className: "cardModuleList cardModule" }, React.createElement("div", { className: "container" }, React.createElement("div", { className: "cardTitle" }, textTitle), React.createElement("div", { className: "listContent" }, React.createElement(Components_1.HorizontalScroll, { parent: this, uniqueId: this.props.container.content_type, itemsShown: this.props.itemsShown }, this.getList()))));
    };
    List = List_1 = __decorate([HOC_1.statics({
        moduleName: "list",
        validate: function validate(card, moduleType, parent, props) {
            var container = List_1.getContainer(card, moduleType);
            if (container !== undefined && container.data !== undefined && container.data.length > 0) {
                var Instantiated = HOC_1.navigable(List_1);
                return React.createElement(Instantiated, { itemsShown: 2, container: container, parent: parent, isScrollable: true, card: card, moduleType: moduleType });
            }
            return null;
        }
    })], List);
    return List;
    var List_1;
}(React.PureComponent);
exports.List = List;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "list.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 628:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var Services_1 = __webpack_require__(33);
var Components_1 = __webpack_require__(20);
var HOC_1 = __webpack_require__(17);
var Awards = function (_super) {
    __extends(Awards, _super);
    function Awards() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.getTitle = function () {
            return Localize('AWARDS');
        };
        return _this;
    }
    Awards_1 = Awards;
    Awards.prototype.render = function () {
        return React.createElement("div", { className: "cardModuleAwards cardModule" }, React.createElement("div", { className: "container" }, React.createElement(Components_1.VerticalScroll, { parent: this }, React.createElement("div", { className: "cardTitle" }, this.getTitle()), React.createElement("div", { className: "awards" }, React.createElement("table", null, React.createElement("tbody", null, this.props.container.data.map(function (listItem, idx) {
            var winnerNum = listItem.winner instanceof Array && listItem.winner.length > 0 ? listItem.winner.length : 0;
            var nomineeNum = listItem.nominee instanceof Array && listItem.nominee.length > 0 ? listItem.nominee.length : 0;
            var nomineeTexts = nomineeNum > 0 ? nomineeNum + " " + (nomineeNum > 1 ? Localize("NOMINEE_PLURAL") : Localize("NOMINEE_SINGULAR")) : "";
            var totalAwardsTexts = winnerNum > 0 ? winnerNum + " " + (winnerNum > 1 ? Localize("WINNER_PLURAL") : Localize("WINNER_SINGULAR")) + (nomineeNum > 0 ? " / " + nomineeTexts : "") : nomineeTexts;
            return React.createElement("tr", { key: idx }, React.createElement("td", null, React.createElement("table", null, React.createElement("tbody", null, React.createElement("tr", { key: "name", className: "awardName" }, React.createElement("td", null, listItem.title)), React.createElement("tr", { key: "num", className: "awardNums" }, React.createElement("td", null, totalAwardsTexts))))));
        })))))));
    };
    Awards = Awards_1 = __decorate([HOC_1.statics({
        moduleName: "awards",
        validate: function validate(card, moduleType, parent, props) {
            var container = Services_1.Helper.getContainer(card, 'awards');
            if (container && container.data && container.data.length > 0) {
                var Instantiated = HOC_1.navigable(Awards_1);
                return React.createElement(Instantiated, { container: container, parent: parent, isScrollable: true, card: card, moduleType: moduleType });
            }
            return null;
        }
    })], Awards);
    return Awards;
    var Awards_1;
}(React.PureComponent);
exports.Awards = Awards;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "awards.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 629:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var Services_1 = __webpack_require__(33);
var HOC_1 = __webpack_require__(17);
var Map = function (_super) {
    __extends(Map, _super);
    function Map() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Map_1 = Map;
    Map.prototype.render = function () {
        var textTitle = this.getTitle();
        var _a = this.props.mapData,
            latitude = _a.latitude,
            longitude = _a.longitude,
            zoom = _a.zoom;
        var mapUrl = "https://maps.googleapis.com/maps/api/staticmap?center=" + latitude + "," + longitude + "&size=300x168";
        var appliedZoom = parseInt("" + zoom, 10);
        if (appliedZoom) {
            mapUrl += "&zoom=" + appliedZoom;
        }
        return React.createElement("div", { className: "cardModuleMap cardModule" }, React.createElement("div", { className: "container" }, textTitle ? React.createElement("div", { className: "cardTitle" }, textTitle) : null, React.createElement("div", { className: "map" }, React.createElement("img", { src: mapUrl, className: "mapThumbnail" }))));
    };
    Map.prototype.getTitle = function () {
        if (this.props.container === undefined) {
            return '';
        }
        return Services_1.Localize('LOCATION');
    };
    Map = Map_1 = __decorate([HOC_1.statics({
        moduleName: "map",
        validate: function validate(card, moduleType, parent, props) {
            console.log("[Map] card: ", card);
            var container = Services_1.Helper.getContainer(card, 'map');
            if (container !== undefined && container.data !== undefined && container.data.length > 0 && container.data[0].latitude && container.data[0].longitude) {
                var Instantiated = HOC_1.navigable(Map_1);
                return React.createElement(Instantiated, __assign({}, props, { container: container, mapData: container.data[0], parent: parent, card: card, moduleType: moduleType }));
            }
            return null;
        }
    })], Map);
    return Map;
    var Map_1;
}(React.PureComponent);
exports.Map = Map;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "map.component.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 630:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var CardModules_1 = __webpack_require__(267);
exports.cardModuleClasses = {
    Header: CardModules_1.Header,
    ButtonHeader: CardModules_1.Header,
    MovieHeader: CardModules_1.Header,
    Description: CardModules_1.Text,
    Biography: CardModules_1.Text,
    Reference: CardModules_1.Text,
    FullCuriosity: CardModules_1.Text,
    Overview: CardModules_1.Text,
    Gallery: CardModules_1.List,
    Shop: CardModules_1.List,
    TravelShop: CardModules_1.List,
    Directors: CardModules_1.List,
    Seasons: CardModules_1.List,
    Filmography: CardModules_1.List,
    Cast: CardModules_1.List,
    AppearsInLocation: CardModules_1.List,
    CompleteTheDeco: CardModules_1.List,
    Specifications: CardModules_1.Table,
    BasicInfo: CardModules_1.Table,
    AwardsModuleList: CardModules_1.Awards,
    MapModule: CardModules_1.Map
};

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "cardDetail.modules.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 631:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var Components_1 = __webpack_require__(20);
var HOC_1 = __webpack_require__(17);
var CardDetailContainerClass = function (_super) {
    __extends(CardDetailContainerClass, _super);
    function CardDetailContainerClass() {
        var _this = _super.call(this) || this;
        _this.state = { status: "LOADING", card: undefined };
        return _this;
    }
    CardDetailContainerClass.prototype.componentDidMount = function () {
        var _this = this;
        if (this.state && this.state.status === "LOADING") {
            if (this.props.version != null) {
                DiveAPI.getCardVersion({ cardId: this.props.cardId, version: this.props.version, products: true }).then(function (card) {
                    console.log("[card] " + card.title + ": ", card);
                    _this.setState(__assign({}, _this.state, { status: "LOADED", card: card }));
                });
            } else {
                DiveAPI.getCard({ cardId: this.props.cardId, products: true }).then(function (card) {
                    console.log("[card] " + card.title + ": ", card);
                    _this.setState(__assign({}, _this.state, { status: "LOADED", card: card }));
                });
            }
        }
    };
    CardDetailContainerClass.prototype.render = function () {
        var subcomponent = !this.state || this.state.status !== "LOADED" ? React.createElement(Components_1.Loading, null) : React.createElement(Components_1.CardDetail, { parent: this, card: this.state.card, columns: 1, navClass: "cardDetailNav", isDefault: true });
        return subcomponent;
    };
    return CardDetailContainerClass;
}(React.PureComponent);
exports.CardDetailContainerClass = CardDetailContainerClass;
exports.CardDetailContainer = HOC_1.navigable(CardDetailContainerClass);

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "cardDetail.container.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 632:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var Components_1 = __webpack_require__(20);
;
var BottomOverlayMessage = function (_super) {
    __extends(BottomOverlayMessage, _super);
    function BottomOverlayMessage(props) {
        var _this = _super.call(this, props) || this;
        _this.state = { hidden: false };
        return _this;
    }
    BottomOverlayMessage.prototype.render = function () {
        return this.state && this.state.hidden ? null : this.getChildren();
    };
    BottomOverlayMessage.prototype.getChildren = function () {
        var _this = this;
        return React.createElement("div", { className: "bottomMessage fillParent" }, React.createElement(Components_1.NavigationContainer, { modal: true, parent: this.props.navigationParent, isDefault: true, propagateParent: true, columns: 1 }, React.createElement("div", { className: "messageContainer" }, React.createElement("div", { className: "closeContainer" }, React.createElement(Components_1.NavigationContainer, { className: "carouselButton carouselClose", parent: this, isDefault: true, columns: 1, onClick: function onClick() {
                _this.setState({ hidden: true });
            } })), this.props.children)));
    };
    return BottomOverlayMessage;
}(React.PureComponent);
exports.BottomOverlayMessage = BottomOverlayMessage;

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "bottomOverlayMessage.container.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 633:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = this && this.__assign || Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __webpack_require__(4);
var react_redux_1 = __webpack_require__(52);
var redux_1 = __webpack_require__(80);
var HOC_1 = __webpack_require__(17);
var Components_1 = __webpack_require__(20);
var Actions_1 = __webpack_require__(61);
var Services_1 = __webpack_require__(33);
var Constants_1 = __webpack_require__(266);
var Containers_1 = __webpack_require__(99);
var CarouselClass = function (_super) {
    __extends(CarouselClass, _super);
    function CarouselClass(props) {
        var _this = _super.call(this, props) || this;
        _this.chunkRequested = false;
        _this.currentSceneText = Services_1.Localize("CURRENT_SCENE");
        _this.getState = function () {
            return _this.props.state;
        };
        _this.state = { rewinded: false };
        _this.closeCarousel = _this.closeCarousel.bind(_this);
        _this.getCurrentTime = _this.getCurrentTime.bind(_this);
        _this.adMessageContent = React.createElement("div", { key: "adMessageContent", className: "fillParent adMessage carouselMessageContent" }, React.createElement("div", { className: "adMessageLeft" }, React.createElement("h1", null, Services_1.Localize("PIZZA_OR_POP_CORN")), React.createElement("p", { className: "text1" }, Services_1.Localize("WE_RECOMMEND")), React.createElement("p", { className: "text2" }, Services_1.Localize("MAKE_POP_CORN"))), React.createElement("div", { className: "adMessageRight" }, React.createElement("h1", null, Services_1.Localize("TVGRID_COMMERCIAL_TXT"))));
        _this.endMessageContent = React.createElement("div", { key: "endMessageContent", className: "fillParent endMessage carouselMessageContent centeredMessage" }, React.createElement("div", { className: "messageCenter" }, React.createElement("h1", null, Services_1.Localize("EVERYTHING_END")), React.createElement("p", { className: "text1" }, Services_1.Localize("MOVIE_ENDED")), React.createElement("div", { className: "buttonsContainer" }, React.createElement(Components_1.NavigationContainer, { className: "genericBtn", parent: _this, isDefault: true, columns: 1, key: "messageCloseCarousel", onClick: function onClick() {
                _this.props.uiActions.open({ top: "TV", bottom: "GRID" });
            } }, Services_1.Localize("OKAY")))));
        _this.offMessageContent = React.createElement("div", { key: "offMessageContent", className: "fillParent offMessageContent carouselMessageContent centeredMessage" }, React.createElement("div", { className: "messageCenter" }, React.createElement("h1", null, Services_1.Localize("EVERYTHING_END")), React.createElement("p", { className: "text1" }, Services_1.Localize("MOVIE_OFF")), React.createElement("div", { className: "buttonsContainer" }, React.createElement(Components_1.NavigationContainer, { className: "genericBtn", key: "messageCloseCarousel", parent: _this, isDefault: true, columns: 1, onClick: function onClick() {
                _this.props.uiActions.open({ top: "TV", bottom: "GRID" });
            } }, Services_1.Localize("OKAY")))));
        _this.readyMessageContent = React.createElement("div", { key: "offMessageContent", className: "fillParent readyMessageContent carouselMessageContent centeredMessage" }, React.createElement("div", { className: "messageCenter" }, React.createElement("h1", null, Services_1.Localize("LIGHTS_CAMERA")), React.createElement("p", { className: "text1" }, Services_1.Localize("WE_ARE_LOADING"))));
        return _this;
    }
    CarouselClass.prototype.componentWillUpdate = function (nextProps) {};
    CarouselClass.prototype.componentWillMount = function () {
        this.props.syncChannel();
        this.activeFilters = [this.allCategoriesFilter];
    };
    CarouselClass.prototype.componentWillUnmount = function () {};
    CarouselClass.prototype.render = function () {
        var _this = this;
        var cards = this.props.state.cards !== undefined ? this.props.state.cards : [];
        cards = cards.filter(function (card) {
            return card && card.type && Constants_1.SUPPORTED_CARD_TYPES.indexOf(card.type) > -1 && card.type !== 'person';
        });
        return React.createElement("div", { className: "containerCarousel fillParent" }, React.createElement(Components_1.NavigationContainer, { key: "buttonContainer", ref: function ref(el) {
                if (el) {
                    _this.buttonsContainer = el.getWrappedInstance().refComponent;
                }
            }, propagateParent: false, parent: this, forceFirst: true, columns: 1 }, this.buttonsContainer ? this.getButtons() : ""), React.createElement("div", { className: "cards" }, cards.length === 0 ? React.createElement(Components_1.Loading, null) : React.createElement(Components_1.MiniCardList, { elements: cards, movieId: this.getState().movieId, getMovieTime: this.getCurrentTime, parent: this, columns: 1, key: this.props.state.movieId + "#" + Date.now, groupName: "MiniCardList", setSelectedOnSceneChange: this.props.setSelectedOnSceneChange, wasSelectedOnChangeScene: this.props.state.selectedOnSceneChange })), this.getMessageForCarousel());
    };
    CarouselClass.prototype.getCurrentTime = function () {
        return this.props.state.currentTime;
    };
    CarouselClass.prototype.getButtons = function () {
        var currentTimeInSecs = this.props.state.currentTime;
        var hours = Math.floor(currentTimeInSecs / 3600);
        currentTimeInSecs %= 3600;
        var minutes = Math.floor(currentTimeInSecs / 60);
        var seconds = parseInt((currentTimeInSecs % 60).toFixed(0), 10);
        var buttonCount = 7;
        if (0) {
            buttonCount--;
        }
        if (0) {
            buttonCount--;
        }
        if (this.state.rewinded === false) {
            buttonCount--;
        }
        var timeFormatted = (hours < 10 ? "0" + hours : hours) + ":" + ((minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds));
        var buttonsToRender = [];
        buttonsToRender.push(React.createElement(Components_1.NavigationContainer, { key: "carouselClose", className: "carouselButton bctButton close", forceOrder: 0, parent: this.buttonsContainer, onClick: this.closeCarousel }));
        return React.createElement("div", { id: "carouselButtons", className: "bottomContainerTopButtons" }, buttonsToRender);
    };
    CarouselClass.prototype.closeCarousel = function () {
        this.props.uiActions.open({ top: "TV", bottom: "GRID" });
    };
    CarouselClass.prototype.getMessageForCarousel = function () {
        var messageContent;
        var channelStatus = this.getState().channelStatus;
        if (channelStatus === "paused") {
            messageContent = this.adMessageContent;
        } else if (channelStatus === "end") {
            messageContent = this.endMessageContent;
        } else if (channelStatus === "off") {
            messageContent = this.offMessageContent;
        } else if (channelStatus === "ready") {
            messageContent = this.readyMessageContent;
        }
        if (messageContent) {
            return React.createElement(Containers_1.BottomOverlayMessage, { key: "bottomMessage#" + this.props.state.timeMovieSynced + "#" + channelStatus, navigationParent: this }, messageContent);
        }
    };
    CarouselClass.prototype.allCategoriesFilter = function () {
        return true;
    };
    return CarouselClass;
}(React.PureComponent);
exports.CarouselClass = CarouselClass;
var mapStateToProps = function mapStateToProps(state) {
    return { state: __assign({}, state.carousel) };
};
var mapDispatchToProps = function mapDispatchToProps(dispatch) {
    return __assign({}, redux_1.bindActionCreators(Actions_1.SyncActions, dispatch), { uiActions: redux_1.bindActionCreators(Actions_1.UIActions, dispatch) });
};
exports.Carousel = HOC_1.navigable(react_redux_1.connect(mapStateToProps, mapDispatchToProps)(CarouselClass));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "carousel.container.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ }),

/***/ 99:
/***/ (function(module, exports, __webpack_require__) {

/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-api/modules/index.js"), RootInstanceProvider = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/RootInstanceProvider.js"), ReactMount = require("react-dom/lib/ReactMount"), React = require("react"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {

"use strict";

function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(522));
__export(__webpack_require__(525));
__export(__webpack_require__(526));
__export(__webpack_require__(631));
__export(__webpack_require__(632));
__export(__webpack_require__(633));

/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require("/Users/daniel.marino/Desktop/REACT/api-front-library-react/node_modules/react-hot-loader/makeExportsHot.js"); if (makeExportsHot(module, require("react"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error("Cannot apply hot update to " + "index.tsx" + ": " + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }

/***/ })

},[312]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy8uL0hPQy9pbmRleC50c3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9jb25zdGFudHMudHN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jYXJkTW9kdWxlcy9pbmRleC50c3giLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9kYW5pZWwubWFyaW5vL0Rlc2t0b3AvUkVBQ1QvYXBpLXR5cGVzY3JpcHQtbGlicmFyeS9kaXN0L2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9tYWluLnRzeCIsIndlYnBhY2s6Ly8vLi9zZXJ2aWNlcy9pbmRleC50c3giLCJ3ZWJwYWNrOi8vLy4vc3RvcmUvc3RvcmUudHMiLCJ3ZWJwYWNrOi8vLy4vbWlkZGxld2FyZS9zb2NrZXQubWlkZGxld2FyZS50c3giLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy91aS5hY3Rpb25zLnRzIiwid2VicGFjazovLy8uL2FjdGlvbnMvbmF2LmFjdGlvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9zeW5jLmFjdGlvbnMudHN4Iiwid2VicGFjazovLy8uL2FjdGlvbnMvc29ja2V0LmFjdGlvbnMudHN4Iiwid2VicGFjazovLy8uL2FjdGlvbnMvdXNlci5hY3Rpb25zLnRzeCIsIndlYnBhY2s6Ly8vd3MgKGlnbm9yZWQpIiwid2VicGFjazovLy8uL3JlZHVjZXJzL2luZGV4LnRzIiwid2VicGFjazovLy8uL3JlZHVjZXJzL25hdi5yZWR1Y2VyLnRzIiwid2VicGFjazovLy8uL3JlZHVjZXJzL3VpLnJlZHVjZXIudHMiLCJ3ZWJwYWNrOi8vLy4vcmVkdWNlcnMvc3luYy5yZWR1Y2VyLnRzeCIsIndlYnBhY2s6Ly8vLi9yZWR1Y2Vycy91c2VyLnJlZHVjZXIudHN4Iiwid2VicGFjazovLy8uL2NvbnRhaW5lcnMvbGF5b3V0L2xheW91dC5jb250YWluZXIudHN4Iiwid2VicGFjazovLy8uL0hPQy9uYXZpZ2FibGUvbmF2aWdhYmxlLkhPQy50c3giLCJ3ZWJwYWNrOi8vLy4vSE9DL3N0YXRpY3Mvc3RhdGljcy5IT0MudHN4Iiwid2VicGFjazovLy8uL2NvbnRhaW5lcnMvQXBwL2FwcC50c3giLCJ3ZWJwYWNrOi8vLy4vY29udGFpbmVycy9jYXJkTW9kdWxlTGlzdC9jYXJkTW9kdWxlTGlzdC5jb250YWluZXIudHN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jYXJkTW9kdWxlcy9jYXJkRGV0YWlsLmNvbmZpZy50c3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9hcnQuanNvbiIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY29uZmlnL2J1c2luZXNzLmpzb24iLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9jaGFwdGVyLmpzb24iLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9mYXNoaW9uLmpzb24iLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9mYXVuYV9mbG9yYS5qc29uIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvZm9vZF9kcmluay5qc29uIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvaGVhbHRoX2JlYXV0eS5qc29uIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvaGlzdG9yaWMuanNvbiIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY29uZmlnL2hvbWUuanNvbiIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY29uZmlnL2xlaXN1cmVfc3BvcnQuanNvbiIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY29uZmlnL2xvY2F0aW9uLmpzb24iLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9sb29rLmpzb24iLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9tb3ZpZS5qc29uIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvb3N0Lmpzb24iLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9wZXJzb24uanNvbiIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY29uZmlnL2NoYXJhY3Rlci5qc29uIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvcmVmZXJlbmNlLmpzb24iLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9zZXJpZS5qc29uIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvc29uZy5qc29uIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvdGVjaG5vbG9neS5qc29uIiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvdHJpdmlhLmpzb24iLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy92ZWhpY2xlLmpzb24iLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy93ZWFwb24uanNvbiIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY2FyZE1vZHVsZXMvY2FyZE1vZHVsZS5iYXNlLmNvbXBvbmVudC50c3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NhcmRNb2R1bGVzL2hlYWRlci9oZWFkZXIuY29tcG9uZW50LnRzeCIsIndlYnBhY2s6Ly8vLi9zZXJ2aWNlcy9oZWxwZXIudHN4Iiwid2VicGFjazovLy8uL3NlcnZpY2VzL2xvY2FsaXplZF90ZXh0cy50c3giLCJ3ZWJwYWNrOi8vLy4vYWN0aW9ucy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvRVMvbG9jYWxpemVkX3RleHRzLmpzb24iLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL0VOL2xvY2FsaXplZF90ZXh0cy5qc29uIiwid2VicGFjazovLy8uL2Fzc2V0cy9ERS9sb2NhbGl6ZWRfdGV4dHMuanNvbiIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL25hdmlnYXRpb25Db250YWluZXIvbmF2aWdhdGlvbkNvbnRhaW5lci5jb21wb25lbnQudHN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jYXJkRGV0YWlsLmNvbXBvbmVudC50c3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkQW5kQ2F0ZWdvcnkvY2FyZEFuZENhdGVnb3J5LmNvbXBvbmVudC50c3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy92ZXJ0aWNhbFNjcm9sbC92ZXJ0aWNhbFNjcm9sbC5jb21wb25lbnQudHN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvaG9yaXpvbnRhbFNjcm9sbC9ob3Jpem9udGFsU2Nyb2xsLmNvbXBvbmVudC50c3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9kaXJlY3Rpb25CdXR0b25MaXN0L2RpcmVjdGlvbkJ1dHRvbkxpc3QuY29tcG9uZW50LnRzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2RpcmVjdGlvbkJ1dHRvbkxpc3QvZGlyZWN0aW9uQnV0dG9uL2RpcmVjdGlvbkJ1dHRvbi5jb21wb25lbnQudHN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvbWluaUNhcmQvbWluaUNhcmRCdXR0b24vbWluaUNhcmRCdXR0b24uY29tcG9uZW50LnRzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21pbmlDYXJkTGlzdC9taW5pQ2FyZExpc3QuY29tcG9uZW50LnRzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21pbmlDYXJkL21pbmlDYXJkLmNvbXBvbmVudC50c3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9sb2FkaW5nL2xvYWRpbmcuY29tcG9uZW50LnRzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY2FyZE1vZHVsZXMvdGV4dC90ZXh0LmNvbXBvbmVudC50c3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NhcmRNb2R1bGVzL3RhYmxlL3RhYmxlLmNvbXBvbmVudC50c3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NhcmRNb2R1bGVzL2xpc3QvbGlzdC5jb21wb25lbnQudHN4Iiwid2VicGFjazovLy8uL2NvbXBvbmVudHMvY2FyZERldGFpbC9jYXJkTW9kdWxlcy9hd2FyZHMvYXdhcmRzLmNvbXBvbmVudC50c3giLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NhcmRNb2R1bGVzL21hcC9tYXAuY29tcG9uZW50LnRzeCIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY2FyZE1vZHVsZXMvY2FyZERldGFpbC5tb2R1bGVzLnRzeCIsIndlYnBhY2s6Ly8vLi9jb250YWluZXJzL2NhcmREZXRhaWwvY2FyZERldGFpbC5jb250YWluZXIudHN4Iiwid2VicGFjazovLy8uL2NvbnRhaW5lcnMvdWkvYm90dG9tT3ZlcmxheU1lc3NhZ2UuY29udGFpbmVyLnRzeCIsIndlYnBhY2s6Ly8vLi9jb250YWluZXJzL2Nhcm91c2VsL2Nhcm91c2VsLmNvbnRhaW5lci50c3giLCJ3ZWJwYWNrOi8vLy4vY29udGFpbmVycy9pbmRleC50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxDQUFDO0FBQ0QsTzs7Ozs7Ozs7Ozs7Ozs7O0FDVkEsNkJBQTBDO0FBQzFDLDZCQUFzQyxNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRHRDLDZCQUFvRTtBQUNwRSw2QkFBa0Q7QUFDbEQsNkJBQTREO0FBQzVELDZCQUEwRDtBQUMxRCw2QkFBOEQ7QUFDOUQsNkJBQW9FO0FBQ3BFLDZCQUFnRjtBQUNoRiw2QkFBbUU7QUFDbkUsNkJBQXNEO0FBQ3RELDZCQUE4QztBQUM5Qyw2QkFBNEMsTTs7Ozs7Ozs7Ozs7Ozs7QUNDNUMsSUFBaUIsY0FBdUM7QUFFeEQsSUFBbUIsZ0JBQWtCO0FBRXhCLFFBQW1CLHNCQUFlO0FBTWxDLFFBQWdCLG1CQUFzQztBQUN0RCxRQUFjLGlCQUFpQjtBQUUvQixRQUFvQix1QkFBRyxDQUN6QixTQUNBLFNBQ0MsVUFDRyxhQUNGLFdBQ0EsV0FDQyxZQUNBLFlBQ0YsVUFDRCxTQUNGLE9BQ0MsUUFDTSxjQUNQLE9BQ0MsUUFHRSxVQUNPLGlCQUNBLGlCQUNILGNBQ0MsZUFDSCxZQUNDLGFBSWIsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BERiw2QkFBb0M7QUFDcEMsNkJBQTRDO0FBQzVDLDZCQUEwQztBQUMxQyw2QkFBc0M7QUFDdEMsNkJBQXdDO0FBQ3hDLDZCQUFzQztBQUN0Qyw2QkFBMEM7QUFDMUMsNkJBQW9DO0FBRXBDLDZCQUFxQyxNOzs7Ozs7Ozs7QUNUckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtEQUErRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFlBQVk7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFlBQVk7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsS0FBSyxZQUFZO0FBQ2pCO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksVUFBVTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7O0FBR3pDLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxRQUFRLG1CQUFtQixVQUFVLEVBQUUsRUFBRTtBQUMxRSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUdBQXlHLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSTs7QUFFakk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFO0FBQ3hFOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLGtGQUFrRjtBQUNsRjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsT0FBTztBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFB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QUFLO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHFEQUFxRCxXQUFXLFNBQVMsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXLFNBQVMsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXLFNBQVMsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXLFNBQVMsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVcsU0FBUyxLQUFLO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXLFNBQVMsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVyxTQUFTLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXLFNBQVMsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHFEQUFxRCxXQUFXLFNBQVMsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQUs7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsc0RBQXNELGtDQUFrQztBQUN4RixDQUFD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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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O0FBR0QsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtB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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixzQ0FBc0M7O0FBRWhFLGtCQUFrQixnQkFBZ0I7QUFDbEMsZ0JBQWdCLGNBQWM7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QUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7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QU0sU0FGSSxNQUVBLElBQWMsa0JBQWEsU0FBRTtBQUNyQiw2QkFBTyxLQUN6QjtBQUFDO0FBSUUsWUFBbUQsZ0JBQUU7QUFDN0MsbUJBQ0gsb0JBQUMsYUFBb0Isd0JBQ2QsS0FBRSxtQkFBcUIsS0FBTSxNQUFNLE1BQWdCLHdCQUFtQixlQUN6RCxrQkFBTSxRQUlsQztBQUNKO0FBQUM7QUFHTyw0QkFBbUIsc0JBQTNCO0FBQ1UsZUFDVjtBQUFDO0FBQ0wsV0FBQztBQUFBLEVBM05nQixNQTJOaEI7QUE1Tlksd0JBQWE7QUE4TjFCLElBQXFCLGtCQUFHLHlCQUFjO0FBQTRCLFdBQUMsRUFBTyxvQkFBWSxNQUFjO0FBQUM7QUFDckcsSUFBd0IscUJBQUcsNEJBQWM7QUFDL0Isd0JBQ0MsUUFBa0IsbUJBQUMsVUFBVyxhQUFXLGFBQ25DLFdBQUUsUUFBa0IsbUJBQUMsVUFBUyxXQUUvQztBQUFFO0FBRVcsUUFBUSxXQUFHLE1BQVMsVUFBQyxjQUFPLFFBQ3RCLGlCQUVsQixvQkFBaUIsZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyUGxCLDZCQUEwQztBQUMxQyw2QkFBMEI7QUFDMUIsNkJBQTBEO0FBQzFELDZCQUFrRDtBQUNsRCw2QkFBb0Q7QUFDcEQsNkJBQThDLE0iLCJmaWxlIjoiRGl2ZVNESy5mcm9udC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImZyb250XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkRpdmVTREtcIl0gPSByb290W1wiRGl2ZVNES1wiXSB8fCB7fSwgcm9vdFtcIkRpdmVTREtcIl1bXCJmcm9udFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJleHBvcnQgKiBmcm9tICcuL25hdmlnYWJsZS9uYXZpZ2FibGUuSE9DJztcbmV4cG9ydCAqIGZyb20gJy4vc3RhdGljcy9zdGF0aWNzLkhPQyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9IT0MvaW5kZXgudHN4IiwiZXhwb3J0ICogZnJvbSAnLi9uYXZpZ2F0aW9uQ29udGFpbmVyL25hdmlnYXRpb25Db250YWluZXIuY29tcG9uZW50JztcbmV4cG9ydCAqIGZyb20gJy4vY2FyZERldGFpbC9jYXJkRGV0YWlsLmNvbXBvbmVudCc7XG5leHBvcnQgKiBmcm9tICcuL2NhcmRBbmRDYXRlZ29yeS9jYXJkQW5kQ2F0ZWdvcnkuY29tcG9uZW50JztcbmV4cG9ydCAqIGZyb20gJy4vdmVydGljYWxTY3JvbGwvdmVydGljYWxTY3JvbGwuY29tcG9uZW50JztcbmV4cG9ydCAqIGZyb20gJy4vaG9yaXpvbnRhbFNjcm9sbC9ob3Jpem9udGFsU2Nyb2xsLmNvbXBvbmVudCc7XG5leHBvcnQgKiBmcm9tICcuL2RpcmVjdGlvbkJ1dHRvbkxpc3QvZGlyZWN0aW9uQnV0dG9uTGlzdC5jb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9kaXJlY3Rpb25CdXR0b25MaXN0L2RpcmVjdGlvbkJ1dHRvbi9kaXJlY3Rpb25CdXR0b24uY29tcG9uZW50JztcbmV4cG9ydCAqIGZyb20gJy4vbWluaUNhcmQvbWluaUNhcmRCdXR0b24vbWluaUNhcmRCdXR0b24uY29tcG9uZW50JztcbmV4cG9ydCAqIGZyb20gJy4vbWluaUNhcmRMaXN0L21pbmlDYXJkTGlzdC5jb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9taW5pQ2FyZC9taW5pQ2FyZC5jb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9sb2FkaW5nL2xvYWRpbmcuY29tcG9uZW50JztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvaW5kZXgudHMiLCIvL2ltcG9ydCAqIGFzIFJ4SlMgZnJvbSAncnhqcyc7XG4vLyBpbXBvcnQgeyBLZXlzTWFwcGVkIGFzIE9yc2F5S2V5c01hcHBlZCwgUm9sbGJhcktleSBhcyBPcnNheVJvbGxiYXJLZXkgfSBmcm9tIFwiLi90eXBlcy9leHRyYS5vcnNheVwiO1xuLy8gaW1wb3J0IHsgS2V5c01hcHBlZCBhcyBUaXplbktleXNNYXBwZWQsIFJvbGxiYXJLZXkgYXMgVGl6ZW5Sb2xsYmFyS2V5IH0gZnJvbSBcIi4vdHlwZXMvZXh0cmEudGl6ZW5cIjtcbmRlY2xhcmUgY29uc3QgX19FTkFCTEVfUk9MTEJBUl9fOiBib29sZWFuO1xuZGVjbGFyZSBjb25zdCBfX0VOQUJMRV9BTkFMWVRJQ1NfXzogYm9vbGVhbjtcbmRlY2xhcmUgY29uc3QgX19FTkFCTEVfQVdTX186IGJvb2xlYW47XG5kZWNsYXJlIGNvbnN0IF9fRU5BQkxFX1NFR01FTlRfXzogYm9vbGVhbjtcbmRlY2xhcmUgY29uc3QgX19FTkFCTEVfV0hZX186IGJvb2xlYW47XG5kZWNsYXJlIGNvbnN0IF9fRElWRV9FTlZfXzogXCJERVZcIiB8IFwiUFJFXCIgfCBcIlBST1wiO1xuZGVjbGFyZSBjb25zdCBfX0RJVkVfVkVSU0lPTl9fOiBzdHJpbmc7XG5kZWNsYXJlIGNvbnN0IF9fQ0hVTktfVkVSU0lPTl9fOiBzdHJpbmc7XG5jb25zdCBlbnZpcm9ubWVudDogXCJERVZcIiB8IFwiUFJFXCIgfCBcIlBST1wiID0gX19ESVZFX0VOVl9fO1xuLy8gY29uc3Qgcm9sbGJhcktleTogc3RyaW5nID0gZ2V0Um9sbGJhcktleSgpO1xuY29uc3QgZW5hYmxlUm9sbGJhcjogYm9vbGVhbiA9IGZhbHNlO1xuXG5leHBvcnQgY29uc3QgU0VTU0lPTl9TVE9SQUdFX0tFWSA9ICdEaXZlU3RhdGUnO1xuLypleHBvcnQgY29uc3Qga2V5RG93bk9ic2VydmFibGUkID0gUnhKUy5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgXCJrZXlkb3duXCIpXG4gICAgLm1hcCgoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IGV2ZW50LmtleUNvZGUpO1xuZXhwb3J0IGNvbnN0IGtleVVwT2JzZXJ2YWJsZSQgPSBSeEpTLk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCBcImtleXVwXCIpXG4gICAgLm1hcCgoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IGV2ZW50LmtleUNvZGUpOyovXG5cbmV4cG9ydCBjb25zdCBESVZFX0VOVklST05NRU5UOiBcIkRFVlwiIHwgXCJQUkVcIiB8IFwiUFJPXCIgPSBlbnZpcm9ubWVudDtcbmV4cG9ydCBjb25zdCBFTkFCTEVfUk9MTEJBUiA9IGVuYWJsZVJvbGxiYXI7XG4vKiBDQVJPVVNFTCAqL1xuZXhwb3J0IGNvbnN0IFNVUFBPUlRFRF9DQVJEX1RZUEVTID0gW1xuICAgIFwibW92aWVcIiwgLy8gMSAtIENhdGFsb2cgbW92aWVcbiAgICBcInNlcmllXCIsIC8vIDIgLSBDYXRhbG9nIGZ1bGwgc2VyaWVcbiAgICBcInBlcnNvblwiLCAvLyAzIC0gQWN0b3Igb3IgZGlyZWN0b3JcbiAgICBcImNoYXJhY3RlclwiLCAvLyA0IC0gTW92aWUgY2hhcmFjdGVyXG4gICAgXCJ2ZWhpY2xlXCIsIC8vIDUgLSBWZWhpY2xlIGRlc2NyaXB0aW9uXG4gICAgXCJmYXNoaW9uXCIsIC8vIDYgLSBGYXNoaW9uIGl0ZW1cbiAgICBcImxvY2F0aW9uXCIsIC8vIDcgLSBSZWFsIG9yIGZpY3Rpb25hbCBsb2NhdGlvblxuICAgIFwiaGlzdG9yaWNcIiwgLy8gOSAtIEhpc3RvcmljYWwgY29udGV4dFxuICAgIFwidHJpdmlhXCIsIC8vIDEwIC0gTW92aWUgdHJpdmlhIG9yIGN1cmlvc2l0eVxuICAgIFwicXVvdGVcIiwgLy8gMTEgLSBQbG90IHF1b3RlXG4gICAgXCJvc3RcIiwgLy8gMTIgLSBPcmlnaW5hbCBTb3VudHJhY2tcbiAgICBcImhvbWVcIiwgLy8gMTMgLSBIb21lIGFuZCBkZWNvIGl0ZW1cbiAgICBcInRlY2hub2xvZ3lcIiwgLy8gMTQgLSBUZWNobm9sb2d5IGl0ZW1cbiAgICBcImFydFwiLCAvLyAxNiAtIEFydCBpdGVtXG4gICAgXCJzb25nXCIsIC8vIDE3IC0gU2luZ2xlIE9TVCBzb25nXG4gICAgLy8gXCJsb29rXCIsIC8vIDE4IC0gRmFzaGlvbiBsb29rXG4gICAgLy8gXCJ0cmFpbGVyXCIsIC8vIDE5IC0gTW92aWUgdHJhaWxlclxuICAgIFwid2VhcG9uXCIsIC8vIDIwIC0gV2VhcG9uIGl0ZW1cbiAgICBcImxlaXN1cmVfc3BvcnRcIiwgLy8gMjEgLSBMZWlzdXJlIG9yIHNwb3J0cyBpdGVtXG4gICAgXCJoZWFsdGhfYmVhdXR5XCIsIC8vIDIyIC0gSGVhbHRoIGFuZCBiZWF1dHkgaXRlbVxuICAgIFwiZm9vZF9kcmlua1wiLCAvLyAyMyAtIEZvb2Qgb3IgZHJpbmsgcmVjaXBlXG4gICAgXCJmYXVuYV9mbG9yYVwiLCAvLyAyNCAtIEFuaW1hbCBvciBwbGFudCBkZXNjcmlwdGlvblxuICAgIFwiYnVzaW5lc3NcIiwgLy8gMjUgLSBCdXNpbmVzcyBhbmQgam9icyByZWxhdGVkIGl0ZW1cbiAgICBcInJlZmVyZW5jZVwiLCAvLyAyNiAtIE1lbnRpb24gdG8gb3RoZXIgY2FyZCBpbiBhIG1vdmllXG4gICAgLy8gXCJ2aWRlb2NsaXBcIiwgLy8gMjcgLSBNdXNpYyB2aWRlb2NsaXBcbiAgICBcImNoYXB0ZXJcIiwgLy8gMjggLSBTZXJpZSBjaGFwdGVyXG4gICAgLy8gXCJhY3Rpb25fZW1vdGlvblwiLCAvLyAyOSAtIEFjdGlvbiBvciBlbW90aW9uIHNob3duIG9uc2NyZWVuXG5dO1xuXG4vKmZ1bmN0aW9uIGdldEtleUFsaWFzKCk6IElLZXlzVG9NYXAge1xuICAgIGlmIChfX1BMQVRGT1JNX18gPT09IFwib3JzYXlcIikge1xuICAgICAgICByZXR1cm4gT3JzYXlLZXlzTWFwcGVkO1xuICAgIH0gZWxzZSBpZiAoX19QTEFURk9STV9fID09PSBcInRpemVuXCIpIHtcbiAgICAgICAgcmV0dXJuIFRpemVuS2V5c01hcHBlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBBZGQgY2xpZW50IGtleXNcbiAgICAgICAgcmV0dXJuIE9yc2F5S2V5c01hcHBlZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFJvbGxiYXJLZXkoKSB7XG4gICAgaWYgKF9fUExBVEZPUk1fXyA9PT0gXCJvcnNheVwiKSB7XG4gICAgICAgIHJldHVybiBPcnNheVJvbGxiYXJLZXk7XG4gICAgfSBlbHNlIGlmIChfX1BMQVRGT1JNX18gPT09IFwidGl6ZW5cIikge1xuICAgICAgICByZXR1cm4gVGl6ZW5Sb2xsYmFyS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEFkZCBjbGllbnQga2V5c1xuICAgICAgICByZXR1cm4gT3JzYXlSb2xsYmFyS2V5O1xuICAgIH1cbn1cbiovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb25zdGFudHMudHN4IiwiZXhwb3J0ICogZnJvbSAnLi9jYXJkRGV0YWlsLmNvbmZpZyc7XG5leHBvcnQgKiBmcm9tICcuL2NhcmRNb2R1bGUuYmFzZS5jb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9oZWFkZXIvaGVhZGVyLmNvbXBvbmVudCc7XG5leHBvcnQgKiBmcm9tICcuL3RleHQvdGV4dC5jb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi90YWJsZS90YWJsZS5jb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9saXN0L2xpc3QuY29tcG9uZW50JztcbmV4cG9ydCAqIGZyb20gJy4vYXdhcmRzL2F3YXJkcy5jb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9tYXAvbWFwLmNvbXBvbmVudCc7XG4vLyBNdXN0IGJlIHRoZSBsYXN0IGl0ZW1cbmV4cG9ydCAqIGZyb20gJy4vY2FyZERldGFpbC5tb2R1bGVzJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jYXJkTW9kdWxlcy9pbmRleC50c3giLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDMxKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkpKVxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0cnVlKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcbnZhciBoYXNCaW5hcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbnZhciBzbGljZUJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xudmFyIGFmdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XG52YXIgdXRmOCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xuXG52YXIgYmFzZTY0ZW5jb2RlcjtcbmlmIChnbG9iYWwgJiYgZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG4gIGJhc2U2NGVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG4gKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuICpcbiAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG4gKi9cblxudmFyIGlzQW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHV0ZjhlbmNvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICBpICs9IG47XG4gICAgbGVuZ3RoID0gJyc7XG4gIH1cblxuICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cbiAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcclxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xyXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICB2YXIgc3RyID0gJyc7XHJcblxyXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xyXG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XHJcbiAgdmFyIHFyeSA9IHt9O1xyXG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcclxuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gIH1cclxuICByZXR1cm4gcXJ5O1xyXG59O1xyXG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgaGFzQmluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG52YXIgYmluYXJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG52YXIgaXNCdWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdBQ0snLFxuICAnRVJST1InLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0JJTkFSWV9BQ0snXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGlmICgob2JqLnR5cGUgPT09IGV4cG9ydHMuRVZFTlQgfHwgb2JqLnR5cGUgPT09IGV4cG9ydHMuQUNLKSAmJiBoYXNCaW4ob2JqLmRhdGEpKSB7XG4gICAgb2JqLnR5cGUgPSBvYmoudHlwZSA9PT0gZXhwb3J0cy5FVkVOVCA/IGV4cG9ydHMuQklOQVJZX0VWRU5UIDogZXhwb3J0cy5CSU5BUllfQUNLO1xuICB9XG5cbiAgZGVidWcoJ2VuY29kaW5nIHBhY2tldCAlaicsIG9iaik7XG5cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgdmFyIHN0ciA9ICcnICsgb2JqLnR5cGU7XG5cbiAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHMgKyAnLSc7XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICBpZiAob2JqLm5zcCAmJiAnLycgIT09IG9iai5uc3ApIHtcbiAgICBzdHIgKz0gb2JqLm5zcCArICcsJztcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBzdHIgKz0gb2JqLmlkO1xuICB9XG5cbiAgLy8ganNvbiBkYXRhXG4gIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG4gICAgc3RyICs9IEpTT04uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgaSA9IDA7XG4gIC8vIGxvb2sgdXAgdHlwZVxuICB2YXIgcCA9IHtcbiAgICB0eXBlOiBOdW1iZXIoc3RyLmNoYXJBdCgwKSlcbiAgfTtcblxuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHJldHVybiBlcnJvcigpO1xuXG4gIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPT0gJy0nKSB7XG4gICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT09ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09PSBjKSBicmVhaztcbiAgICAgIHAubnNwICs9IGM7XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHAgPSB0cnlQYXJzZShwLCBzdHIuc3Vic3RyKGkpKTtcbiAgfVxuXG4gIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHRyeVBhcnNlKHAsIHN0cikge1xuICB0cnkge1xuICAgIHAuZGF0YSA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZXJyb3IoKTtcbiAgfVxuICByZXR1cm4gcDsgXG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yJ1xuICB9O1xufVxuXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7Ly8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcblxudmFyIGhhc0NPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW1snQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyldKCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuICB9XG59O1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9IG9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygxMikoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcclxuICogUGFyc2VzIGFuIFVSSVxyXG4gKlxyXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xyXG5cclxudmFyIHBhcnRzID0gW1xyXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXHJcbl07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xyXG4gICAgdmFyIHNyYyA9IHN0cixcclxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcclxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcclxuICAgICAgICB1cmkgPSB7fSxcclxuICAgICAgICBpID0gMTQ7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xyXG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXJpO1xyXG59O1xyXG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogZ2xvYmFsIEJsb2IgRmlsZSAqL1xuXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIGdsb2JhbC5CbG9iID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBnbG9iYWwuRmlsZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0cmluZy5jYWxsKGdsb2JhbC5GaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBTdXBwb3J0cyBCdWZmZXIsIEFycmF5QnVmZmVyLCBCbG9iIGFuZCBGaWxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkgKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChoYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgZ2xvYmFsLkJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgaWYgKG9iai50b0pTT04gJiYgdHlwZW9mIG9iai50b0pTT04gPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBoYXNCaW5hcnkob2JqLnRvSlNPTigpLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBoYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gIHJldHVybiAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn1cblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlaW8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcbnZhciBTb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbnZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xudmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xudmFyIEJhY2tvZmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcblxuLyoqXG4gKiBJRTYrIGhhc093blByb3BlcnR5XG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB2YXIgX3BhcnNlciA9IG9wdHMucGFyc2VyIHx8IHBhcnNlcjtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IF9wYXJzZXIuRW5jb2RlcigpO1xuICB0aGlzLmRlY29kZXIgPSBuZXcgX3BhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmdlbmVyYXRlSWQobnNwKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogZ2VuZXJhdGUgYHNvY2tldC5pZGAgZm9yIHRoZSBnaXZlbiBgbnNwYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuc3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmdlbmVyYXRlSWQgPSBmdW5jdGlvbiAobnNwKSB7XG4gIHJldHVybiAobnNwID09PSAnLycgPyAnJyA6IChuc3AgKyAnIycpKSArIHRoaXMuZW5naW5lLmlkO1xufTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuICpcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIHRoaXMuX3RpbWVvdXQgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKGZuLCBvcHRzKSB7XG4gIGRlYnVnKCdyZWFkeVN0YXRlICVzJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuICBkZWJ1Zygnb3BlbmluZyAlcycsIHRoaXMudXJpKTtcbiAgdGhpcy5lbmdpbmUgPSBlaW8odGhpcy51cmksIHRoaXMub3B0cyk7XG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXG4gIC8vIGVtaXQgYG9wZW5gXG4gIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9ub3BlbigpO1xuICAgIGZuICYmIGZuKCk7XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG4gIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkZWJ1ZygnY29ubmVjdF9lcnJvcicpO1xuICAgIHNlbGYuY2xlYW51cCgpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF9lcnJvcicsIGRhdGEpO1xuICAgIGlmIChmbikge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBlcnJvcicpO1xuICAgICAgZXJyLmRhdGEgPSBkYXRhO1xuICAgICAgZm4oZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT25seSBkbyB0aGlzIGlmIHRoZXJlIGlzIG5vIGZuIHRvIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl90aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgd2lsbCB0aW1lb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG5cbiAgICAvLyBzZXQgdGltZXJcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG4gICAgICBvcGVuU3ViLmRlc3Ryb3koKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgJ3RpbWVvdXQnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF90aW1lb3V0JywgdGltZW91dCk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcbiAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdvcGVuJyk7XG5cbiAgLy8gY2xlYXIgb2xkIHN1YnNcbiAgdGhpcy5jbGVhbnVwKCk7XG5cbiAgLy8gbWFyayBhcyBvcGVuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cbiAgLy8gYWRkIG5ldyBzdWJzXG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BpbmcnLCBiaW5kKHRoaXMsICdvbnBpbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwb25nJywgYmluZCh0aGlzLCAnb25wb25nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGluZy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGFzdFBpbmcgPSBuZXcgRGF0ZSgpO1xuICB0aGlzLmVtaXRBbGwoJ3BpbmcnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25wb25nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXRBbGwoJ3BvbmcnLCBuZXcgRGF0ZSgpIC0gdGhpcy5sYXN0UGluZyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uIChuc3AsIG9wdHMpIHtcbiAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICBpZiAoIXNvY2tldCkge1xuICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwLCBvcHRzKTtcbiAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzb2NrZXQuaWQgPSBzZWxmLmdlbmVyYXRlSWQobnNwKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB7XG4gICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldmVudCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG4gICAgICBvbkNvbm5lY3RpbmcoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbm5lY3RpbmcgKCkge1xuICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0aW5nLCBzb2NrZXQpKSB7XG4gICAgICBzZWxmLmNvbm5lY3RpbmcucHVzaChzb2NrZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHNvY2tldCkge1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMuY29ubmVjdGluZywgc29ja2V0KTtcbiAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0aW5nLnNwbGljZShpbmRleCwgMSk7XG4gIGlmICh0aGlzLmNvbm5lY3RpbmcubGVuZ3RoKSByZXR1cm47XG5cbiAgdGhpcy5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBkZWJ1Zygnd3JpdGluZyBwYWNrZXQgJWonLCBwYWNrZXQpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChwYWNrZXQucXVlcnkgJiYgcGFja2V0LnR5cGUgPT09IDApIHBhY2tldC5uc3AgKz0gJz8nICsgcGFja2V0LnF1ZXJ5O1xuXG4gIGlmICghc2VsZi5lbmNvZGluZykge1xuICAgIC8vIGVuY29kZSwgdGhlbiB3cml0ZSB0byBlbmdpbmUgd2l0aCByZXN1bHRcbiAgICBzZWxmLmVuY29kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24gKGVuY29kZWRQYWNrZXRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldLCBwYWNrZXQub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBzZWxmLmVuY29kaW5nID0gZmFsc2U7XG4gICAgICBzZWxmLnByb2Nlc3NQYWNrZXRRdWV1ZSgpO1xuICAgIH0pO1xuICB9IGVsc2UgeyAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuICAgIHNlbGYucGFja2V0QnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBJZiBwYWNrZXQgYnVmZmVyIGlzIG5vbi1lbXB0eSwgYmVnaW5zIGVuY29kaW5nIHRoZVxuICogbmV4dCBwYWNrZXQgaW4gbGluZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhY2tldEJ1ZmZlci5sZW5ndGggPiAwICYmICF0aGlzLmVuY29kaW5nKSB7XG4gICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuICAgIHRoaXMucGFja2V0KHBhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG5cbiAgdmFyIHN1YnNMZW5ndGggPSB0aGlzLnN1YnMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNMZW5ndGg7IGkrKykge1xuICAgIHZhciBzdWIgPSB0aGlzLnN1YnMuc2hpZnQoKTtcbiAgICBzdWIuZGVzdHJveSgpO1xuICB9XG5cbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcblxuICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPVxuTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2Rpc2Nvbm5lY3QnKTtcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gYG9uY2xvc2VgIHdpbGwgbm90IGZpcmUgYmVjYXVzZVxuICAgIC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIGlmICh0aGlzLmVuZ2luZSkgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIGRlYnVnKCdvbmNsb3NlJyk7XG5cbiAgdGhpcy5jbGVhbnVwKCk7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG5cbiAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPj0gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcbiAgICBkZWJ1ZygncmVjb25uZWN0IGZhaWxlZCcpO1xuICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0X2ZhaWxlZCcpO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlbGF5ID0gdGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7XG4gICAgZGVidWcoJ3dpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdCcsIGRlbGF5KTtcblxuICAgIHRoaXMucmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgcmVjb25uZWN0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblxuICAgICAgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIHNlbGYub3BlbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IGF0dGVtcHQgZXJyb3InKTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfZXJyb3InLCBlcnIuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBzdWNjZXNzJyk7XG4gICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBYSFIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcbnZhciBKU09OUCA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xudmFyIHdlYnNvY2tldCA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgcGFyc2VxcyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBpbmhlcml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciB5ZWFzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xudmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIElzIFhIUjIgc3VwcG9ydGVkP1xuICovXG5cbnZhciBoYXNYSFIyID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wb2xsKCk7XG59O1xuXG4vKipcbiAqIFBhdXNlcyBwb2xsaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAob25QYXVzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG4gIGZ1bmN0aW9uIHBhdXNlICgpIHtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGF1c2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgIGlmICgnY2xvc2UnID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJylcbiAgLCBsZW5ndGggPSA2NFxuICAsIG1hcCA9IHt9XG4gICwgc2VlZCA9IDBcbiAgLCBpID0gMFxuICAsIHByZXY7XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShudW0pIHtcbiAgdmFyIGVuY29kZWQgPSAnJztcblxuICBkbyB7XG4gICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcbiAgfSB3aGlsZSAobnVtID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdmFyIGRlY29kZWQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vKipcbiAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZWFzdCgpIHtcbiAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG5cbiAgaWYgKG5vdyAhPT0gcHJldikgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xufVxuXG4vL1xuLy8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cbi8vXG5mb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cbi8vXG55ZWFzdC5lbmNvZGUgPSBlbmNvZGU7XG55ZWFzdC5kZWNvZGUgPSBkZWNvZGU7XG5tb2R1bGUuZXhwb3J0cyA9IHllYXN0O1xuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIHRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcbnZhciBvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbnZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgcGFyc2VxcyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGV2ZW50cyA9IHtcbiAgY29ubmVjdDogMSxcbiAgY29ubmVjdF9lcnJvcjogMSxcbiAgY29ubmVjdF90aW1lb3V0OiAxLFxuICBjb25uZWN0aW5nOiAxLFxuICBkaXNjb25uZWN0OiAxLFxuICBlcnJvcjogMSxcbiAgcmVjb25uZWN0OiAxLFxuICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcbiAgcmVjb25uZWN0X2ZhaWxlZDogMSxcbiAgcmVjb25uZWN0X2Vycm9yOiAxLFxuICByZWNvbm5lY3Rpbmc6IDEsXG4gIHBpbmc6IDEsXG4gIHBvbmc6IDFcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG4gKi9cblxudmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0IChpbywgbnNwLCBvcHRzKSB7XG4gIHRoaXMuaW8gPSBpbztcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuICB0aGlzLmlkcyA9IDA7XG4gIHRoaXMuYWNrcyA9IHt9O1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgaWYgKG9wdHMgJiYgb3B0cy5xdWVyeSkge1xuICAgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB9XG4gIGlmICh0aGlzLmlvLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuICB2YXIgaW8gPSB0aGlzLmlvO1xuICB0aGlzLnN1YnMgPSBbXG4gICAgb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLFxuICAgIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksXG4gICAgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSlcbiAgXTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuc3ViRXZlbnRzKCk7XG4gIHRoaXMuaW8ub3BlbigpOyAvLyBlbnN1cmUgb3BlblxuICBpZiAoJ29wZW4nID09PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgZW1pdGAuXG4gKiBJZiB0aGUgZXZlbnQgaXMgaW4gYGV2ZW50c2AsIGl0J3MgZW1pdHRlZCBub3JtYWxseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldikge1xuICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICB2YXIgcGFja2V0ID0geyB0eXBlOiBwYXJzZXIuRVZFTlQsIGRhdGE6IGFyZ3MgfTtcblxuICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG4gICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxuXG4gIGRlbGV0ZSB0aGlzLmZsYWdzO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT09IHRoaXMubnNwKSB7XG4gICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgIHZhciBxdWVyeSA9IHR5cGVvZiB0aGlzLnF1ZXJ5ID09PSAnb2JqZWN0JyA/IHBhcnNlcXMuZW5jb2RlKHRoaXMucXVlcnkpIDogdGhpcy5xdWVyeTtcbiAgICAgIGRlYnVnKCdzZW5kaW5nIGNvbm5lY3QgcGFja2V0IHdpdGggcXVlcnkgJXMnLCBxdWVyeSk7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1QsIHF1ZXJ5OiBxdWVyeX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1R9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKHBhY2tldC5uc3AgIT09IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHBhcnNlci5BQ0ssXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbn07XG5cbi8qKlxuICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSB7XG4gICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3VicyA9IG51bGw7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG4gIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uIChvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG5cblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxyXG4vLyB0c2xpbnQ6ZGlzYWJsZVxyXG4vKipcclxuICogRGl2ZSBSRVNUIEFQSVxyXG4gKiBEaXZlIHRoaXJkIHBhcnR5IFJFU1QgQVBJIHByb3ZpZGVzIGEgc2V0IG9mIHNlcnZpY2VzIHdoaWNoIGxldmVyYWdlIG9idGFpbmluZyBjYXRhbG9nIGFuZCBUViBncmlkIGluZm8sIGNvbnRleHR1YWwgaXRlbXMgKGNhcmRzKSBpbmZvcm1hdGlvbiBhbmQgc2F2aW5nIGFuZCBhIHN0YXRpYyAoc2NlbmUgYnkgc2NlbmUpIHZlcnNpb24gb2YgdGhlIGNhcmQgY2Fyb3VzZWwgZm9yIGxpbmVhciBUViBhbmQgdmlkZW8gb24gZGVtYW5kXHJcbiAqXHJcbiAqIE9wZW5BUEkgc3BlYyB2ZXJzaW9uOiAxLjAuMFxyXG4gKlxyXG4gKlxyXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IHRoZSBzd2FnZ2VyIGNvZGUgZ2VuZXJhdG9yIHByb2dyYW0uXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2FnZ2VyLWFwaS9zd2FnZ2VyLWNvZGVnZW4uZ2l0XHJcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cclxuICovXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBxdWVyeXN0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XHJcbnZhciBmZXRjaF9pc28gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcclxudmFyIGlvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcclxudmFyIEJBU0VfUEFUSCA9IFwiaHR0cHM6Ly9yZXN0LmRpdmUudHYvdjFcIi5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xyXG52YXIgQmFzZUFQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhc2VBUEkoYmFzZVBhdGgsIGZldGNoKSB7XHJcbiAgICAgICAgaWYgKGJhc2VQYXRoID09PSB2b2lkIDApIHsgYmFzZVBhdGggPSBCQVNFX1BBVEg7IH1cclxuICAgICAgICBpZiAoZmV0Y2ggPT09IHZvaWQgMCkgeyBmZXRjaCA9IGZldGNoX2lzbzsgfVxyXG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aDtcclxuICAgICAgICB0aGlzLmZldGNoID0gZmV0Y2g7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQmFzZUFQSTtcclxufSgpKTtcclxuZXhwb3J0cy5CYXNlQVBJID0gQmFzZUFQSTtcclxuLyoqXHJcbiogRGVmYXVsdEFwaSAtIGZldGNoIHBhcmFtZXRlciBjcmVhdG9yXHJcbiovXHJcbmV4cG9ydHMuRGVmYXVsdEFwaUZldGNoUGFyYW1DcmVhdG9yID0ge1xyXG4gICAgLyoqXHJcbiAgICAqIERlbGV0ZSBjYXJkIGxpa2VcclxuICAgICogUmVtb3ZlcyBhIGNhcmQgZnJvbSBjdXJyZW50IHVzZXImIzM5O3MgbGlrZXMgbGlzdFxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjYXJkSWQgUmVxdWVzdGVkIGNhcmQgSURcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICovXHJcbiAgICBkZWxldGVMaWtlczogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJhdXRob3JpemF0aW9uXCIgaXMgc2V0XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBhdXRob3JpemF0aW9uIHdoZW4gY2FsbGluZyBkZWxldGVMaWtlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciBcImNhcmRJZFwiIGlzIHNldFxyXG4gICAgICAgIGlmIChwYXJhbXNbXCJjYXJkSWRcIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBjYXJkSWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUxpa2VzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmFzZVVybCA9IFwiL2xpa2VzL3tjYXJkX2lkfVwiXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKFwie1wiICsgXCJjYXJkX2lkXCIgKyBcIn1cIiwgXCJcIiArIHBhcmFtc1tcImNhcmRJZFwiXSk7XHJcbiAgICAgICAgdmFyIHVybE9iaiA9IHVybC5wYXJzZShiYXNlVXJsLCB0cnVlKTtcclxuICAgICAgICB2YXIgZmV0Y2hPcHRpb25zID0gYXNzaWduKHt9LCB7IG1ldGhvZDogXCJERUxFVEVcIiB9LCBvcHRpb25zKTtcclxuICAgICAgICB2YXIgY29udGVudFR5cGVIZWFkZXIgPSB7fTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycy5hcHBlbmQoXCJBY2NlcHQtTGFuZ3VhZ2VcIiwgcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0pO2ZldGNoT3B0aW9ucy5oZWFkZXJzLmFwcGVuZChcIkF1dGhvcml6YXRpb25cIiwgcGFyYW1zW1wiYXV0aG9yaXphdGlvblwiXSk7XHJcbiAgICAgICAgKi9cclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IGFzc2lnbih7XHJcbiAgICAgICAgICAgIFwiQWNjZXB0LUxhbmd1YWdlXCI6IHBhcmFtc1tcImFjY2VwdExhbmd1YWdlXCJdLCBcIkF1dGhvcml6YXRpb25cIjogcGFyYW1zW1wiYXV0aG9yaXphdGlvblwiXSxcclxuICAgICAgICB9LCBjb250ZW50VHlwZUhlYWRlcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXJsOiB1cmwuZm9ybWF0KHVybE9iaiksXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IGZldGNoT3B0aW9ucyxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgKiBGdWxsIGNhcmQgZGV0YWlsXHJcbiAgICAqIFJldHJpZXZlcyBhIGZ1bGwgY2FyZCBkZXRhaWwsIHdpdGggbm8gcmVsYXRpb25zIG9yIGNvbnRleHRcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2FyZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGNhcmRcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICogQHBhcmFtIHByb2R1Y3RzIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiBjb21tZXJjaWFsIHByb2R1Y3RzIHdoZW4gYXZhaWxhYmxlICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgKiBAcGFyYW0gdXNlckRhdGEgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIHVzZXIgZGF0YSB3aGVuIGF2YWlsYWJsZSAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuICAgICogQHBhcmFtIGltYWdlU2l6ZSBTaXplIG9mIHRoZSBpbWFnZXMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAqL1xyXG4gICAgZ2V0Q2FyZDogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJhdXRob3JpemF0aW9uXCIgaXMgc2V0XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBhdXRob3JpemF0aW9uIHdoZW4gY2FsbGluZyBnZXRDYXJkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyIFwiY2FyZElkXCIgaXMgc2V0XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImNhcmRJZFwiXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGNhcmRJZCB3aGVuIGNhbGxpbmcgZ2V0Q2FyZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBcIi9jYXJkcy97Y2FyZF9pZH1cIlxyXG4gICAgICAgICAgICAucmVwbGFjZShcIntcIiArIFwiY2FyZF9pZFwiICsgXCJ9XCIsIFwiXCIgKyBwYXJhbXNbXCJjYXJkSWRcIl0pO1xyXG4gICAgICAgIHZhciB1cmxPYmogPSB1cmwucGFyc2UoYmFzZVVybCwgdHJ1ZSk7XHJcbiAgICAgICAgdXJsT2JqLnF1ZXJ5ID0gYXNzaWduKHt9LCB1cmxPYmoucXVlcnksIHtcclxuICAgICAgICAgICAgXCJwcm9kdWN0c1wiOiBwYXJhbXNbXCJwcm9kdWN0c1wiXSxcclxuICAgICAgICAgICAgXCJ1c2VyX2RhdGFcIjogcGFyYW1zW1widXNlckRhdGFcIl0sXHJcbiAgICAgICAgICAgIFwiaW1hZ2Vfc2l6ZVwiOiBwYXJhbXNbXCJpbWFnZVNpemVcIl0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGZldGNoT3B0aW9ucyA9IGFzc2lnbih7fSwgeyBtZXRob2Q6IFwiR0VUXCIgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGVhZGVyID0ge307XHJcbiAgICAgICAgLypcclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdKTtmZXRjaE9wdGlvbnMuaGVhZGVycy5hcHBlbmQoXCJBY2NlcHQtTGFuZ3VhZ2VcIiwgcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0pO1xyXG4gICAgICAgICovXHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBhc3NpZ24oe1xyXG4gICAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogcGFyYW1zW1wiYXV0aG9yaXphdGlvblwiXSwgXCJBY2NlcHQtTGFuZ3VhZ2VcIjogcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0sXHJcbiAgICAgICAgfSwgY29udGVudFR5cGVIZWFkZXIpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVybDogdXJsLmZvcm1hdCh1cmxPYmopLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBmZXRjaE9wdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogRnVsbCBjYXJkIGRldGFpbCB3aXRoIHZlcnNpb25cclxuICAgICogUmV0cmlldmVzIGEgZnVsbCBjYXJkIGRldGFpbCwgYW5kIGl0cyByZWxhdGlvbnMgdG8gb3RoZXIgY2FyZHMgaW4gYSBnaXZlbiBjb250ZXh0IChjYXJkIHZlcnNpb24pXHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNhcmRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBjYXJkXHJcbiAgICAqIEBwYXJhbSB2ZXJzaW9uIFZlcnNpb24gaWRlbnRpZmllciwgaW5kaWNhdGVzIHRoZSBjb250ZXh0IHdoZXJlIHRoZSBjYXJkIGlzIGJlaW5nIHJlcXVlc3RlZFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKiBAcGFyYW0gcHJvZHVjdHMgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIGNvbW1lcmNpYWwgcHJvZHVjdHMgd2hlbiBhdmFpbGFibGUgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAqIEBwYXJhbSB1c2VyRGF0YSBJbmRpY2F0ZXMgaWYgY2FyZHMgc2hvdWxkIGNvbnRhaW4gdXNlciBkYXRhIHdoZW4gYXZhaWxhYmxlICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgKiBAcGFyYW0gcmVsYXRpb25zIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiB0aGUgc2NlbmUgaGllcmFyY2h5ICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICovXHJcbiAgICBnZXRDYXJkVmVyc2lvbjogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJhdXRob3JpemF0aW9uXCIgaXMgc2V0XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBhdXRob3JpemF0aW9uIHdoZW4gY2FsbGluZyBnZXRDYXJkVmVyc2lvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciBcImNhcmRJZFwiIGlzIHNldFxyXG4gICAgICAgIGlmIChwYXJhbXNbXCJjYXJkSWRcIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBjYXJkSWQgd2hlbiBjYWxsaW5nIGdldENhcmRWZXJzaW9uXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyIFwidmVyc2lvblwiIGlzIHNldFxyXG4gICAgICAgIGlmIChwYXJhbXNbXCJ2ZXJzaW9uXCJdID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgdmVyc2lvbiB3aGVuIGNhbGxpbmcgZ2V0Q2FyZFZlcnNpb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXNlVXJsID0gXCIvY2FyZHMve2NhcmRfaWR9L3ZlcnNpb25zL3t2ZXJzaW9ufVwiXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKFwie1wiICsgXCJjYXJkX2lkXCIgKyBcIn1cIiwgXCJcIiArIHBhcmFtc1tcImNhcmRJZFwiXSlcclxuICAgICAgICAgICAgLnJlcGxhY2UoXCJ7XCIgKyBcInZlcnNpb25cIiArIFwifVwiLCBcIlwiICsgcGFyYW1zW1widmVyc2lvblwiXSk7XHJcbiAgICAgICAgdmFyIHVybE9iaiA9IHVybC5wYXJzZShiYXNlVXJsLCB0cnVlKTtcclxuICAgICAgICB1cmxPYmoucXVlcnkgPSBhc3NpZ24oe30sIHVybE9iai5xdWVyeSwge1xyXG4gICAgICAgICAgICBcInByb2R1Y3RzXCI6IHBhcmFtc1tcInByb2R1Y3RzXCJdLFxyXG4gICAgICAgICAgICBcInVzZXJfZGF0YVwiOiBwYXJhbXNbXCJ1c2VyRGF0YVwiXSxcclxuICAgICAgICAgICAgXCJyZWxhdGlvbnNcIjogcGFyYW1zW1wicmVsYXRpb25zXCJdLFxyXG4gICAgICAgICAgICBcImltYWdlX3NpemVcIjogcGFyYW1zW1wiaW1hZ2VTaXplXCJdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBmZXRjaE9wdGlvbnMgPSBhc3NpZ24oe30sIHsgbWV0aG9kOiBcIkdFVFwiIH0sIG9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBjb250ZW50VHlwZUhlYWRlciA9IHt9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xyXG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLmFwcGVuZChcIkF1dGhvcml6YXRpb25cIiwgcGFyYW1zW1wiYXV0aG9yaXphdGlvblwiXSk7ZmV0Y2hPcHRpb25zLmhlYWRlcnMuYXBwZW5kKFwiQWNjZXB0LUxhbmd1YWdlXCIsIHBhcmFtc1tcImFjY2VwdExhbmd1YWdlXCJdKTtcclxuICAgICAgICAqL1xyXG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0gYXNzaWduKHtcclxuICAgICAgICAgICAgXCJBdXRob3JpemF0aW9uXCI6IHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0sIFwiQWNjZXB0LUxhbmd1YWdlXCI6IHBhcmFtc1tcImFjY2VwdExhbmd1YWdlXCJdLFxyXG4gICAgICAgIH0sIGNvbnRlbnRUeXBlSGVhZGVyKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1cmw6IHVybC5mb3JtYXQodXJsT2JqKSxcclxuICAgICAgICAgICAgb3B0aW9uczogZmV0Y2hPcHRpb25zLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAqIE1vdmllIGNhdGFsb2cgaW5mb1xyXG4gICAgKiBSZXRyaWV2ZXMgYSBtb3ZpZSYjMzk7cyBmdWxsIGNhcmQgYnkgaXRzIGNsaWVudCBJRCwgaW5jbHVkaW5nIGNhdGFsb2cgYW5kIGNhc3QgaW5mb3JtYXRpb25cclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2xpZW50TW92aWVJZCBDbGllbnQgbW92aWUgSUQgYmVpbmcgcGxheWVkXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIGdldENhdGFsb2dNb3ZpZTogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJhdXRob3JpemF0aW9uXCIgaXMgc2V0XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBhdXRob3JpemF0aW9uIHdoZW4gY2FsbGluZyBnZXRDYXRhbG9nTW92aWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJjbGllbnRNb3ZpZUlkXCIgaXMgc2V0XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImNsaWVudE1vdmllSWRcIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBjbGllbnRNb3ZpZUlkIHdoZW4gY2FsbGluZyBnZXRDYXRhbG9nTW92aWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXNlVXJsID0gXCIvbW92aWVzL3tjbGllbnRfbW92aWVfaWR9XCJcclxuICAgICAgICAgICAgLnJlcGxhY2UoXCJ7XCIgKyBcImNsaWVudF9tb3ZpZV9pZFwiICsgXCJ9XCIsIFwiXCIgKyBwYXJhbXNbXCJjbGllbnRNb3ZpZUlkXCJdKTtcclxuICAgICAgICB2YXIgdXJsT2JqID0gdXJsLnBhcnNlKGJhc2VVcmwsIHRydWUpO1xyXG4gICAgICAgIHVybE9iai5xdWVyeSA9IGFzc2lnbih7fSwgdXJsT2JqLnF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIFwiaW1hZ2Vfc2l6ZVwiOiBwYXJhbXNbXCJpbWFnZVNpemVcIl0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGZldGNoT3B0aW9ucyA9IGFzc2lnbih7fSwgeyBtZXRob2Q6IFwiR0VUXCIgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGVhZGVyID0ge307XHJcbiAgICAgICAgLypcclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdKTtmZXRjaE9wdGlvbnMuaGVhZGVycy5hcHBlbmQoXCJBY2NlcHQtTGFuZ3VhZ2VcIiwgcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0pO1xyXG4gICAgICAgICovXHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBhc3NpZ24oe1xyXG4gICAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogcGFyYW1zW1wiYXV0aG9yaXphdGlvblwiXSwgXCJBY2NlcHQtTGFuZ3VhZ2VcIjogcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0sXHJcbiAgICAgICAgfSwgY29udGVudFR5cGVIZWFkZXIpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVybDogdXJsLmZvcm1hdCh1cmxPYmopLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBmZXRjaE9wdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogQ2hhbm5lbCBldmVudHMgZ3JpZFxyXG4gICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGFuZCB1cGNvbWluZyBncmlkIG9mIFRWIGV2ZW50cyBmb3IgdGhlIGdpdmVuIGNoYW5uZWxcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2hhbm5lbElkIENsaWVudCBjaGFubmVsIElEXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIGdldENoYW5uZWxHcmlkOiBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciBcImF1dGhvcml6YXRpb25cIiBpcyBzZXRcclxuICAgICAgICBpZiAocGFyYW1zW1wiYXV0aG9yaXphdGlvblwiXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGF1dGhvcml6YXRpb24gd2hlbiBjYWxsaW5nIGdldENoYW5uZWxHcmlkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyIFwiY2hhbm5lbElkXCIgaXMgc2V0XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImNoYW5uZWxJZFwiXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGNoYW5uZWxJZCB3aGVuIGNhbGxpbmcgZ2V0Q2hhbm5lbEdyaWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXNlVXJsID0gXCIvY2hhbm5lbHMve2NoYW5uZWxfaWR9L2dyaWRcIlxyXG4gICAgICAgICAgICAucmVwbGFjZShcIntcIiArIFwiY2hhbm5lbF9pZFwiICsgXCJ9XCIsIFwiXCIgKyBwYXJhbXNbXCJjaGFubmVsSWRcIl0pO1xyXG4gICAgICAgIHZhciB1cmxPYmogPSB1cmwucGFyc2UoYmFzZVVybCwgdHJ1ZSk7XHJcbiAgICAgICAgdXJsT2JqLnF1ZXJ5ID0gYXNzaWduKHt9LCB1cmxPYmoucXVlcnksIHtcclxuICAgICAgICAgICAgXCJpbWFnZV9zaXplXCI6IHBhcmFtc1tcImltYWdlU2l6ZVwiXSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgZmV0Y2hPcHRpb25zID0gYXNzaWduKHt9LCB7IG1ldGhvZDogXCJHRVRcIiB9LCBvcHRpb25zKTtcclxuICAgICAgICB2YXIgY29udGVudFR5cGVIZWFkZXIgPSB7fTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycy5hcHBlbmQoXCJBdXRob3JpemF0aW9uXCIsIHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0pO2ZldGNoT3B0aW9ucy5oZWFkZXJzLmFwcGVuZChcIkFjY2VwdC1MYW5ndWFnZVwiLCBwYXJhbXNbXCJhY2NlcHRMYW5ndWFnZVwiXSk7XHJcbiAgICAgICAgKi9cclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IGFzc2lnbih7XHJcbiAgICAgICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdLCBcIkFjY2VwdC1MYW5ndWFnZVwiOiBwYXJhbXNbXCJhY2NlcHRMYW5ndWFnZVwiXSxcclxuICAgICAgICB9LCBjb250ZW50VHlwZUhlYWRlcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXJsOiB1cmwuZm9ybWF0KHVybE9iaiksXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IGZldGNoT3B0aW9ucyxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgKiBDaGFubmVsIG1vdmllIGNhdGFsb2cgaW5mb1xyXG4gICAgKiBSZXRyaWV2ZXMgZnVsbCBjYXJkIGRldGFpbCwgaW5jbHVkaW5nIGNhdGFsb2cgYW5kIGNhc3QgaW5mb3JtYXRpb24sIGZvciB0aGUgY29udGVudCBjdXJyZW50bHkgYmVpbmcgYnJvYWRjYXN0ZWQgb24gdGhlIGNoYW5uZWxcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2hhbm5lbElkIENsaWVudCBjaGFubmVsIElEXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIGdldENoYW5uZWxNb3ZpZTogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJhdXRob3JpemF0aW9uXCIgaXMgc2V0XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBhdXRob3JpemF0aW9uIHdoZW4gY2FsbGluZyBnZXRDaGFubmVsTW92aWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJjaGFubmVsSWRcIiBpcyBzZXRcclxuICAgICAgICBpZiAocGFyYW1zW1wiY2hhbm5lbElkXCJdID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgY2hhbm5lbElkIHdoZW4gY2FsbGluZyBnZXRDaGFubmVsTW92aWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXNlVXJsID0gXCIvY2hhbm5lbHMve2NoYW5uZWxfaWR9XCJcclxuICAgICAgICAgICAgLnJlcGxhY2UoXCJ7XCIgKyBcImNoYW5uZWxfaWRcIiArIFwifVwiLCBcIlwiICsgcGFyYW1zW1wiY2hhbm5lbElkXCJdKTtcclxuICAgICAgICB2YXIgdXJsT2JqID0gdXJsLnBhcnNlKGJhc2VVcmwsIHRydWUpO1xyXG4gICAgICAgIHVybE9iai5xdWVyeSA9IGFzc2lnbih7fSwgdXJsT2JqLnF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIFwiaW1hZ2Vfc2l6ZVwiOiBwYXJhbXNbXCJpbWFnZVNpemVcIl0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGZldGNoT3B0aW9ucyA9IGFzc2lnbih7fSwgeyBtZXRob2Q6IFwiR0VUXCIgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGVhZGVyID0ge307XHJcbiAgICAgICAgLypcclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdKTtmZXRjaE9wdGlvbnMuaGVhZGVycy5hcHBlbmQoXCJBY2NlcHQtTGFuZ3VhZ2VcIiwgcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0pO1xyXG4gICAgICAgICovXHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBhc3NpZ24oe1xyXG4gICAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogcGFyYW1zW1wiYXV0aG9yaXphdGlvblwiXSwgXCJBY2NlcHQtTGFuZ3VhZ2VcIjogcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0sXHJcbiAgICAgICAgfSwgY29udGVudFR5cGVIZWFkZXIpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVybDogdXJsLmZvcm1hdCh1cmxPYmopLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBmZXRjaE9wdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogR2V0IGNhcmQgbGlrZXNcclxuICAgICogUmV0dXJucyBhIHBhZ2luYXRlZCBsaXN0IG9mIGNhcmRzIGxpa2VkIGJ5IGN1cnJlbnQgdXNlclxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKiBAcGFyYW0gcGFnaW5hdGVLZXkgUGFnaW5hdGUga2V5XHJcbiAgICAqIEBwYXJhbSBzaXplIE51bWJlciBvZiBkZXNpcmVkIHJlc3VsdHNcclxuICAgICovXHJcbiAgICBnZXRMaWtlczogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJhdXRob3JpemF0aW9uXCIgaXMgc2V0XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBhdXRob3JpemF0aW9uIHdoZW4gY2FsbGluZyBnZXRMaWtlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBcIi9saWtlc1wiO1xyXG4gICAgICAgIHZhciB1cmxPYmogPSB1cmwucGFyc2UoYmFzZVVybCwgdHJ1ZSk7XHJcbiAgICAgICAgdXJsT2JqLnF1ZXJ5ID0gYXNzaWduKHt9LCB1cmxPYmoucXVlcnksIHtcclxuICAgICAgICAgICAgXCJpbWFnZV9zaXplXCI6IHBhcmFtc1tcImltYWdlU2l6ZVwiXSxcclxuICAgICAgICAgICAgXCJwYWdpbmF0ZV9rZXlcIjogcGFyYW1zW1wicGFnaW5hdGVLZXlcIl0sXHJcbiAgICAgICAgICAgIFwic2l6ZVwiOiBwYXJhbXNbXCJzaXplXCJdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBmZXRjaE9wdGlvbnMgPSBhc3NpZ24oe30sIHsgbWV0aG9kOiBcIkdFVFwiIH0sIG9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBjb250ZW50VHlwZUhlYWRlciA9IHt9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xyXG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLmFwcGVuZChcIkFjY2VwdC1MYW5ndWFnZVwiLCBwYXJhbXNbXCJhY2NlcHRMYW5ndWFnZVwiXSk7ZmV0Y2hPcHRpb25zLmhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdKTtcclxuICAgICAgICAqL1xyXG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0gYXNzaWduKHtcclxuICAgICAgICAgICAgXCJBY2NlcHQtTGFuZ3VhZ2VcIjogcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0sIFwiQXV0aG9yaXphdGlvblwiOiBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdLFxyXG4gICAgICAgIH0sIGNvbnRlbnRUeXBlSGVhZGVyKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1cmw6IHVybC5mb3JtYXQodXJsT2JqKSxcclxuICAgICAgICAgICAgb3B0aW9uczogZmV0Y2hPcHRpb25zLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAqIENoYW5uZWwgc3luYyBhdmFpbGFiaWxpdHlcclxuICAgICogQ2hlY2tzIGlmIGEgbGlzdCBvZiBjbGllbnQgY2hhbm5lbCBpZGVudGlmaWVycyBhcmUgY3VycmVudGx5IGJyb2FkY2FzdGluZyBzeW5jaHJvbml6YWJsZSBjb250ZW50XHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNoYW5uZWxJZExpc3QgTGlzdCBvZiBjbGllbnQgY2hhbm5lbCBJRHMgYXMgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKi9cclxuICAgIGdldFJlYWR5Q2hhbm5lbHM6IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyIFwiYXV0aG9yaXphdGlvblwiIGlzIHNldFxyXG4gICAgICAgIGlmIChwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgYXV0aG9yaXphdGlvbiB3aGVuIGNhbGxpbmcgZ2V0UmVhZHlDaGFubmVsc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciBcImNoYW5uZWxJZExpc3RcIiBpcyBzZXRcclxuICAgICAgICBpZiAocGFyYW1zW1wiY2hhbm5lbElkTGlzdFwiXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGNoYW5uZWxJZExpc3Qgd2hlbiBjYWxsaW5nIGdldFJlYWR5Q2hhbm5lbHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXNlVXJsID0gXCIvY2hhbm5lbHMve2NoYW5uZWxfaWRfbGlzdH0vcmVhZHlcIlxyXG4gICAgICAgICAgICAucmVwbGFjZShcIntcIiArIFwiY2hhbm5lbF9pZF9saXN0XCIgKyBcIn1cIiwgXCJcIiArIHBhcmFtc1tcImNoYW5uZWxJZExpc3RcIl0pO1xyXG4gICAgICAgIHZhciB1cmxPYmogPSB1cmwucGFyc2UoYmFzZVVybCwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGZldGNoT3B0aW9ucyA9IGFzc2lnbih7fSwgeyBtZXRob2Q6IFwiR0VUXCIgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGVhZGVyID0ge307XHJcbiAgICAgICAgLypcclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdKTtmZXRjaE9wdGlvbnMuaGVhZGVycy5hcHBlbmQoXCJBY2NlcHQtTGFuZ3VhZ2VcIiwgcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0pO1xyXG4gICAgICAgICovXHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBhc3NpZ24oe1xyXG4gICAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogcGFyYW1zW1wiYXV0aG9yaXphdGlvblwiXSwgXCJBY2NlcHQtTGFuZ3VhZ2VcIjogcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0sXHJcbiAgICAgICAgfSwgY29udGVudFR5cGVIZWFkZXIpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVybDogdXJsLmZvcm1hdCh1cmxPYmopLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBmZXRjaE9wdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogTW92aWUgc3luYyBhdmFpbGFiaWxpdHlcclxuICAgICogQ2hlY2tzIHdoZXRoZXIgYSBsaXN0IG9mIGNsaWVudCBtb3ZpZSBpZGVudGlmaWVycyAoVmlkZW8gT24gRGVtYW5kKSBhcmUgYXZhaWxhYmxlIHRvIGJlIHN5bmNocm9uaXplZCB1c2luZyB0aGUgRGl2ZSBBUElcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2xpZW50TW92aWVJZExpc3QgTGlzdCBvZiBjbGllbnQgbW92aWUgSURzLCBwcm92aWRlZCBhcyBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0XHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqL1xyXG4gICAgZ2V0UmVhZHlNb3ZpZXM6IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyIFwiYXV0aG9yaXphdGlvblwiIGlzIHNldFxyXG4gICAgICAgIGlmIChwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgYXV0aG9yaXphdGlvbiB3aGVuIGNhbGxpbmcgZ2V0UmVhZHlNb3ZpZXNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJjbGllbnRNb3ZpZUlkTGlzdFwiIGlzIHNldFxyXG4gICAgICAgIGlmIChwYXJhbXNbXCJjbGllbnRNb3ZpZUlkTGlzdFwiXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGNsaWVudE1vdmllSWRMaXN0IHdoZW4gY2FsbGluZyBnZXRSZWFkeU1vdmllc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBcIi9tb3ZpZXMve2NsaWVudF9tb3ZpZV9pZF9saXN0fS9yZWFkeVwiXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKFwie1wiICsgXCJjbGllbnRfbW92aWVfaWRfbGlzdFwiICsgXCJ9XCIsIFwiXCIgKyBwYXJhbXNbXCJjbGllbnRNb3ZpZUlkTGlzdFwiXSk7XHJcbiAgICAgICAgdmFyIHVybE9iaiA9IHVybC5wYXJzZShiYXNlVXJsLCB0cnVlKTtcclxuICAgICAgICB2YXIgZmV0Y2hPcHRpb25zID0gYXNzaWduKHt9LCB7IG1ldGhvZDogXCJHRVRcIiB9LCBvcHRpb25zKTtcclxuICAgICAgICB2YXIgY29udGVudFR5cGVIZWFkZXIgPSB7fTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycy5hcHBlbmQoXCJBdXRob3JpemF0aW9uXCIsIHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0pO2ZldGNoT3B0aW9ucy5oZWFkZXJzLmFwcGVuZChcIkFjY2VwdC1MYW5ndWFnZVwiLCBwYXJhbXNbXCJhY2NlcHRMYW5ndWFnZVwiXSk7XHJcbiAgICAgICAgKi9cclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IGFzc2lnbih7XHJcbiAgICAgICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdLCBcIkFjY2VwdC1MYW5ndWFnZVwiOiBwYXJhbXNbXCJhY2NlcHRMYW5ndWFnZVwiXSxcclxuICAgICAgICB9LCBjb250ZW50VHlwZUhlYWRlcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXJsOiB1cmwuZm9ybWF0KHVybE9iaiksXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IGZldGNoT3B0aW9ucyxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgKiBTdGF0aWMgY2hhbm5lbCBzY2VuZVxyXG4gICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgY2FyZHMgcmVsYXRlZCB0byB0aGUgY29udGVudCBjdXJyZW50bHkgYmVpbmcgYnJvYWRjYXN0ZWQgaW4gdGhlIHByb3ZpZGVkIGNoYW5uZWxcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2hhbm5lbElkIENsaWVudCBjaGFubmVsIElEXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSByZWxhdGlvbnMgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIHRoZSBzY2VuZSBoaWVyYXJjaHkgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIGdldFN0YXRpY0NoYW5uZWxTY2VuZTogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJhdXRob3JpemF0aW9uXCIgaXMgc2V0XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBhdXRob3JpemF0aW9uIHdoZW4gY2FsbGluZyBnZXRTdGF0aWNDaGFubmVsU2NlbmVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJjaGFubmVsSWRcIiBpcyBzZXRcclxuICAgICAgICBpZiAocGFyYW1zW1wiY2hhbm5lbElkXCJdID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgY2hhbm5lbElkIHdoZW4gY2FsbGluZyBnZXRTdGF0aWNDaGFubmVsU2NlbmVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXNlVXJsID0gXCIvY2hhbm5lbHMve2NoYW5uZWxfaWR9L3N0YXRpY1wiXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKFwie1wiICsgXCJjaGFubmVsX2lkXCIgKyBcIn1cIiwgXCJcIiArIHBhcmFtc1tcImNoYW5uZWxJZFwiXSk7XHJcbiAgICAgICAgdmFyIHVybE9iaiA9IHVybC5wYXJzZShiYXNlVXJsLCB0cnVlKTtcclxuICAgICAgICB1cmxPYmoucXVlcnkgPSBhc3NpZ24oe30sIHVybE9iai5xdWVyeSwge1xyXG4gICAgICAgICAgICBcInJlbGF0aW9uc1wiOiBwYXJhbXNbXCJyZWxhdGlvbnNcIl0sXHJcbiAgICAgICAgICAgIFwiaW1hZ2Vfc2l6ZVwiOiBwYXJhbXNbXCJpbWFnZVNpemVcIl0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGZldGNoT3B0aW9ucyA9IGFzc2lnbih7fSwgeyBtZXRob2Q6IFwiR0VUXCIgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGVhZGVyID0ge307XHJcbiAgICAgICAgLypcclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdKTtmZXRjaE9wdGlvbnMuaGVhZGVycy5hcHBlbmQoXCJBY2NlcHQtTGFuZ3VhZ2VcIiwgcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0pO1xyXG4gICAgICAgICovXHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBhc3NpZ24oe1xyXG4gICAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogcGFyYW1zW1wiYXV0aG9yaXphdGlvblwiXSwgXCJBY2NlcHQtTGFuZ3VhZ2VcIjogcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0sXHJcbiAgICAgICAgfSwgY29udGVudFR5cGVIZWFkZXIpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVybDogdXJsLmZvcm1hdCh1cmxPYmopLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBmZXRjaE9wdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogU3RhdGljIFZPRCBzY2VuZVxyXG4gICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgbGlzdCBvZiBjYXJkcyByZWxhdGVkIHRvIHRoZSBnaXZlbiBtb3ZpZSBzY2VuZVxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjbGllbnRNb3ZpZUlkIENsaWVudCBtb3ZpZSBJRCBiZWluZyBwbGF5ZWRcclxuICAgICogQHBhcmFtIHRpbWVzdGFtcCBDdXJyZW50IG1vdmllIHRpbWVzdGFtcCBpbiBzZWNvbmRzXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSByZWxhdGlvbnMgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIHRoZSBzY2VuZSBoaWVyYXJjaHkgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIGdldFN0YXRpY01vdmllU2NlbmU6IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyIFwiYXV0aG9yaXphdGlvblwiIGlzIHNldFxyXG4gICAgICAgIGlmIChwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgYXV0aG9yaXphdGlvbiB3aGVuIGNhbGxpbmcgZ2V0U3RhdGljTW92aWVTY2VuZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciBcImNsaWVudE1vdmllSWRcIiBpcyBzZXRcclxuICAgICAgICBpZiAocGFyYW1zW1wiY2xpZW50TW92aWVJZFwiXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGNsaWVudE1vdmllSWQgd2hlbiBjYWxsaW5nIGdldFN0YXRpY01vdmllU2NlbmVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgXCJ0aW1lc3RhbXBcIiBpcyBzZXRcclxuICAgICAgICBpZiAocGFyYW1zW1widGltZXN0YW1wXCJdID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgdGltZXN0YW1wIHdoZW4gY2FsbGluZyBnZXRTdGF0aWNNb3ZpZVNjZW5lXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmFzZVVybCA9IFwiL21vdmllcy97Y2xpZW50X21vdmllX2lkfS9zdGF0aWMve3RpbWVzdGFtcH1cIlxyXG4gICAgICAgICAgICAucmVwbGFjZShcIntcIiArIFwiY2xpZW50X21vdmllX2lkXCIgKyBcIn1cIiwgXCJcIiArIHBhcmFtc1tcImNsaWVudE1vdmllSWRcIl0pXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKFwie1wiICsgXCJ0aW1lc3RhbXBcIiArIFwifVwiLCBcIlwiICsgcGFyYW1zW1widGltZXN0YW1wXCJdKTtcclxuICAgICAgICB2YXIgdXJsT2JqID0gdXJsLnBhcnNlKGJhc2VVcmwsIHRydWUpO1xyXG4gICAgICAgIHVybE9iai5xdWVyeSA9IGFzc2lnbih7fSwgdXJsT2JqLnF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIFwicmVsYXRpb25zXCI6IHBhcmFtc1tcInJlbGF0aW9uc1wiXSxcclxuICAgICAgICAgICAgXCJpbWFnZV9zaXplXCI6IHBhcmFtc1tcImltYWdlU2l6ZVwiXSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgZmV0Y2hPcHRpb25zID0gYXNzaWduKHt9LCB7IG1ldGhvZDogXCJHRVRcIiB9LCBvcHRpb25zKTtcclxuICAgICAgICB2YXIgY29udGVudFR5cGVIZWFkZXIgPSB7fTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycy5hcHBlbmQoXCJBdXRob3JpemF0aW9uXCIsIHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0pO2ZldGNoT3B0aW9ucy5oZWFkZXJzLmFwcGVuZChcIkFjY2VwdC1MYW5ndWFnZVwiLCBwYXJhbXNbXCJhY2NlcHRMYW5ndWFnZVwiXSk7XHJcbiAgICAgICAgKi9cclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IGFzc2lnbih7XHJcbiAgICAgICAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdLCBcIkFjY2VwdC1MYW5ndWFnZVwiOiBwYXJhbXNbXCJhY2NlcHRMYW5ndWFnZVwiXSxcclxuICAgICAgICB9LCBjb250ZW50VHlwZUhlYWRlcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXJsOiB1cmwuZm9ybWF0KHVybE9iaiksXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IGZldGNoT3B0aW9ucyxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgKiBBZGQgY2FyZCBsaWtlXHJcbiAgICAqIFN0b3JlcyBhIGNhcmQgdW5kZXIgY3VycmVudCB1c2VyJiMzOTtzIGxpa2VzIGxpc3RcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2FyZElkIFJlcXVlc3RlZCBjYXJkIElEXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqL1xyXG4gICAgcG9zdExpa2VzOiBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciBcImF1dGhvcml6YXRpb25cIiBpcyBzZXRcclxuICAgICAgICBpZiAocGFyYW1zW1wiYXV0aG9yaXphdGlvblwiXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGF1dGhvcml6YXRpb24gd2hlbiBjYWxsaW5nIHBvc3RMaWtlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciBcImNhcmRJZFwiIGlzIHNldFxyXG4gICAgICAgIGlmIChwYXJhbXNbXCJjYXJkSWRcIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBjYXJkSWQgd2hlbiBjYWxsaW5nIHBvc3RMaWtlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBcIi9saWtlcy97Y2FyZF9pZH1cIlxyXG4gICAgICAgICAgICAucmVwbGFjZShcIntcIiArIFwiY2FyZF9pZFwiICsgXCJ9XCIsIFwiXCIgKyBwYXJhbXNbXCJjYXJkSWRcIl0pO1xyXG4gICAgICAgIHZhciB1cmxPYmogPSB1cmwucGFyc2UoYmFzZVVybCwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGZldGNoT3B0aW9ucyA9IGFzc2lnbih7fSwgeyBtZXRob2Q6IFwiUE9TVFwiIH0sIG9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBjb250ZW50VHlwZUhlYWRlciA9IHt9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xyXG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLmFwcGVuZChcIkFjY2VwdC1MYW5ndWFnZVwiLCBwYXJhbXNbXCJhY2NlcHRMYW5ndWFnZVwiXSk7ZmV0Y2hPcHRpb25zLmhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdKTtcclxuICAgICAgICAqL1xyXG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0gYXNzaWduKHtcclxuICAgICAgICAgICAgXCJBY2NlcHQtTGFuZ3VhZ2VcIjogcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0sIFwiQXV0aG9yaXphdGlvblwiOiBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdLFxyXG4gICAgICAgIH0sIGNvbnRlbnRUeXBlSGVhZGVyKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1cmw6IHVybC5mb3JtYXQodXJsT2JqKSxcclxuICAgICAgICAgICAgb3B0aW9uczogZmV0Y2hPcHRpb25zLFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAqIFRva2VuIGVuZHBvaW50XHJcbiAgICAqIFRoZSB0b2tlbiBlbmRwb2ludCBpcyB1c2VkIHRvIG9idGFpbiBhY2Nlc3MgdG9rZW5zIHdoaWNoIGFsbG93IGNsaWVudHMgdG8gbWFrZSBBUEkgcmVxdWVzdHNcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQmFzaWMgYXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCYXNpYyAmbHQ7Y2xpZW50X2tleSZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGdyYW50VHlwZSBHcmFudCB0eXBlIHVzZWQgdG8gb2J0YWluIHRoZSB0b2tlbi5cclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICogQHBhcmFtIGRldmljZUlkIERldmljZSBpZGVudGlmaWVyLCBtdXN0IHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSB1c2VyIG9yIGRldmljZSBhY2Nlc3NpbmcgdGhlIEFQSS4gUmVxdWlyZWQgb25seSBmb3IgXFwmcXVvdDtkZXZpY2VfY3JlZGVudGlhbHNcXCZxdW90OyBncmFudCB0eXBlXHJcbiAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gUmVmcmVzaCB0b2tlbiwgdXNlZCB0byBpc3N1ZSBhIG5ldyB0b2tlbiB3aXRob3V0IHJlc2VuZGluZyBjbGllbnQgY3JlZGVudGlhbHMuIFJlcXVpcmVkIG9ubHkgZm9yIFxcJnF1b3Q7cmVmcmVzaF90b2tlblxcJnF1b3Q7IGdyYW50IHR5cGVcclxuICAgICovXHJcbiAgICBwb3N0VG9rZW46IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyIFwiYXV0aG9yaXphdGlvblwiIGlzIHNldFxyXG4gICAgICAgIGlmIChwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgYXV0aG9yaXphdGlvbiB3aGVuIGNhbGxpbmcgcG9zdFRva2VuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyIFwiZ3JhbnRUeXBlXCIgaXMgc2V0XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImdyYW50VHlwZVwiXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyIGdyYW50VHlwZSB3aGVuIGNhbGxpbmcgcG9zdFRva2VuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmFzZVVybCA9IFwiL3Rva2VuXCI7XHJcbiAgICAgICAgdmFyIHVybE9iaiA9IHVybC5wYXJzZShiYXNlVXJsLCB0cnVlKTtcclxuICAgICAgICB1cmxPYmoucXVlcnkgPSBhc3NpZ24oe30sIHVybE9iai5xdWVyeSwge1xyXG4gICAgICAgICAgICBcImdyYW50X3R5cGVcIjogcGFyYW1zW1wiZ3JhbnRUeXBlXCJdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBmZXRjaE9wdGlvbnMgPSBhc3NpZ24oe30sIHsgbWV0aG9kOiBcIlBPU1RcIiB9LCBvcHRpb25zKTtcclxuICAgICAgICB2YXIgY29udGVudFR5cGVIZWFkZXIgPSB7fTtcclxuICAgICAgICBjb250ZW50VHlwZUhlYWRlciA9IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiB9O1xyXG4gICAgICAgIGZldGNoT3B0aW9ucy5ib2R5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgXCJkZXZpY2VfaWRcIjogcGFyYW1zW1wiZGV2aWNlSWRcIl0sXHJcbiAgICAgICAgICAgIFwicmVmcmVzaF90b2tlblwiOiBwYXJhbXNbXCJyZWZyZXNoVG9rZW5cIl0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLypcclxuICAgICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBwYXJhbXNbXCJhdXRob3JpemF0aW9uXCJdKTtmZXRjaE9wdGlvbnMuaGVhZGVycy5hcHBlbmQoXCJBY2NlcHQtTGFuZ3VhZ2VcIiwgcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0pO1xyXG4gICAgICAgICovXHJcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBhc3NpZ24oe1xyXG4gICAgICAgICAgICBcIkF1dGhvcml6YXRpb25cIjogcGFyYW1zW1wiYXV0aG9yaXphdGlvblwiXSwgXCJBY2NlcHQtTGFuZ3VhZ2VcIjogcGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0sXHJcbiAgICAgICAgfSwgY29udGVudFR5cGVIZWFkZXIpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVybDogdXJsLmZvcm1hdCh1cmxPYmopLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBmZXRjaE9wdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4qIERlZmF1bHRBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxyXG4qL1xyXG5leHBvcnRzLkRlZmF1bHRBcGlGcCA9IHtcclxuICAgIC8qKlxyXG4gICAgKiBEZWxldGUgY2FyZCBsaWtlXHJcbiAgICAqIFJlbW92ZXMgYSBjYXJkIGZyb20gY3VycmVudCB1c2VyJiMzOTtzIGxpa2VzIGxpc3RcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2FyZElkIFJlcXVlc3RlZCBjYXJkIElEXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqL1xyXG4gICAgZGVsZXRlTGlrZXM6IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZmV0Y2hBcmdzID0gZXhwb3J0cy5EZWZhdWx0QXBpRmV0Y2hQYXJhbUNyZWF0b3IuZGVsZXRlTGlrZXMocGFyYW1zLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZldGNoLCBiYXNlUGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoYmFzZVBhdGggPT09IHZvaWQgMCkgeyBiYXNlUGF0aCA9IEJBU0VfUEFUSDsgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goYmFzZVBhdGggKyBmZXRjaEFyZ3MudXJsLCBmZXRjaEFyZ3Mub3B0aW9ucylcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogRnVsbCBjYXJkIGRldGFpbFxyXG4gICAgKiBSZXRyaWV2ZXMgYSBmdWxsIGNhcmQgZGV0YWlsLCB3aXRoIG5vIHJlbGF0aW9ucyBvciBjb250ZXh0XHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNhcmRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBjYXJkXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSBwcm9kdWN0cyBJbmRpY2F0ZXMgaWYgY2FyZHMgc2hvdWxkIGNvbnRhaW4gY29tbWVyY2lhbCBwcm9kdWN0cyB3aGVuIGF2YWlsYWJsZSAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuICAgICogQHBhcmFtIHVzZXJEYXRhIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiB1c2VyIGRhdGEgd2hlbiBhdmFpbGFibGUgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIGdldENhcmQ6IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZmV0Y2hBcmdzID0gZXhwb3J0cy5EZWZhdWx0QXBpRmV0Y2hQYXJhbUNyZWF0b3IuZ2V0Q2FyZChwYXJhbXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmV0Y2gsIGJhc2VQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXNlUGF0aCA9PT0gdm9pZCAwKSB7IGJhc2VQYXRoID0gQkFTRV9QQVRIOyB9XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChiYXNlUGF0aCArIGZldGNoQXJncy51cmwsIGZldGNoQXJncy5vcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogRnVsbCBjYXJkIGRldGFpbCB3aXRoIHZlcnNpb25cclxuICAgICogUmV0cmlldmVzIGEgZnVsbCBjYXJkIGRldGFpbCwgYW5kIGl0cyByZWxhdGlvbnMgdG8gb3RoZXIgY2FyZHMgaW4gYSBnaXZlbiBjb250ZXh0IChjYXJkIHZlcnNpb24pXHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNhcmRJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBjYXJkXHJcbiAgICAqIEBwYXJhbSB2ZXJzaW9uIFZlcnNpb24gaWRlbnRpZmllciwgaW5kaWNhdGVzIHRoZSBjb250ZXh0IHdoZXJlIHRoZSBjYXJkIGlzIGJlaW5nIHJlcXVlc3RlZFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKiBAcGFyYW0gcHJvZHVjdHMgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIGNvbW1lcmNpYWwgcHJvZHVjdHMgd2hlbiBhdmFpbGFibGUgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAqIEBwYXJhbSB1c2VyRGF0YSBJbmRpY2F0ZXMgaWYgY2FyZHMgc2hvdWxkIGNvbnRhaW4gdXNlciBkYXRhIHdoZW4gYXZhaWxhYmxlICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgKiBAcGFyYW0gcmVsYXRpb25zIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiB0aGUgc2NlbmUgaGllcmFyY2h5ICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICovXHJcbiAgICBnZXRDYXJkVmVyc2lvbjogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBmZXRjaEFyZ3MgPSBleHBvcnRzLkRlZmF1bHRBcGlGZXRjaFBhcmFtQ3JlYXRvci5nZXRDYXJkVmVyc2lvbihwYXJhbXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmV0Y2gsIGJhc2VQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXNlUGF0aCA9PT0gdm9pZCAwKSB7IGJhc2VQYXRoID0gQkFTRV9QQVRIOyB9XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChiYXNlUGF0aCArIGZldGNoQXJncy51cmwsIGZldGNoQXJncy5vcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogTW92aWUgY2F0YWxvZyBpbmZvXHJcbiAgICAqIFJldHJpZXZlcyBhIG1vdmllJiMzOTtzIGZ1bGwgY2FyZCBieSBpdHMgY2xpZW50IElELCBpbmNsdWRpbmcgY2F0YWxvZyBhbmQgY2FzdCBpbmZvcm1hdGlvblxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjbGllbnRNb3ZpZUlkIENsaWVudCBtb3ZpZSBJRCBiZWluZyBwbGF5ZWRcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICogQHBhcmFtIGltYWdlU2l6ZSBTaXplIG9mIHRoZSBpbWFnZXMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAqL1xyXG4gICAgZ2V0Q2F0YWxvZ01vdmllOiBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGZldGNoQXJncyA9IGV4cG9ydHMuRGVmYXVsdEFwaUZldGNoUGFyYW1DcmVhdG9yLmdldENhdGFsb2dNb3ZpZShwYXJhbXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmV0Y2gsIGJhc2VQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXNlUGF0aCA9PT0gdm9pZCAwKSB7IGJhc2VQYXRoID0gQkFTRV9QQVRIOyB9XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChiYXNlUGF0aCArIGZldGNoQXJncy51cmwsIGZldGNoQXJncy5vcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogQ2hhbm5lbCBldmVudHMgZ3JpZFxyXG4gICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGFuZCB1cGNvbWluZyBncmlkIG9mIFRWIGV2ZW50cyBmb3IgdGhlIGdpdmVuIGNoYW5uZWxcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2hhbm5lbElkIENsaWVudCBjaGFubmVsIElEXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIGdldENoYW5uZWxHcmlkOiBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGZldGNoQXJncyA9IGV4cG9ydHMuRGVmYXVsdEFwaUZldGNoUGFyYW1DcmVhdG9yLmdldENoYW5uZWxHcmlkKHBhcmFtcywgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmZXRjaCwgYmFzZVBhdGgpIHtcclxuICAgICAgICAgICAgaWYgKGJhc2VQYXRoID09PSB2b2lkIDApIHsgYmFzZVBhdGggPSBCQVNFX1BBVEg7IH1cclxuICAgICAgICAgICAgcmV0dXJuIGZldGNoKGJhc2VQYXRoICsgZmV0Y2hBcmdzLnVybCwgZmV0Y2hBcmdzLm9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgKiBDaGFubmVsIG1vdmllIGNhdGFsb2cgaW5mb1xyXG4gICAgKiBSZXRyaWV2ZXMgZnVsbCBjYXJkIGRldGFpbCwgaW5jbHVkaW5nIGNhdGFsb2cgYW5kIGNhc3QgaW5mb3JtYXRpb24sIGZvciB0aGUgY29udGVudCBjdXJyZW50bHkgYmVpbmcgYnJvYWRjYXN0ZWQgb24gdGhlIGNoYW5uZWxcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2hhbm5lbElkIENsaWVudCBjaGFubmVsIElEXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIGdldENoYW5uZWxNb3ZpZTogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBmZXRjaEFyZ3MgPSBleHBvcnRzLkRlZmF1bHRBcGlGZXRjaFBhcmFtQ3JlYXRvci5nZXRDaGFubmVsTW92aWUocGFyYW1zLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZldGNoLCBiYXNlUGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoYmFzZVBhdGggPT09IHZvaWQgMCkgeyBiYXNlUGF0aCA9IEJBU0VfUEFUSDsgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goYmFzZVBhdGggKyBmZXRjaEFyZ3MudXJsLCBmZXRjaEFyZ3Mub3B0aW9ucylcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAqIEdldCBjYXJkIGxpa2VzXHJcbiAgICAqIFJldHVybnMgYSBwYWdpbmF0ZWQgbGlzdCBvZiBjYXJkcyBsaWtlZCBieSBjdXJyZW50IHVzZXJcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICogQHBhcmFtIHBhZ2luYXRlS2V5IFBhZ2luYXRlIGtleVxyXG4gICAgKiBAcGFyYW0gc2l6ZSBOdW1iZXIgb2YgZGVzaXJlZCByZXN1bHRzXHJcbiAgICAqL1xyXG4gICAgZ2V0TGlrZXM6IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZmV0Y2hBcmdzID0gZXhwb3J0cy5EZWZhdWx0QXBpRmV0Y2hQYXJhbUNyZWF0b3IuZ2V0TGlrZXMocGFyYW1zLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZldGNoLCBiYXNlUGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoYmFzZVBhdGggPT09IHZvaWQgMCkgeyBiYXNlUGF0aCA9IEJBU0VfUEFUSDsgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goYmFzZVBhdGggKyBmZXRjaEFyZ3MudXJsLCBmZXRjaEFyZ3Mub3B0aW9ucylcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAqIENoYW5uZWwgc3luYyBhdmFpbGFiaWxpdHlcclxuICAgICogQ2hlY2tzIGlmIGEgbGlzdCBvZiBjbGllbnQgY2hhbm5lbCBpZGVudGlmaWVycyBhcmUgY3VycmVudGx5IGJyb2FkY2FzdGluZyBzeW5jaHJvbml6YWJsZSBjb250ZW50XHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNoYW5uZWxJZExpc3QgTGlzdCBvZiBjbGllbnQgY2hhbm5lbCBJRHMgYXMgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKi9cclxuICAgIGdldFJlYWR5Q2hhbm5lbHM6IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZmV0Y2hBcmdzID0gZXhwb3J0cy5EZWZhdWx0QXBpRmV0Y2hQYXJhbUNyZWF0b3IuZ2V0UmVhZHlDaGFubmVscyhwYXJhbXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmV0Y2gsIGJhc2VQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXNlUGF0aCA9PT0gdm9pZCAwKSB7IGJhc2VQYXRoID0gQkFTRV9QQVRIOyB9XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChiYXNlUGF0aCArIGZldGNoQXJncy51cmwsIGZldGNoQXJncy5vcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogTW92aWUgc3luYyBhdmFpbGFiaWxpdHlcclxuICAgICogQ2hlY2tzIHdoZXRoZXIgYSBsaXN0IG9mIGNsaWVudCBtb3ZpZSBpZGVudGlmaWVycyAoVmlkZW8gT24gRGVtYW5kKSBhcmUgYXZhaWxhYmxlIHRvIGJlIHN5bmNocm9uaXplZCB1c2luZyB0aGUgRGl2ZSBBUElcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2xpZW50TW92aWVJZExpc3QgTGlzdCBvZiBjbGllbnQgbW92aWUgSURzLCBwcm92aWRlZCBhcyBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0XHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqL1xyXG4gICAgZ2V0UmVhZHlNb3ZpZXM6IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZmV0Y2hBcmdzID0gZXhwb3J0cy5EZWZhdWx0QXBpRmV0Y2hQYXJhbUNyZWF0b3IuZ2V0UmVhZHlNb3ZpZXMocGFyYW1zLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZldGNoLCBiYXNlUGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoYmFzZVBhdGggPT09IHZvaWQgMCkgeyBiYXNlUGF0aCA9IEJBU0VfUEFUSDsgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goYmFzZVBhdGggKyBmZXRjaEFyZ3MudXJsLCBmZXRjaEFyZ3Mub3B0aW9ucylcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAqIFN0YXRpYyBjaGFubmVsIHNjZW5lXHJcbiAgICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBjYXJkcyByZWxhdGVkIHRvIHRoZSBjb250ZW50IGN1cnJlbnRseSBiZWluZyBicm9hZGNhc3RlZCBpbiB0aGUgcHJvdmlkZWQgY2hhbm5lbFxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjaGFubmVsSWQgQ2xpZW50IGNoYW5uZWwgSURcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICogQHBhcmFtIHJlbGF0aW9ucyBJbmRpY2F0ZXMgaWYgY2FyZHMgc2hvdWxkIGNvbnRhaW4gdGhlIHNjZW5lIGhpZXJhcmNoeSAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuICAgICogQHBhcmFtIGltYWdlU2l6ZSBTaXplIG9mIHRoZSBpbWFnZXMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAqL1xyXG4gICAgZ2V0U3RhdGljQ2hhbm5lbFNjZW5lOiBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGZldGNoQXJncyA9IGV4cG9ydHMuRGVmYXVsdEFwaUZldGNoUGFyYW1DcmVhdG9yLmdldFN0YXRpY0NoYW5uZWxTY2VuZShwYXJhbXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmV0Y2gsIGJhc2VQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXNlUGF0aCA9PT0gdm9pZCAwKSB7IGJhc2VQYXRoID0gQkFTRV9QQVRIOyB9XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChiYXNlUGF0aCArIGZldGNoQXJncy51cmwsIGZldGNoQXJncy5vcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogU3RhdGljIFZPRCBzY2VuZVxyXG4gICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgbGlzdCBvZiBjYXJkcyByZWxhdGVkIHRvIHRoZSBnaXZlbiBtb3ZpZSBzY2VuZVxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjbGllbnRNb3ZpZUlkIENsaWVudCBtb3ZpZSBJRCBiZWluZyBwbGF5ZWRcclxuICAgICogQHBhcmFtIHRpbWVzdGFtcCBDdXJyZW50IG1vdmllIHRpbWVzdGFtcCBpbiBzZWNvbmRzXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSByZWxhdGlvbnMgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIHRoZSBzY2VuZSBoaWVyYXJjaHkgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIGdldFN0YXRpY01vdmllU2NlbmU6IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZmV0Y2hBcmdzID0gZXhwb3J0cy5EZWZhdWx0QXBpRmV0Y2hQYXJhbUNyZWF0b3IuZ2V0U3RhdGljTW92aWVTY2VuZShwYXJhbXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmV0Y2gsIGJhc2VQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXNlUGF0aCA9PT0gdm9pZCAwKSB7IGJhc2VQYXRoID0gQkFTRV9QQVRIOyB9XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChiYXNlUGF0aCArIGZldGNoQXJncy51cmwsIGZldGNoQXJncy5vcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogQWRkIGNhcmQgbGlrZVxyXG4gICAgKiBTdG9yZXMgYSBjYXJkIHVuZGVyIGN1cnJlbnQgdXNlciYjMzk7cyBsaWtlcyBsaXN0XHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNhcmRJZCBSZXF1ZXN0ZWQgY2FyZCBJRFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKi9cclxuICAgIHBvc3RMaWtlczogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBmZXRjaEFyZ3MgPSBleHBvcnRzLkRlZmF1bHRBcGlGZXRjaFBhcmFtQ3JlYXRvci5wb3N0TGlrZXMocGFyYW1zLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZldGNoLCBiYXNlUGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoYmFzZVBhdGggPT09IHZvaWQgMCkgeyBiYXNlUGF0aCA9IEJBU0VfUEFUSDsgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goYmFzZVBhdGggKyBmZXRjaEFyZ3MudXJsLCBmZXRjaEFyZ3Mub3B0aW9ucylcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICogVG9rZW4gZW5kcG9pbnRcclxuICAgICogVGhlIHRva2VuIGVuZHBvaW50IGlzIHVzZWQgdG8gb2J0YWluIGFjY2VzcyB0b2tlbnMgd2hpY2ggYWxsb3cgY2xpZW50cyB0byBtYWtlIEFQSSByZXF1ZXN0c1xyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBCYXNpYyBhdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0Jhc2ljICZsdDtjbGllbnRfa2V5Jmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gZ3JhbnRUeXBlIEdyYW50IHR5cGUgdXNlZCB0byBvYnRhaW4gdGhlIHRva2VuLlxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKiBAcGFyYW0gZGV2aWNlSWQgRGV2aWNlIGlkZW50aWZpZXIsIG11c3QgdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHVzZXIgb3IgZGV2aWNlIGFjY2Vzc2luZyB0aGUgQVBJLiBSZXF1aXJlZCBvbmx5IGZvciBcXCZxdW90O2RldmljZV9jcmVkZW50aWFsc1xcJnF1b3Q7IGdyYW50IHR5cGVcclxuICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBSZWZyZXNoIHRva2VuLCB1c2VkIHRvIGlzc3VlIGEgbmV3IHRva2VuIHdpdGhvdXQgcmVzZW5kaW5nIGNsaWVudCBjcmVkZW50aWFscy4gUmVxdWlyZWQgb25seSBmb3IgXFwmcXVvdDtyZWZyZXNoX3Rva2VuXFwmcXVvdDsgZ3JhbnQgdHlwZVxyXG4gICAgKi9cclxuICAgIHBvc3RUb2tlbjogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBmZXRjaEFyZ3MgPSBleHBvcnRzLkRlZmF1bHRBcGlGZXRjaFBhcmFtQ3JlYXRvci5wb3N0VG9rZW4ocGFyYW1zLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZldGNoLCBiYXNlUGF0aCkge1xyXG4gICAgICAgICAgICBpZiAoYmFzZVBhdGggPT09IHZvaWQgMCkgeyBiYXNlUGF0aCA9IEJBU0VfUEFUSDsgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goYmFzZVBhdGggKyBmZXRjaEFyZ3MudXJsLCBmZXRjaEFyZ3Mub3B0aW9ucylcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuKiBEZWZhdWx0QXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxyXG4qL1xyXG52YXIgRGVmYXVsdEFwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZWZhdWx0QXBpLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGVmYXVsdEFwaSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogRGVsZXRlIGNhcmQgbGlrZVxyXG4gICAgKiBSZW1vdmVzIGEgY2FyZCBmcm9tIGN1cnJlbnQgdXNlciYjMzk7cyBsaWtlcyBsaXN0XHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNhcmRJZCBSZXF1ZXN0ZWQgY2FyZCBJRFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKi9cclxuICAgIERlZmF1bHRBcGkucHJvdG90eXBlLmRlbGV0ZUxpa2VzID0gZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5kZWxldGVMaWtlcyhwYXJhbXMsIG9wdGlvbnMpKHRoaXMuZmV0Y2gsIHRoaXMuYmFzZVBhdGgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBGdWxsIGNhcmQgZGV0YWlsXHJcbiAgICAqIFJldHJpZXZlcyBhIGZ1bGwgY2FyZCBkZXRhaWwsIHdpdGggbm8gcmVsYXRpb25zIG9yIGNvbnRleHRcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2FyZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGNhcmRcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICogQHBhcmFtIHByb2R1Y3RzIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiBjb21tZXJjaWFsIHByb2R1Y3RzIHdoZW4gYXZhaWxhYmxlICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgKiBAcGFyYW0gdXNlckRhdGEgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIHVzZXIgZGF0YSB3aGVuIGF2YWlsYWJsZSAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuICAgICogQHBhcmFtIGltYWdlU2l6ZSBTaXplIG9mIHRoZSBpbWFnZXMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAqL1xyXG4gICAgRGVmYXVsdEFwaS5wcm90b3R5cGUuZ2V0Q2FyZCA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0Q2FyZChwYXJhbXMsIG9wdGlvbnMpKHRoaXMuZmV0Y2gsIHRoaXMuYmFzZVBhdGgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBGdWxsIGNhcmQgZGV0YWlsIHdpdGggdmVyc2lvblxyXG4gICAgKiBSZXRyaWV2ZXMgYSBmdWxsIGNhcmQgZGV0YWlsLCBhbmQgaXRzIHJlbGF0aW9ucyB0byBvdGhlciBjYXJkcyBpbiBhIGdpdmVuIGNvbnRleHQgKGNhcmQgdmVyc2lvbilcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2FyZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGNhcmRcclxuICAgICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiBpZGVudGlmaWVyLCBpbmRpY2F0ZXMgdGhlIGNvbnRleHQgd2hlcmUgdGhlIGNhcmQgaXMgYmVpbmcgcmVxdWVzdGVkXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSBwcm9kdWN0cyBJbmRpY2F0ZXMgaWYgY2FyZHMgc2hvdWxkIGNvbnRhaW4gY29tbWVyY2lhbCBwcm9kdWN0cyB3aGVuIGF2YWlsYWJsZSAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuICAgICogQHBhcmFtIHVzZXJEYXRhIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiB1c2VyIGRhdGEgd2hlbiBhdmFpbGFibGUgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAqIEBwYXJhbSByZWxhdGlvbnMgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIHRoZSBzY2VuZSBoaWVyYXJjaHkgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIERlZmF1bHRBcGkucHJvdG90eXBlLmdldENhcmRWZXJzaW9uID0gZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRDYXJkVmVyc2lvbihwYXJhbXMsIG9wdGlvbnMpKHRoaXMuZmV0Y2gsIHRoaXMuYmFzZVBhdGgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBNb3ZpZSBjYXRhbG9nIGluZm9cclxuICAgICogUmV0cmlldmVzIGEgbW92aWUmIzM5O3MgZnVsbCBjYXJkIGJ5IGl0cyBjbGllbnQgSUQsIGluY2x1ZGluZyBjYXRhbG9nIGFuZCBjYXN0IGluZm9ybWF0aW9uXHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNsaWVudE1vdmllSWQgQ2xpZW50IG1vdmllIElEIGJlaW5nIHBsYXllZFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICovXHJcbiAgICBEZWZhdWx0QXBpLnByb3RvdHlwZS5nZXRDYXRhbG9nTW92aWUgPSBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuRGVmYXVsdEFwaUZwLmdldENhdGFsb2dNb3ZpZShwYXJhbXMsIG9wdGlvbnMpKHRoaXMuZmV0Y2gsIHRoaXMuYmFzZVBhdGgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBDaGFubmVsIGV2ZW50cyBncmlkXHJcbiAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYW5kIHVwY29taW5nIGdyaWQgb2YgVFYgZXZlbnRzIGZvciB0aGUgZ2l2ZW4gY2hhbm5lbFxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjaGFubmVsSWQgQ2xpZW50IGNoYW5uZWwgSURcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICogQHBhcmFtIGltYWdlU2l6ZSBTaXplIG9mIHRoZSBpbWFnZXMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAqL1xyXG4gICAgRGVmYXVsdEFwaS5wcm90b3R5cGUuZ2V0Q2hhbm5lbEdyaWQgPSBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuRGVmYXVsdEFwaUZwLmdldENoYW5uZWxHcmlkKHBhcmFtcywgb3B0aW9ucykodGhpcy5mZXRjaCwgdGhpcy5iYXNlUGF0aCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAqIENoYW5uZWwgbW92aWUgY2F0YWxvZyBpbmZvXHJcbiAgICAqIFJldHJpZXZlcyBmdWxsIGNhcmQgZGV0YWlsLCBpbmNsdWRpbmcgY2F0YWxvZyBhbmQgY2FzdCBpbmZvcm1hdGlvbiwgZm9yIHRoZSBjb250ZW50IGN1cnJlbnRseSBiZWluZyBicm9hZGNhc3RlZCBvbiB0aGUgY2hhbm5lbFxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjaGFubmVsSWQgQ2xpZW50IGNoYW5uZWwgSURcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICogQHBhcmFtIGltYWdlU2l6ZSBTaXplIG9mIHRoZSBpbWFnZXMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAqL1xyXG4gICAgRGVmYXVsdEFwaS5wcm90b3R5cGUuZ2V0Q2hhbm5lbE1vdmllID0gZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRDaGFubmVsTW92aWUocGFyYW1zLCBvcHRpb25zKSh0aGlzLmZldGNoLCB0aGlzLmJhc2VQYXRoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICogR2V0IGNhcmQgbGlrZXNcclxuICAgICogUmV0dXJucyBhIHBhZ2luYXRlZCBsaXN0IG9mIGNhcmRzIGxpa2VkIGJ5IGN1cnJlbnQgdXNlclxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKiBAcGFyYW0gcGFnaW5hdGVLZXkgUGFnaW5hdGUga2V5XHJcbiAgICAqIEBwYXJhbSBzaXplIE51bWJlciBvZiBkZXNpcmVkIHJlc3VsdHNcclxuICAgICovXHJcbiAgICBEZWZhdWx0QXBpLnByb3RvdHlwZS5nZXRMaWtlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0TGlrZXMocGFyYW1zLCBvcHRpb25zKSh0aGlzLmZldGNoLCB0aGlzLmJhc2VQYXRoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICogQ2hhbm5lbCBzeW5jIGF2YWlsYWJpbGl0eVxyXG4gICAgKiBDaGVja3MgaWYgYSBsaXN0IG9mIGNsaWVudCBjaGFubmVsIGlkZW50aWZpZXJzIGFyZSBjdXJyZW50bHkgYnJvYWRjYXN0aW5nIHN5bmNocm9uaXphYmxlIGNvbnRlbnRcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2hhbm5lbElkTGlzdCBMaXN0IG9mIGNsaWVudCBjaGFubmVsIElEcyBhcyBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0XHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqL1xyXG4gICAgRGVmYXVsdEFwaS5wcm90b3R5cGUuZ2V0UmVhZHlDaGFubmVscyA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0UmVhZHlDaGFubmVscyhwYXJhbXMsIG9wdGlvbnMpKHRoaXMuZmV0Y2gsIHRoaXMuYmFzZVBhdGgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBNb3ZpZSBzeW5jIGF2YWlsYWJpbGl0eVxyXG4gICAgKiBDaGVja3Mgd2hldGhlciBhIGxpc3Qgb2YgY2xpZW50IG1vdmllIGlkZW50aWZpZXJzIChWaWRlbyBPbiBEZW1hbmQpIGFyZSBhdmFpbGFibGUgdG8gYmUgc3luY2hyb25pemVkIHVzaW5nIHRoZSBEaXZlIEFQSVxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjbGllbnRNb3ZpZUlkTGlzdCBMaXN0IG9mIGNsaWVudCBtb3ZpZSBJRHMsIHByb3ZpZGVkIGFzIGEgY29tbWEgc2VwYXJhdGVkIGxpc3RcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICovXHJcbiAgICBEZWZhdWx0QXBpLnByb3RvdHlwZS5nZXRSZWFkeU1vdmllcyA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0UmVhZHlNb3ZpZXMocGFyYW1zLCBvcHRpb25zKSh0aGlzLmZldGNoLCB0aGlzLmJhc2VQYXRoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICogU3RhdGljIGNoYW5uZWwgc2NlbmVcclxuICAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIGNhcmRzIHJlbGF0ZWQgdG8gdGhlIGNvbnRlbnQgY3VycmVudGx5IGJlaW5nIGJyb2FkY2FzdGVkIGluIHRoZSBwcm92aWRlZCBjaGFubmVsXHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNoYW5uZWxJZCBDbGllbnQgY2hhbm5lbCBJRFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKiBAcGFyYW0gcmVsYXRpb25zIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiB0aGUgc2NlbmUgaGllcmFyY2h5ICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICovXHJcbiAgICBEZWZhdWx0QXBpLnByb3RvdHlwZS5nZXRTdGF0aWNDaGFubmVsU2NlbmUgPSBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuRGVmYXVsdEFwaUZwLmdldFN0YXRpY0NoYW5uZWxTY2VuZShwYXJhbXMsIG9wdGlvbnMpKHRoaXMuZmV0Y2gsIHRoaXMuYmFzZVBhdGgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBTdGF0aWMgVk9EIHNjZW5lXHJcbiAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBsaXN0IG9mIGNhcmRzIHJlbGF0ZWQgdG8gdGhlIGdpdmVuIG1vdmllIHNjZW5lXHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNsaWVudE1vdmllSWQgQ2xpZW50IG1vdmllIElEIGJlaW5nIHBsYXllZFxyXG4gICAgKiBAcGFyYW0gdGltZXN0YW1wIEN1cnJlbnQgbW92aWUgdGltZXN0YW1wIGluIHNlY29uZHNcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICogQHBhcmFtIHJlbGF0aW9ucyBJbmRpY2F0ZXMgaWYgY2FyZHMgc2hvdWxkIGNvbnRhaW4gdGhlIHNjZW5lIGhpZXJhcmNoeSAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuICAgICogQHBhcmFtIGltYWdlU2l6ZSBTaXplIG9mIHRoZSBpbWFnZXMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAqL1xyXG4gICAgRGVmYXVsdEFwaS5wcm90b3R5cGUuZ2V0U3RhdGljTW92aWVTY2VuZSA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0U3RhdGljTW92aWVTY2VuZShwYXJhbXMsIG9wdGlvbnMpKHRoaXMuZmV0Y2gsIHRoaXMuYmFzZVBhdGgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBBZGQgY2FyZCBsaWtlXHJcbiAgICAqIFN0b3JlcyBhIGNhcmQgdW5kZXIgY3VycmVudCB1c2VyJiMzOTtzIGxpa2VzIGxpc3RcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2FyZElkIFJlcXVlc3RlZCBjYXJkIElEXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqL1xyXG4gICAgRGVmYXVsdEFwaS5wcm90b3R5cGUucG9zdExpa2VzID0gZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5wb3N0TGlrZXMocGFyYW1zLCBvcHRpb25zKSh0aGlzLmZldGNoLCB0aGlzLmJhc2VQYXRoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICogVG9rZW4gZW5kcG9pbnRcclxuICAgICogVGhlIHRva2VuIGVuZHBvaW50IGlzIHVzZWQgdG8gb2J0YWluIGFjY2VzcyB0b2tlbnMgd2hpY2ggYWxsb3cgY2xpZW50cyB0byBtYWtlIEFQSSByZXF1ZXN0c1xyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBCYXNpYyBhdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0Jhc2ljICZsdDtjbGllbnRfa2V5Jmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gZ3JhbnRUeXBlIEdyYW50IHR5cGUgdXNlZCB0byBvYnRhaW4gdGhlIHRva2VuLlxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKiBAcGFyYW0gZGV2aWNlSWQgRGV2aWNlIGlkZW50aWZpZXIsIG11c3QgdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHVzZXIgb3IgZGV2aWNlIGFjY2Vzc2luZyB0aGUgQVBJLiBSZXF1aXJlZCBvbmx5IGZvciBcXCZxdW90O2RldmljZV9jcmVkZW50aWFsc1xcJnF1b3Q7IGdyYW50IHR5cGVcclxuICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBSZWZyZXNoIHRva2VuLCB1c2VkIHRvIGlzc3VlIGEgbmV3IHRva2VuIHdpdGhvdXQgcmVzZW5kaW5nIGNsaWVudCBjcmVkZW50aWFscy4gUmVxdWlyZWQgb25seSBmb3IgXFwmcXVvdDtyZWZyZXNoX3Rva2VuXFwmcXVvdDsgZ3JhbnQgdHlwZVxyXG4gICAgKi9cclxuICAgIERlZmF1bHRBcGkucHJvdG90eXBlLnBvc3RUb2tlbiA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAucG9zdFRva2VuKHBhcmFtcywgb3B0aW9ucykodGhpcy5mZXRjaCwgdGhpcy5iYXNlUGF0aCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERlZmF1bHRBcGk7XHJcbn0oQmFzZUFQSSkpO1xyXG5leHBvcnRzLkRlZmF1bHRBcGkgPSBEZWZhdWx0QXBpO1xyXG47XHJcbi8qKlxyXG4qIERlZmF1bHRBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxyXG4qL1xyXG5leHBvcnRzLkRlZmF1bHRBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGZldGNoLCBiYXNlUGF0aCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAqIERlbGV0ZSBjYXJkIGxpa2VcclxuICAgICAgICAqIFJlbW92ZXMgYSBjYXJkIGZyb20gY3VycmVudCB1c2VyJiMzOTtzIGxpa2VzIGxpc3RcclxuICAgICAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICAgICAqIEBwYXJhbSBjYXJkSWQgUmVxdWVzdGVkIGNhcmQgSURcclxuICAgICAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAgICAgKi9cclxuICAgICAgICBkZWxldGVMaWtlczogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZGVsZXRlTGlrZXMocGFyYW1zLCBvcHRpb25zKShmZXRjaCwgYmFzZVBhdGgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBGdWxsIGNhcmQgZGV0YWlsXHJcbiAgICAgICAgKiBSZXRyaWV2ZXMgYSBmdWxsIGNhcmQgZGV0YWlsLCB3aXRoIG5vIHJlbGF0aW9ucyBvciBjb250ZXh0XHJcbiAgICAgICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAgICAgKiBAcGFyYW0gY2FyZElkIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGNhcmRcclxuICAgICAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAgICAgKiBAcGFyYW0gcHJvZHVjdHMgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIGNvbW1lcmNpYWwgcHJvZHVjdHMgd2hlbiBhdmFpbGFibGUgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAgICAgKiBAcGFyYW0gdXNlckRhdGEgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIHVzZXIgZGF0YSB3aGVuIGF2YWlsYWJsZSAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuICAgICAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgZ2V0Q2FyZDogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0Q2FyZChwYXJhbXMsIG9wdGlvbnMpKGZldGNoLCBiYXNlUGF0aCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIEZ1bGwgY2FyZCBkZXRhaWwgd2l0aCB2ZXJzaW9uXHJcbiAgICAgICAgKiBSZXRyaWV2ZXMgYSBmdWxsIGNhcmQgZGV0YWlsLCBhbmQgaXRzIHJlbGF0aW9ucyB0byBvdGhlciBjYXJkcyBpbiBhIGdpdmVuIGNvbnRleHQgKGNhcmQgdmVyc2lvbilcclxuICAgICAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICAgICAqIEBwYXJhbSBjYXJkSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgY2FyZFxyXG4gICAgICAgICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiBpZGVudGlmaWVyLCBpbmRpY2F0ZXMgdGhlIGNvbnRleHQgd2hlcmUgdGhlIGNhcmQgaXMgYmVpbmcgcmVxdWVzdGVkXHJcbiAgICAgICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgICAgICogQHBhcmFtIHByb2R1Y3RzIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiBjb21tZXJjaWFsIHByb2R1Y3RzIHdoZW4gYXZhaWxhYmxlICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgICAgICogQHBhcmFtIHVzZXJEYXRhIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiB1c2VyIGRhdGEgd2hlbiBhdmFpbGFibGUgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAgICAgKiBAcGFyYW0gcmVsYXRpb25zIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiB0aGUgc2NlbmUgaGllcmFyY2h5ICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgICAgICogQHBhcmFtIGltYWdlU2l6ZSBTaXplIG9mIHRoZSBpbWFnZXMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAgICAgKi9cclxuICAgICAgICBnZXRDYXJkVmVyc2lvbjogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0Q2FyZFZlcnNpb24ocGFyYW1zLCBvcHRpb25zKShmZXRjaCwgYmFzZVBhdGgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBNb3ZpZSBjYXRhbG9nIGluZm9cclxuICAgICAgICAqIFJldHJpZXZlcyBhIG1vdmllJiMzOTtzIGZ1bGwgY2FyZCBieSBpdHMgY2xpZW50IElELCBpbmNsdWRpbmcgY2F0YWxvZyBhbmQgY2FzdCBpbmZvcm1hdGlvblxyXG4gICAgICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgICAgICogQHBhcmFtIGNsaWVudE1vdmllSWQgQ2xpZW50IG1vdmllIElEIGJlaW5nIHBsYXllZFxyXG4gICAgICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgZ2V0Q2F0YWxvZ01vdmllOiBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRDYXRhbG9nTW92aWUocGFyYW1zLCBvcHRpb25zKShmZXRjaCwgYmFzZVBhdGgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBDaGFubmVsIGV2ZW50cyBncmlkXHJcbiAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGFuZCB1cGNvbWluZyBncmlkIG9mIFRWIGV2ZW50cyBmb3IgdGhlIGdpdmVuIGNoYW5uZWxcclxuICAgICAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICAgICAqIEBwYXJhbSBjaGFubmVsSWQgQ2xpZW50IGNoYW5uZWwgSURcclxuICAgICAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAgICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICAgICAqL1xyXG4gICAgICAgIGdldENoYW5uZWxHcmlkOiBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRDaGFubmVsR3JpZChwYXJhbXMsIG9wdGlvbnMpKGZldGNoLCBiYXNlUGF0aCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIENoYW5uZWwgbW92aWUgY2F0YWxvZyBpbmZvXHJcbiAgICAgICAgKiBSZXRyaWV2ZXMgZnVsbCBjYXJkIGRldGFpbCwgaW5jbHVkaW5nIGNhdGFsb2cgYW5kIGNhc3QgaW5mb3JtYXRpb24sIGZvciB0aGUgY29udGVudCBjdXJyZW50bHkgYmVpbmcgYnJvYWRjYXN0ZWQgb24gdGhlIGNoYW5uZWxcclxuICAgICAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICAgICAqIEBwYXJhbSBjaGFubmVsSWQgQ2xpZW50IGNoYW5uZWwgSURcclxuICAgICAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAgICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICAgICAqL1xyXG4gICAgICAgIGdldENoYW5uZWxNb3ZpZTogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0Q2hhbm5lbE1vdmllKHBhcmFtcywgb3B0aW9ucykoZmV0Y2gsIGJhc2VQYXRoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogR2V0IGNhcmQgbGlrZXNcclxuICAgICAgICAqIFJldHVybnMgYSBwYWdpbmF0ZWQgbGlzdCBvZiBjYXJkcyBsaWtlZCBieSBjdXJyZW50IHVzZXJcclxuICAgICAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAgICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICAgICAqIEBwYXJhbSBwYWdpbmF0ZUtleSBQYWdpbmF0ZSBrZXlcclxuICAgICAgICAqIEBwYXJhbSBzaXplIE51bWJlciBvZiBkZXNpcmVkIHJlc3VsdHNcclxuICAgICAgICAqL1xyXG4gICAgICAgIGdldExpa2VzOiBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRMaWtlcyhwYXJhbXMsIG9wdGlvbnMpKGZldGNoLCBiYXNlUGF0aCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIENoYW5uZWwgc3luYyBhdmFpbGFiaWxpdHlcclxuICAgICAgICAqIENoZWNrcyBpZiBhIGxpc3Qgb2YgY2xpZW50IGNoYW5uZWwgaWRlbnRpZmllcnMgYXJlIGN1cnJlbnRseSBicm9hZGNhc3Rpbmcgc3luY2hyb25pemFibGUgY29udGVudFxyXG4gICAgICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgICAgICogQHBhcmFtIGNoYW5uZWxJZExpc3QgTGlzdCBvZiBjbGllbnQgY2hhbm5lbCBJRHMgYXMgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdFxyXG4gICAgICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICAgICAqL1xyXG4gICAgICAgIGdldFJlYWR5Q2hhbm5lbHM6IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuRGVmYXVsdEFwaUZwLmdldFJlYWR5Q2hhbm5lbHMocGFyYW1zLCBvcHRpb25zKShmZXRjaCwgYmFzZVBhdGgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBNb3ZpZSBzeW5jIGF2YWlsYWJpbGl0eVxyXG4gICAgICAgICogQ2hlY2tzIHdoZXRoZXIgYSBsaXN0IG9mIGNsaWVudCBtb3ZpZSBpZGVudGlmaWVycyAoVmlkZW8gT24gRGVtYW5kKSBhcmUgYXZhaWxhYmxlIHRvIGJlIHN5bmNocm9uaXplZCB1c2luZyB0aGUgRGl2ZSBBUElcclxuICAgICAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICAgICAqIEBwYXJhbSBjbGllbnRNb3ZpZUlkTGlzdCBMaXN0IG9mIGNsaWVudCBtb3ZpZSBJRHMsIHByb3ZpZGVkIGFzIGEgY29tbWEgc2VwYXJhdGVkIGxpc3RcclxuICAgICAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAgICAgKi9cclxuICAgICAgICBnZXRSZWFkeU1vdmllczogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0UmVhZHlNb3ZpZXMocGFyYW1zLCBvcHRpb25zKShmZXRjaCwgYmFzZVBhdGgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBTdGF0aWMgY2hhbm5lbCBzY2VuZVxyXG4gICAgICAgICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIGNhcmRzIHJlbGF0ZWQgdG8gdGhlIGNvbnRlbnQgY3VycmVudGx5IGJlaW5nIGJyb2FkY2FzdGVkIGluIHRoZSBwcm92aWRlZCBjaGFubmVsXHJcbiAgICAgICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAgICAgKiBAcGFyYW0gY2hhbm5lbElkIENsaWVudCBjaGFubmVsIElEXHJcbiAgICAgICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgICAgICogQHBhcmFtIHJlbGF0aW9ucyBJbmRpY2F0ZXMgaWYgY2FyZHMgc2hvdWxkIGNvbnRhaW4gdGhlIHNjZW5lIGhpZXJhcmNoeSAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuICAgICAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgZ2V0U3RhdGljQ2hhbm5lbFNjZW5lOiBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRTdGF0aWNDaGFubmVsU2NlbmUocGFyYW1zLCBvcHRpb25zKShmZXRjaCwgYmFzZVBhdGgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBTdGF0aWMgVk9EIHNjZW5lXHJcbiAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgbGlzdCBvZiBjYXJkcyByZWxhdGVkIHRvIHRoZSBnaXZlbiBtb3ZpZSBzY2VuZVxyXG4gICAgICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgICAgICogQHBhcmFtIGNsaWVudE1vdmllSWQgQ2xpZW50IG1vdmllIElEIGJlaW5nIHBsYXllZFxyXG4gICAgICAgICogQHBhcmFtIHRpbWVzdGFtcCBDdXJyZW50IG1vdmllIHRpbWVzdGFtcCBpbiBzZWNvbmRzXHJcbiAgICAgICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgICAgICogQHBhcmFtIHJlbGF0aW9ucyBJbmRpY2F0ZXMgaWYgY2FyZHMgc2hvdWxkIGNvbnRhaW4gdGhlIHNjZW5lIGhpZXJhcmNoeSAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuICAgICAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgZ2V0U3RhdGljTW92aWVTY2VuZTogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0U3RhdGljTW92aWVTY2VuZShwYXJhbXMsIG9wdGlvbnMpKGZldGNoLCBiYXNlUGF0aCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIEFkZCBjYXJkIGxpa2VcclxuICAgICAgICAqIFN0b3JlcyBhIGNhcmQgdW5kZXIgY3VycmVudCB1c2VyJiMzOTtzIGxpa2VzIGxpc3RcclxuICAgICAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICAgICAqIEBwYXJhbSBjYXJkSWQgUmVxdWVzdGVkIGNhcmQgSURcclxuICAgICAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAgICAgKi9cclxuICAgICAgICBwb3N0TGlrZXM6IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuRGVmYXVsdEFwaUZwLnBvc3RMaWtlcyhwYXJhbXMsIG9wdGlvbnMpKGZldGNoLCBiYXNlUGF0aCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRva2VuIGVuZHBvaW50XHJcbiAgICAgICAgKiBUaGUgdG9rZW4gZW5kcG9pbnQgaXMgdXNlZCB0byBvYnRhaW4gYWNjZXNzIHRva2VucyB3aGljaCBhbGxvdyBjbGllbnRzIHRvIG1ha2UgQVBJIHJlcXVlc3RzXHJcbiAgICAgICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBCYXNpYyBhdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0Jhc2ljICZsdDtjbGllbnRfa2V5Jmd0OyYjMzk7KVxyXG4gICAgICAgICogQHBhcmFtIGdyYW50VHlwZSBHcmFudCB0eXBlIHVzZWQgdG8gb2J0YWluIHRoZSB0b2tlbi5cclxuICAgICAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAgICAgKiBAcGFyYW0gZGV2aWNlSWQgRGV2aWNlIGlkZW50aWZpZXIsIG11c3QgdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHVzZXIgb3IgZGV2aWNlIGFjY2Vzc2luZyB0aGUgQVBJLiBSZXF1aXJlZCBvbmx5IGZvciBcXCZxdW90O2RldmljZV9jcmVkZW50aWFsc1xcJnF1b3Q7IGdyYW50IHR5cGVcclxuICAgICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gUmVmcmVzaCB0b2tlbiwgdXNlZCB0byBpc3N1ZSBhIG5ldyB0b2tlbiB3aXRob3V0IHJlc2VuZGluZyBjbGllbnQgY3JlZGVudGlhbHMuIFJlcXVpcmVkIG9ubHkgZm9yIFxcJnF1b3Q7cmVmcmVzaF90b2tlblxcJnF1b3Q7IGdyYW50IHR5cGVcclxuICAgICAgICAqL1xyXG4gICAgICAgIHBvc3RUb2tlbjogZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAucG9zdFRva2VuKHBhcmFtcywgb3B0aW9ucykoZmV0Y2gsIGJhc2VQYXRoKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufTtcclxuO1xyXG4vKipcclxuKiBEaXZlQVBJIC0gZXh0ZW5kZWQgb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxyXG4qL1xyXG52YXIgRGl2ZUFQSUNsYXNzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERpdmVBUElDbGFzcywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERpdmVBUElDbGFzcyhwYXJhbXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcIlwiLCBwYXJhbXMuZmV0Y2gpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZW52aXJvbm1lbnQgPSBcIlBST1wiO1xyXG4gICAgICAgIF90aGlzLm5vQXV0aFNlcnZpY2VzID0gW1wicG9zdFJlZ2lzdGVyRGV2aWNlXCIsIFwicG9zdFJlZ2lzdGVyRW1haWxcIiwgXCJwb3N0VG9rZW5cIiwgXCJwb3N0VmVyc2lvblwiXTtcclxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IHNob3VsZCBwcm92aWRlIGluaXRpYWxpemF0aW9uIHBhcmFtcy5cIik7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBzaG91bGQgcHJvdmlkZSBpbml0aWFsaXphdGlvbiBwYXJhbXMuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5hcGlLZXkgPSBwYXJhbXMuYXBpS2V5O1xyXG4gICAgICAgIGlmIChwYXJhbXMuZGV2aWNlSWQpIHtcclxuICAgICAgICAgICAgX3RoaXMuc2V0RGV2aWNlSWQocGFyYW1zLmRldmljZUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuZXZlbnROYW1lc3BhY2UgPSBwYXJhbXMuZXZlbnROYW1lc3BhY2UgfHwgXCJkaXZlLWV4dGVybmFsLWFwaS1cIjtcclxuICAgICAgICBfdGhpcy5zZXRFbnZpcm9ubWVudChwYXJhbXMuZW52KTtcclxuICAgICAgICBfdGhpcy5zdG9yZVRva2VuVHlwZSA9IHBhcmFtcy5zdG9yZVRva2VuO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICAvLyB0aGlzLmNvbm5lY3Rpb25GYWlsZWRPYnNlcnZhYmxlID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsIGAke3RoaXMuZXZlbnROYW1lc3BhY2V9LWNvbm5lY3Rpb24tZmFpbGVkYCk7XHJcbiAgICAgICAgLy8gdGhpcy5pbnRlcm5hbFNlcnZlckVycm9yT2JzZXJ2YWJsZSA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCBgJHt0aGlzLmV2ZW50TmFtZXNwYWNlfS1pbnRlcm5hbC1zZXJ2ZXItZXJyb3JgKTtcclxuICAgICAgICAvLyB0aGlzLnNlcnZpY2VUZW1wb3JhcmlseVVuYXZhaWxhYmxlT2JzZXJ2YWJsZSA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCBgJHt0aGlzLmV2ZW50TmFtZXNwYWNlfS1zZXJ2aWNlLXVuYXZhaWxhYmxlYCk7XHJcbiAgICAgICAgLy8gdGhpcy51bnN1cHBvcnRlZE1lZGlhVHlwZUVycm9yT2JzZXJ2YWJsZSA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCBgJHt0aGlzLmV2ZW50TmFtZXNwYWNlfS11bnN1cHBvcnRlZC1tZWRpYXR5cGVgKTtcclxuICAgICAgICAvLyB0aGlzLnVuYXV0aG9yaXplZE9ic2VydmFibGUgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgYCR7dGhpcy5ldmVudE5hbWVzcGFjZX0tdW5hdXRob3JpemVkYCk7XHJcbiAgICAgICAgLy8gdGhpcy51bmF1dGhvcml6ZWRSb2xlT2JzZXJ2YWJsZSA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCBgJHt0aGlzLmV2ZW50TmFtZXNwYWNlfS11bmF1dGhvcml6ZWQtcm9sZWApO1xyXG4gICAgfVxyXG4gICAgRGl2ZUFQSUNsYXNzLnByb3RvdHlwZS5zZXREZXZpY2VJZCA9IGZ1bmN0aW9uIChkZXZpY2VJZCkge1xyXG4gICAgICAgIHRoaXMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcclxuICAgIH07XHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLmdldFNhdmVkVG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0b3JlVG9rZW5UeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjb29raWVzXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbkZyb21Db29raWVzKCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRUb2tlbkZyb21XZWJTdG9yYWdlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmdldFRva2VuRnJvbVdlYlN0b3JhZ2UoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGl2ZUFQSUNsYXNzLnByb3RvdHlwZS5zZXRFbnZpcm9ubWVudCA9IGZ1bmN0aW9uIChlbnYpIHtcclxuICAgICAgICB0aGlzLmVudmlyb25tZW50ID0gZW52O1xyXG4gICAgICAgIHN3aXRjaCAoZW52KSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVZcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVBhdGggPSBCQVNFX1BBVEgucmVwbGFjZShcImh0dHBzOi8vXCIsIFwiaHR0cHM6Ly9kZXYtXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQUkVcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVBhdGggPSBCQVNFX1BBVEgucmVwbGFjZShcImh0dHBzOi8vXCIsIFwiaHR0cHM6Ly9wcmUtXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQUk9cIjpcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVBhdGggPSBCQVNFX1BBVEg7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGl2ZUFQSUNsYXNzLnByb3RvdHlwZS5zZXRMb2NhbGUgPSBmdW5jdGlvbiAobG9jYWxlKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XHJcbiAgICB9O1xyXG4gICAgRGl2ZUFQSUNsYXNzLnByb3RvdHlwZS5nZXRMb2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlO1xyXG4gICAgfTtcclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUud3JpdGVUb2tlbiA9IGZ1bmN0aW9uIChuZXdUb2tlbikge1xyXG4gICAgICAgIGlmIChuZXdUb2tlbikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc3RvcmVUb2tlblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJjb29raWVzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZVRva2VuVG9Db29raWUobmV3VG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlVG9rZW5Ub1dlYlN0b3JhZ2UobmV3VG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRpdmVUb2tlblJlZnJlc2hJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5kaXZlVG9rZW5SZWZyZXNoSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXZlVG9rZW5SZWZyZXNoSW50ZXJ2YWwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5ld1Rva2VuLmV4cGlyZXNfaW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGl2ZVRva2VuUmVmcmVzaEludGVydmFsID0gd2luZG93LnNldEludGVydmFsKHRoaXMucmVmcmVzaFRva2VuLmJpbmQodGhpcyksIChNYXRoLm1heCgxMDAwMCwgbmV3VG9rZW4uZXhwaXJlc19pbiAtIDYwKSAqIDEwMDApKTsgLy8gNjAgc2Vjb25kcyBiZWZvcmUgZXhwaXJhdGlvbiAoaW4gbXMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGl2ZUFQSUNsYXNzLnByb3RvdHlwZS5nYXRoZXJDb21tb25IZWFkZXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSB7fTtcclxuICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbmV3UGFyYW1zW1wiVXNlci1BZ2VudFwiXSA9IFwiZm9vXCI7XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImNvbm5lY3Rpb25cIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBuZXdQYXJhbXMuY29ubmVjdGlvbiA9IFwia2VlcC1hbGl2ZVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyYW1zW1wiYWNjZXB0RW5jb2RpbmdcIl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBuZXdQYXJhbXMuYWNjZXB0RW5jb2RpbmcgPSBcImd6aXAsIGRlZmxhdGVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcmFtc1tcImF1dGhvcml6YXRpb25cIl0gPT0gbnVsbCAmJiB0aGlzLmdldFNhdmVkVG9rZW4oKSkge1xyXG4gICAgICAgICAgICBuZXdQYXJhbXMuYXV0aG9yaXphdGlvbiA9IFwiXCIgKyB0aGlzLmdldFNhdmVkVG9rZW4oKS50b2tlbl90eXBlLnN1YnN0cmluZygwLCAxKS50b1VwcGVyQ2FzZSgpICsgdGhpcy5nZXRTYXZlZFRva2VuKCkudG9rZW5fdHlwZS5zdWJzdHJpbmcoMSkgKyBcIiBcIiArIHRoaXMuZ2V0U2F2ZWRUb2tlbigpLmFjY2Vzc190b2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1BhcmFtcy5hdXRob3JpemF0aW9uID0gXCJCYXNpYyBcIiArIHRoaXMuYXBpS2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyYW1zW1wiYWNjZXB0TGFuZ3VhZ2VcIl0gPT0gbnVsbCAmJiB0aGlzLmxvY2FsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBuZXdQYXJhbXMuYWNjZXB0TGFuZ3VhZ2UgPSB0aGlzLmxvY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCBuZXdQYXJhbXMsIHBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgRGl2ZUFQSUNsYXNzLnByb3RvdHlwZS5kZWxldGVTYXZlZFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdG9yZVRva2VuVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiY29va2llc1wiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVUb2tlbkZyb21Db29raWVzKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlVG9rZW5Gcm9tV2ViU3RvcmFnZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUuaW5pdGlhbGl6ZVRva2VuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgX3RoaXMucmVmcmVzaFRva2VuKClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLnBvc3RUb2tlbkFuZFNhdmUgPSBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRlbGV0ZVNhdmVkVG9rZW4oKTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3UGFyYW1zID0gX19hc3NpZ24oe30sIF90aGlzLmdhdGhlckNvbW1vbkhlYWRlcnMocGFyYW1zKSwgeyBkZXZpY2VJZDogX3RoaXMuZGV2aWNlSWQgfSk7XHJcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gX3RoaXMucG9zdFRva2VuKG5ld1BhcmFtcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QudGhlbihmdW5jdGlvbiAobmV3VG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLndyaXRlVG9rZW4obmV3VG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGl2ZUFQSUNsYXNzLnByb3RvdHlwZS5zeW5jV2l0aE1vdmllVk9EID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yLCBtaXNzaW5nIHBhcmFtZXRlcnMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhcmFtcy5tb3ZpZUlkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yLCBtaXNzaW5nIG1vdmllSWQgcGFyYW1ldGVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhcmFtcy50aW1lc3RhbXApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IsIG1pc3NpbmcgdGltZXN0YW1wIHBhcmFtZXRlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zeW5jV2l0aE1vdmllKHsgbW92aWVJZDogcGFyYW1zLm1vdmllSWQsIHRpbWVzdGFtcDogcGFyYW1zLnRpbWVzdGFtcCwgY2FsbGJhY2tzOiBwYXJhbXMuY2FsbGJhY2tzIH0pO1xyXG4gICAgfTtcclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUuc3luY1dpdGhNb3ZpZVN0cmVhbWluZyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciwgbWlzc2luZyBwYXJhbWV0ZXJzIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwYXJhbXMuY2hhbm5lbElkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yLCBtaXNzaW5nIGNoYW5uZWxJZCBwYXJhbWV0ZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3luY1dpdGhNb3ZpZSh7IGNoYW5uZWxJZDogcGFyYW1zLmNoYW5uZWxJZCwgcHJvdG9jb2w6IHBhcmFtcy5wcm90b2NvbCwgY2FsbGJhY2tzOiBwYXJhbXMuY2FsbGJhY2tzIH0pO1xyXG4gICAgfTtcclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUuc3luY1dpdGhNb3ZpZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yLCBtaXNzaW5nIHBhcmFtZXRlcnMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvdG9jb2wgPSBwYXJhbXMucHJvdG9jb2wgfHwgXCJodHRwc1wiO1xyXG4gICAgICAgIHZhciB1cmwgPSBcInN0cmVhbS5kaXZlLnR2XCI7XHJcbiAgICAgICAgdmFyIHN5bmNUeXBlID0gXCJjaGFubmVsc1wiO1xyXG4gICAgICAgIC8vIGxldCBxdWVyeTogYW55ID0ge3Rva2VuOiBgJHt0aGlzLmdldFNhdmVkVG9rZW4oKS5hY2Nlc3NfdG9rZW59YH07XHJcbiAgICAgICAgdmFyIHF1ZXJ5ID0ge307XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmVudmlyb25tZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVZcIjpcclxuICAgICAgICAgICAgICAgIHVybCA9IHByb3RvY29sICsgXCI6Ly9kZXYtXCIgKyB1cmw7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIlBSRVwiOlxyXG4gICAgICAgICAgICAgICAgdXJsID0gcHJvdG9jb2wgKyBcIjovL3ByZS1cIiArIHVybDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdXJsID0gcHJvdG9jb2wgKyBcIjovL1wiICsgdXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhcmFtcy5jaGFubmVsSWQgJiYgcGFyYW1zLm1vdmllSWQgJiYgcGFyYW1zLnRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICBzeW5jVHlwZSA9IFwibW92aWVzXCI7XHJcbiAgICAgICAgICAgIHF1ZXJ5Lm1vdmllX2lkID0gcGFyYW1zLm1vdmllSWQ7XHJcbiAgICAgICAgICAgIHF1ZXJ5LnRpbWVzdGFtcCA9IHBhcmFtcy50aW1lc3RhbXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWVyeS5jaGFubmVsX2lkID0gcGFyYW1zLmNoYW5uZWxJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXJsICs9IFwiL1wiICsgc3luY1R5cGU7XHJcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBpbyh1cmwsIHtcclxuICAgICAgICAgICAgcGF0aDogXCIvdjEvc3RyZWFtXCIsXHJcbiAgICAgICAgICAgIG11bHRpcGxleDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlY29ubmVjdGlvbjogdHJ1ZSxcclxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxyXG4gICAgICAgICAgICAvLyBmb3JjZU5ldzogdHJ1ZSxcclxuICAgICAgICAgICAgLy8gcmVqZWN0VW5hdXRob3JpemVkOiBmYWxzZSxcclxuICAgICAgICAgICAgLy8gc2VjdXJlOiB0cnVlLFxyXG4gICAgICAgICAgICB0cmFuc3BvcnRzOiBbXCJ3ZWJzb2NrZXRcIl0sXHJcbiAgICAgICAgICAgIGV4dHJhSGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6IHRoaXMubG9jYWxlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5zb2NrZXQuZW1pdCgnYXV0aGVudGljYXRlJywgeyB0b2tlbjogX3RoaXMuZ2V0U2F2ZWRUb2tlbigpLmFjY2Vzc190b2tlbiB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdhdXRoZW50aWNhdGVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhdXRob3JpemVkXCIpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCd1bmF1dGhvcml6ZWQnLCBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVuYXV0aG9yaXplZDogXCIgKyBKU09OLnN0cmluZ2lmeShtc2cuZGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZy5kYXRhLnR5cGUpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTT0NLRVQgZXJyb3JcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5jYWxsYmFja3MgJiYgcGFyYW1zLmNhbGxiYWNrcy5vbkVycm9yIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY2FsbGJhY2tzLm9uRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3ZpZV9zdGFydCcsIGZ1bmN0aW9uIChtb3ZpZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTT0NLRVQgbW92aWVfc3RhcnRcIiwgbW92aWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5jYWxsYmFja3MgJiYgcGFyYW1zLmNhbGxiYWNrcy5vbk1vdmllU3RhcnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jYWxsYmFja3Mub25Nb3ZpZVN0YXJ0KG1vdmllKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW92aWVfZW5kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTT0NLRVQgbW92aWVfZW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5jYWxsYmFja3MgJiYgcGFyYW1zLmNhbGxiYWNrcy5vbk1vdmllRW5kIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY2FsbGJhY2tzLm9uTW92aWVFbmQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignc2NlbmVfc3RhcnQnLCBmdW5jdGlvbiAoc2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU09DS0VUIHNjZW5lX3N0YXJ0XCIsIHNjZW5lKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuY2FsbGJhY2tzICYmIHBhcmFtcy5jYWxsYmFja3Mub25TY2VuZVN0YXJ0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY2FsbGJhY2tzLm9uU2NlbmVTdGFydChzY2VuZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ3NjZW5lX3VwZGF0ZScsIGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTT0NLRVQgc2NlbmVfdXBkYXRlXCIsIHNjZW5lKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuY2FsbGJhY2tzICYmIHBhcmFtcy5jYWxsYmFja3Mub25TY2VuZVVwZGF0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNhbGxiYWNrcy5vblNjZW5lVXBkYXRlKHNjZW5lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignc2NlbmVfZW5kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTT0NLRVQgc2NlbmVfZW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5jYWxsYmFja3MgJiYgcGFyYW1zLmNhbGxiYWNrcy5vblNjZW5lRW5kIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY2FsbGJhY2tzLm9uU2NlbmVFbmQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbigncGF1c2Vfc3RhcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNPQ0tFVCBwYXVzZV9zdGFydFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuY2FsbGJhY2tzICYmIHBhcmFtcy5jYWxsYmFja3Mub25QYXVzZVN0YXJ0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY2FsbGJhY2tzLm9uUGF1c2VTdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdwYXVzZV9lbmQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNPQ0tFVCBwYXVzZV9lbmRcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmNhbGxiYWNrcyAmJiBwYXJhbXMuY2FsbGJhY2tzLm9uUGF1c2VFbmQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jYWxsYmFja3Mub25QYXVzZUVuZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLmNsZWFyU29ja2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNvY2tldCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrZXQuY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5kaXNjb25uZWN0KHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc29ja2V0ID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBEZWxldGUgY2FyZCBsaWtlXHJcbiAgICAqIFJlbW92ZXMgYSBjYXJkIGZyb20gY3VycmVudCB1c2VyJiMzOTtzIGxpa2VzIGxpc3RcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2FyZElkIFJlcXVlc3RlZCBjYXJkIElEXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqL1xyXG4gICAgRGl2ZUFQSUNsYXNzLnByb3RvdHlwZS5kZWxldGVMaWtlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdQYXJhbXMgPSBfdGhpcy5nYXRoZXJDb21tb25IZWFkZXJzKHBhcmFtcyk7XHJcbiAgICAgICAgICAgIGV4cG9ydHMuRGVmYXVsdEFwaUZwLmRlbGV0ZUxpa2VzKG5ld1BhcmFtcywgb3B0aW9ucykoX3RoaXMuZmV0Y2gsIF90aGlzLmJhc2VQYXRoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIlYyBSRVNUIGVycm9yIC0gZGVsZXRlTGlrZXNcIiwgXCJiYWNrZ3JvdW5kOiBibGFjazsgY29sb3I6ICNGRTJFRjc7IHBhZGRpbmc6IDAgMTBweDtcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDAxICYmIF90aGlzLnNlcnZpY2VSZXF1aXJlc1Rva2VuKFwiZGVsZXRlTGlrZXNcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZyZXNoVG9rZW4oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wb3N0VG9rZW5BbmRTYXZlKHsgZ3JhbnRUeXBlOiBcImRldmljZV9jcmVkZW50aWFsc1wiLCBkZXZpY2VJZDogX3RoaXMuZGV2aWNlSWQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbXMgPSBfdGhpcy5nYXRoZXJDb21tb25IZWFkZXJzKHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5kZWxldGVMaWtlcyhuZXdQYXJhbXMsIG9wdGlvbnMpKF90aGlzLmZldGNoLCBfdGhpcy5iYXNlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvclJlZnJlc2hpbmdUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JSZWZyZXNoaW5nVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAqIEZ1bGwgY2FyZCBkZXRhaWxcclxuICAgICogUmV0cmlldmVzIGEgZnVsbCBjYXJkIGRldGFpbCwgd2l0aCBubyByZWxhdGlvbnMgb3IgY29udGV4dFxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjYXJkSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgY2FyZFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKiBAcGFyYW0gcHJvZHVjdHMgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIGNvbW1lcmNpYWwgcHJvZHVjdHMgd2hlbiBhdmFpbGFibGUgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAqIEBwYXJhbSB1c2VyRGF0YSBJbmRpY2F0ZXMgaWYgY2FyZHMgc2hvdWxkIGNvbnRhaW4gdXNlciBkYXRhIHdoZW4gYXZhaWxhYmxlICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICovXHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLmdldENhcmQgPSBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRDYXJkKG5ld1BhcmFtcywgb3B0aW9ucykoX3RoaXMuZmV0Y2gsIF90aGlzLmJhc2VQYXRoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIlYyBSRVNUIGVycm9yIC0gZ2V0Q2FyZFwiLCBcImJhY2tncm91bmQ6IGJsYWNrOyBjb2xvcjogI0ZFMkVGNzsgcGFkZGluZzogMCAxMHB4O1wiLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDEgJiYgX3RoaXMuc2VydmljZVJlcXVpcmVzVG9rZW4oXCJnZXRDYXJkXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmcmVzaFRva2VuKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucG9zdFRva2VuQW5kU2F2ZSh7IGdyYW50VHlwZTogXCJkZXZpY2VfY3JlZGVudGlhbHNcIiwgZGV2aWNlSWQ6IF90aGlzLmRldmljZUlkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0Q2FyZChuZXdQYXJhbXMsIG9wdGlvbnMpKF90aGlzLmZldGNoLCBfdGhpcy5iYXNlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvclJlZnJlc2hpbmdUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JSZWZyZXNoaW5nVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAqIEZ1bGwgY2FyZCBkZXRhaWwgd2l0aCB2ZXJzaW9uXHJcbiAgICAqIFJldHJpZXZlcyBhIGZ1bGwgY2FyZCBkZXRhaWwsIGFuZCBpdHMgcmVsYXRpb25zIHRvIG90aGVyIGNhcmRzIGluIGEgZ2l2ZW4gY29udGV4dCAoY2FyZCB2ZXJzaW9uKVxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjYXJkSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgY2FyZFxyXG4gICAgKiBAcGFyYW0gdmVyc2lvbiBWZXJzaW9uIGlkZW50aWZpZXIsIGluZGljYXRlcyB0aGUgY29udGV4dCB3aGVyZSB0aGUgY2FyZCBpcyBiZWluZyByZXF1ZXN0ZWRcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICogQHBhcmFtIHByb2R1Y3RzIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiBjb21tZXJjaWFsIHByb2R1Y3RzIHdoZW4gYXZhaWxhYmxlICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgKiBAcGFyYW0gdXNlckRhdGEgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIHVzZXIgZGF0YSB3aGVuIGF2YWlsYWJsZSAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuICAgICogQHBhcmFtIHJlbGF0aW9ucyBJbmRpY2F0ZXMgaWYgY2FyZHMgc2hvdWxkIGNvbnRhaW4gdGhlIHNjZW5lIGhpZXJhcmNoeSAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuICAgICogQHBhcmFtIGltYWdlU2l6ZSBTaXplIG9mIHRoZSBpbWFnZXMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAqL1xyXG4gICAgRGl2ZUFQSUNsYXNzLnByb3RvdHlwZS5nZXRDYXJkVmVyc2lvbiA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdQYXJhbXMgPSBfdGhpcy5nYXRoZXJDb21tb25IZWFkZXJzKHBhcmFtcyk7XHJcbiAgICAgICAgICAgIGV4cG9ydHMuRGVmYXVsdEFwaUZwLmdldENhcmRWZXJzaW9uKG5ld1BhcmFtcywgb3B0aW9ucykoX3RoaXMuZmV0Y2gsIF90aGlzLmJhc2VQYXRoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIlYyBSRVNUIGVycm9yIC0gZ2V0Q2FyZFZlcnNpb25cIiwgXCJiYWNrZ3JvdW5kOiBibGFjazsgY29sb3I6ICNGRTJFRjc7IHBhZGRpbmc6IDAgMTBweDtcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDAxICYmIF90aGlzLnNlcnZpY2VSZXF1aXJlc1Rva2VuKFwiZ2V0Q2FyZFZlcnNpb25cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZyZXNoVG9rZW4oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wb3N0VG9rZW5BbmRTYXZlKHsgZ3JhbnRUeXBlOiBcImRldmljZV9jcmVkZW50aWFsc1wiLCBkZXZpY2VJZDogX3RoaXMuZGV2aWNlSWQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbXMgPSBfdGhpcy5nYXRoZXJDb21tb25IZWFkZXJzKHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRDYXJkVmVyc2lvbihuZXdQYXJhbXMsIG9wdGlvbnMpKF90aGlzLmZldGNoLCBfdGhpcy5iYXNlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvclJlZnJlc2hpbmdUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JSZWZyZXNoaW5nVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAqIE1vdmllIGNhdGFsb2cgaW5mb1xyXG4gICAgKiBSZXRyaWV2ZXMgYSBtb3ZpZSYjMzk7cyBmdWxsIGNhcmQgYnkgaXRzIGNsaWVudCBJRCwgaW5jbHVkaW5nIGNhdGFsb2cgYW5kIGNhc3QgaW5mb3JtYXRpb25cclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2xpZW50TW92aWVJZCBDbGllbnQgbW92aWUgSUQgYmVpbmcgcGxheWVkXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUuZ2V0Q2F0YWxvZ01vdmllID0gZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1BhcmFtcyA9IF90aGlzLmdhdGhlckNvbW1vbkhlYWRlcnMocGFyYW1zKTtcclxuICAgICAgICAgICAgZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0Q2F0YWxvZ01vdmllKG5ld1BhcmFtcywgb3B0aW9ucykoX3RoaXMuZmV0Y2gsIF90aGlzLmJhc2VQYXRoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIlYyBSRVNUIGVycm9yIC0gZ2V0Q2F0YWxvZ01vdmllXCIsIFwiYmFja2dyb3VuZDogYmxhY2s7IGNvbG9yOiAjRkUyRUY3OyBwYWRkaW5nOiAwIDEwcHg7XCIsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQwMSAmJiBfdGhpcy5zZXJ2aWNlUmVxdWlyZXNUb2tlbihcImdldENhdGFsb2dNb3ZpZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZnJlc2hUb2tlbigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBvc3RUb2tlbkFuZFNhdmUoeyBncmFudFR5cGU6IFwiZGV2aWNlX2NyZWRlbnRpYWxzXCIsIGRldmljZUlkOiBfdGhpcy5kZXZpY2VJZCB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtcyA9IF90aGlzLmdhdGhlckNvbW1vbkhlYWRlcnMocGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuRGVmYXVsdEFwaUZwLmdldENhdGFsb2dNb3ZpZShuZXdQYXJhbXMsIG9wdGlvbnMpKF90aGlzLmZldGNoLCBfdGhpcy5iYXNlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvclJlZnJlc2hpbmdUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JSZWZyZXNoaW5nVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAqIENoYW5uZWwgZXZlbnRzIGdyaWRcclxuICAgICogUmV0dXJucyB0aGUgY3VycmVudCBhbmQgdXBjb21pbmcgZ3JpZCBvZiBUViBldmVudHMgZm9yIHRoZSBnaXZlbiBjaGFubmVsXHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNoYW5uZWxJZCBDbGllbnQgY2hhbm5lbCBJRFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICovXHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLmdldENoYW5uZWxHcmlkID0gZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1BhcmFtcyA9IF90aGlzLmdhdGhlckNvbW1vbkhlYWRlcnMocGFyYW1zKTtcclxuICAgICAgICAgICAgZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0Q2hhbm5lbEdyaWQobmV3UGFyYW1zLCBvcHRpb25zKShfdGhpcy5mZXRjaCwgX3RoaXMuYmFzZVBhdGgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiVjIFJFU1QgZXJyb3IgLSBnZXRDaGFubmVsR3JpZFwiLCBcImJhY2tncm91bmQ6IGJsYWNrOyBjb2xvcjogI0ZFMkVGNzsgcGFkZGluZzogMCAxMHB4O1wiLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDEgJiYgX3RoaXMuc2VydmljZVJlcXVpcmVzVG9rZW4oXCJnZXRDaGFubmVsR3JpZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZnJlc2hUb2tlbigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBvc3RUb2tlbkFuZFNhdmUoeyBncmFudFR5cGU6IFwiZGV2aWNlX2NyZWRlbnRpYWxzXCIsIGRldmljZUlkOiBfdGhpcy5kZXZpY2VJZCB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtcyA9IF90aGlzLmdhdGhlckNvbW1vbkhlYWRlcnMocGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuRGVmYXVsdEFwaUZwLmdldENoYW5uZWxHcmlkKG5ld1BhcmFtcywgb3B0aW9ucykoX3RoaXMuZmV0Y2gsIF90aGlzLmJhc2VQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yUmVmcmVzaGluZ1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvclJlZnJlc2hpbmdUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICogQ2hhbm5lbCBtb3ZpZSBjYXRhbG9nIGluZm9cclxuICAgICogUmV0cmlldmVzIGZ1bGwgY2FyZCBkZXRhaWwsIGluY2x1ZGluZyBjYXRhbG9nIGFuZCBjYXN0IGluZm9ybWF0aW9uLCBmb3IgdGhlIGNvbnRlbnQgY3VycmVudGx5IGJlaW5nIGJyb2FkY2FzdGVkIG9uIHRoZSBjaGFubmVsXHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNoYW5uZWxJZCBDbGllbnQgY2hhbm5lbCBJRFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICovXHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLmdldENoYW5uZWxNb3ZpZSA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdQYXJhbXMgPSBfdGhpcy5nYXRoZXJDb21tb25IZWFkZXJzKHBhcmFtcyk7XHJcbiAgICAgICAgICAgIGV4cG9ydHMuRGVmYXVsdEFwaUZwLmdldENoYW5uZWxNb3ZpZShuZXdQYXJhbXMsIG9wdGlvbnMpKF90aGlzLmZldGNoLCBfdGhpcy5iYXNlUGF0aClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJWMgUkVTVCBlcnJvciAtIGdldENoYW5uZWxNb3ZpZVwiLCBcImJhY2tncm91bmQ6IGJsYWNrOyBjb2xvcjogI0ZFMkVGNzsgcGFkZGluZzogMCAxMHB4O1wiLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDEgJiYgX3RoaXMuc2VydmljZVJlcXVpcmVzVG9rZW4oXCJnZXRDaGFubmVsTW92aWVcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZyZXNoVG9rZW4oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wb3N0VG9rZW5BbmRTYXZlKHsgZ3JhbnRUeXBlOiBcImRldmljZV9jcmVkZW50aWFsc1wiLCBkZXZpY2VJZDogX3RoaXMuZGV2aWNlSWQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbXMgPSBfdGhpcy5nYXRoZXJDb21tb25IZWFkZXJzKHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRDaGFubmVsTW92aWUobmV3UGFyYW1zLCBvcHRpb25zKShfdGhpcy5mZXRjaCwgX3RoaXMuYmFzZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3JSZWZyZXNoaW5nVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yUmVmcmVzaGluZ1Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBHZXQgY2FyZCBsaWtlc1xyXG4gICAgKiBSZXR1cm5zIGEgcGFnaW5hdGVkIGxpc3Qgb2YgY2FyZHMgbGlrZWQgYnkgY3VycmVudCB1c2VyXHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICogQHBhcmFtIGltYWdlU2l6ZSBTaXplIG9mIHRoZSBpbWFnZXMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAqIEBwYXJhbSBwYWdpbmF0ZUtleSBQYWdpbmF0ZSBrZXlcclxuICAgICogQHBhcmFtIHNpemUgTnVtYmVyIG9mIGRlc2lyZWQgcmVzdWx0c1xyXG4gICAgKi9cclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUuZ2V0TGlrZXMgPSBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRMaWtlcyhuZXdQYXJhbXMsIG9wdGlvbnMpKF90aGlzLmZldGNoLCBfdGhpcy5iYXNlUGF0aClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJWMgUkVTVCBlcnJvciAtIGdldExpa2VzXCIsIFwiYmFja2dyb3VuZDogYmxhY2s7IGNvbG9yOiAjRkUyRUY3OyBwYWRkaW5nOiAwIDEwcHg7XCIsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQwMSAmJiBfdGhpcy5zZXJ2aWNlUmVxdWlyZXNUb2tlbihcImdldExpa2VzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmcmVzaFRva2VuKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucG9zdFRva2VuQW5kU2F2ZSh7IGdyYW50VHlwZTogXCJkZXZpY2VfY3JlZGVudGlhbHNcIiwgZGV2aWNlSWQ6IF90aGlzLmRldmljZUlkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0TGlrZXMobmV3UGFyYW1zLCBvcHRpb25zKShfdGhpcy5mZXRjaCwgX3RoaXMuYmFzZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3JSZWZyZXNoaW5nVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yUmVmcmVzaGluZ1Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBDaGFubmVsIHN5bmMgYXZhaWxhYmlsaXR5XHJcbiAgICAqIENoZWNrcyBpZiBhIGxpc3Qgb2YgY2xpZW50IGNoYW5uZWwgaWRlbnRpZmllcnMgYXJlIGN1cnJlbnRseSBicm9hZGNhc3Rpbmcgc3luY2hyb25pemFibGUgY29udGVudFxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjaGFubmVsSWRMaXN0IExpc3Qgb2YgY2xpZW50IGNoYW5uZWwgSURzIGFzIGEgY29tbWEgc2VwYXJhdGVkIGxpc3RcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICovXHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLmdldFJlYWR5Q2hhbm5lbHMgPSBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRSZWFkeUNoYW5uZWxzKG5ld1BhcmFtcywgb3B0aW9ucykoX3RoaXMuZmV0Y2gsIF90aGlzLmJhc2VQYXRoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIlYyBSRVNUIGVycm9yIC0gZ2V0UmVhZHlDaGFubmVsc1wiLCBcImJhY2tncm91bmQ6IGJsYWNrOyBjb2xvcjogI0ZFMkVGNzsgcGFkZGluZzogMCAxMHB4O1wiLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDEgJiYgX3RoaXMuc2VydmljZVJlcXVpcmVzVG9rZW4oXCJnZXRSZWFkeUNoYW5uZWxzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmcmVzaFRva2VuKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucG9zdFRva2VuQW5kU2F2ZSh7IGdyYW50VHlwZTogXCJkZXZpY2VfY3JlZGVudGlhbHNcIiwgZGV2aWNlSWQ6IF90aGlzLmRldmljZUlkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0UmVhZHlDaGFubmVscyhuZXdQYXJhbXMsIG9wdGlvbnMpKF90aGlzLmZldGNoLCBfdGhpcy5iYXNlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvclJlZnJlc2hpbmdUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JSZWZyZXNoaW5nVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAqIE1vdmllIHN5bmMgYXZhaWxhYmlsaXR5XHJcbiAgICAqIENoZWNrcyB3aGV0aGVyIGEgbGlzdCBvZiBjbGllbnQgbW92aWUgaWRlbnRpZmllcnMgKFZpZGVvIE9uIERlbWFuZCkgYXJlIGF2YWlsYWJsZSB0byBiZSBzeW5jaHJvbml6ZWQgdXNpbmcgdGhlIERpdmUgQVBJXHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmVhcmVyICZsdDt0b2tlbiZndDsmIzM5OylcclxuICAgICogQHBhcmFtIGNsaWVudE1vdmllSWRMaXN0IExpc3Qgb2YgY2xpZW50IG1vdmllIElEcywgcHJvdmlkZWQgYXMgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdFxyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKi9cclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUuZ2V0UmVhZHlNb3ZpZXMgPSBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRSZWFkeU1vdmllcyhuZXdQYXJhbXMsIG9wdGlvbnMpKF90aGlzLmZldGNoLCBfdGhpcy5iYXNlUGF0aClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJWMgUkVTVCBlcnJvciAtIGdldFJlYWR5TW92aWVzXCIsIFwiYmFja2dyb3VuZDogYmxhY2s7IGNvbG9yOiAjRkUyRUY3OyBwYWRkaW5nOiAwIDEwcHg7XCIsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQwMSAmJiBfdGhpcy5zZXJ2aWNlUmVxdWlyZXNUb2tlbihcImdldFJlYWR5TW92aWVzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmcmVzaFRva2VuKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucG9zdFRva2VuQW5kU2F2ZSh7IGdyYW50VHlwZTogXCJkZXZpY2VfY3JlZGVudGlhbHNcIiwgZGV2aWNlSWQ6IF90aGlzLmRldmljZUlkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0UmVhZHlNb3ZpZXMobmV3UGFyYW1zLCBvcHRpb25zKShfdGhpcy5mZXRjaCwgX3RoaXMuYmFzZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3JSZWZyZXNoaW5nVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yUmVmcmVzaGluZ1Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBTdGF0aWMgY2hhbm5lbCBzY2VuZVxyXG4gICAgKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgY2FyZHMgcmVsYXRlZCB0byB0aGUgY29udGVudCBjdXJyZW50bHkgYmVpbmcgYnJvYWRjYXN0ZWQgaW4gdGhlIHByb3ZpZGVkIGNoYW5uZWxcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2hhbm5lbElkIENsaWVudCBjaGFubmVsIElEXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSByZWxhdGlvbnMgSW5kaWNhdGVzIGlmIGNhcmRzIHNob3VsZCBjb250YWluIHRoZSBzY2VuZSBoaWVyYXJjaHkgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcbiAgICAqIEBwYXJhbSBpbWFnZVNpemUgU2l6ZSBvZiB0aGUgaW1hZ2VzIHJldHVybmVkIGluIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUuZ2V0U3RhdGljQ2hhbm5lbFNjZW5lID0gZnVuY3Rpb24gKHBhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1BhcmFtcyA9IF90aGlzLmdhdGhlckNvbW1vbkhlYWRlcnMocGFyYW1zKTtcclxuICAgICAgICAgICAgZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0U3RhdGljQ2hhbm5lbFNjZW5lKG5ld1BhcmFtcywgb3B0aW9ucykoX3RoaXMuZmV0Y2gsIF90aGlzLmJhc2VQYXRoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIlYyBSRVNUIGVycm9yIC0gZ2V0U3RhdGljQ2hhbm5lbFNjZW5lXCIsIFwiYmFja2dyb3VuZDogYmxhY2s7IGNvbG9yOiAjRkUyRUY3OyBwYWRkaW5nOiAwIDEwcHg7XCIsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQwMSAmJiBfdGhpcy5zZXJ2aWNlUmVxdWlyZXNUb2tlbihcImdldFN0YXRpY0NoYW5uZWxTY2VuZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZnJlc2hUb2tlbigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBvc3RUb2tlbkFuZFNhdmUoeyBncmFudFR5cGU6IFwiZGV2aWNlX2NyZWRlbnRpYWxzXCIsIGRldmljZUlkOiBfdGhpcy5kZXZpY2VJZCB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtcyA9IF90aGlzLmdhdGhlckNvbW1vbkhlYWRlcnMocGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuRGVmYXVsdEFwaUZwLmdldFN0YXRpY0NoYW5uZWxTY2VuZShuZXdQYXJhbXMsIG9wdGlvbnMpKF90aGlzLmZldGNoLCBfdGhpcy5iYXNlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvclJlZnJlc2hpbmdUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JSZWZyZXNoaW5nVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAqIFN0YXRpYyBWT0Qgc2NlbmVcclxuICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IGxpc3Qgb2YgY2FyZHMgcmVsYXRlZCB0byB0aGUgZ2l2ZW4gbW92aWUgc2NlbmVcclxuICAgICogQHBhcmFtIGF1dGhvcml6YXRpb24gQXV0aG9yaXphdGlvbiB0b2tlbiAoJiMzOTtCZWFyZXIgJmx0O3Rva2VuJmd0OyYjMzk7KVxyXG4gICAgKiBAcGFyYW0gY2xpZW50TW92aWVJZCBDbGllbnQgbW92aWUgSUQgYmVpbmcgcGxheWVkXHJcbiAgICAqIEBwYXJhbSB0aW1lc3RhbXAgQ3VycmVudCBtb3ZpZSB0aW1lc3RhbXAgaW4gc2Vjb25kc1xyXG4gICAgKiBAcGFyYW0gYWNjZXB0TGFuZ3VhZ2UgQ2xpZW50IGxvY2FsZSwgYXMgbGFuZ3VhZ2UtY291bnRyeVxyXG4gICAgKiBAcGFyYW0gcmVsYXRpb25zIEluZGljYXRlcyBpZiBjYXJkcyBzaG91bGQgY29udGFpbiB0aGUgc2NlbmUgaGllcmFyY2h5ICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG4gICAgKiBAcGFyYW0gaW1hZ2VTaXplIFNpemUgb2YgdGhlIGltYWdlcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2VcclxuICAgICovXHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLmdldFN0YXRpY01vdmllU2NlbmUgPSBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICBleHBvcnRzLkRlZmF1bHRBcGlGcC5nZXRTdGF0aWNNb3ZpZVNjZW5lKG5ld1BhcmFtcywgb3B0aW9ucykoX3RoaXMuZmV0Y2gsIF90aGlzLmJhc2VQYXRoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIlYyBSRVNUIGVycm9yIC0gZ2V0U3RhdGljTW92aWVTY2VuZVwiLCBcImJhY2tncm91bmQ6IGJsYWNrOyBjb2xvcjogI0ZFMkVGNzsgcGFkZGluZzogMCAxMHB4O1wiLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDEgJiYgX3RoaXMuc2VydmljZVJlcXVpcmVzVG9rZW4oXCJnZXRTdGF0aWNNb3ZpZVNjZW5lXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmcmVzaFRva2VuKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucG9zdFRva2VuQW5kU2F2ZSh7IGdyYW50VHlwZTogXCJkZXZpY2VfY3JlZGVudGlhbHNcIiwgZGV2aWNlSWQ6IF90aGlzLmRldmljZUlkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAuZ2V0U3RhdGljTW92aWVTY2VuZShuZXdQYXJhbXMsIG9wdGlvbnMpKF90aGlzLmZldGNoLCBfdGhpcy5iYXNlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvclJlZnJlc2hpbmdUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JSZWZyZXNoaW5nVG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAqIEFkZCBjYXJkIGxpa2VcclxuICAgICogU3RvcmVzIGEgY2FyZCB1bmRlciBjdXJyZW50IHVzZXImIzM5O3MgbGlrZXMgbGlzdFxyXG4gICAgKiBAcGFyYW0gYXV0aG9yaXphdGlvbiBBdXRob3JpemF0aW9uIHRva2VuICgmIzM5O0JlYXJlciAmbHQ7dG9rZW4mZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBjYXJkSWQgUmVxdWVzdGVkIGNhcmQgSURcclxuICAgICogQHBhcmFtIGFjY2VwdExhbmd1YWdlIENsaWVudCBsb2NhbGUsIGFzIGxhbmd1YWdlLWNvdW50cnlcclxuICAgICovXHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLnBvc3RMaWtlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdQYXJhbXMgPSBfdGhpcy5nYXRoZXJDb21tb25IZWFkZXJzKHBhcmFtcyk7XHJcbiAgICAgICAgICAgIGV4cG9ydHMuRGVmYXVsdEFwaUZwLnBvc3RMaWtlcyhuZXdQYXJhbXMsIG9wdGlvbnMpKF90aGlzLmZldGNoLCBfdGhpcy5iYXNlUGF0aClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJWMgUkVTVCBlcnJvciAtIHBvc3RMaWtlc1wiLCBcImJhY2tncm91bmQ6IGJsYWNrOyBjb2xvcjogI0ZFMkVGNzsgcGFkZGluZzogMCAxMHB4O1wiLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSA0MDEgJiYgX3RoaXMuc2VydmljZVJlcXVpcmVzVG9rZW4oXCJwb3N0TGlrZXNcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZyZXNoVG9rZW4oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wb3N0VG9rZW5BbmRTYXZlKHsgZ3JhbnRUeXBlOiBcImRldmljZV9jcmVkZW50aWFsc1wiLCBkZXZpY2VJZDogX3RoaXMuZGV2aWNlSWQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbXMgPSBfdGhpcy5nYXRoZXJDb21tb25IZWFkZXJzKHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRlZmF1bHRBcGlGcC5wb3N0TGlrZXMobmV3UGFyYW1zLCBvcHRpb25zKShfdGhpcy5mZXRjaCwgX3RoaXMuYmFzZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3JSZWZyZXNoaW5nVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yUmVmcmVzaGluZ1Rva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgKiBUb2tlbiBlbmRwb2ludFxyXG4gICAgKiBUaGUgdG9rZW4gZW5kcG9pbnQgaXMgdXNlZCB0byBvYnRhaW4gYWNjZXNzIHRva2VucyB3aGljaCBhbGxvdyBjbGllbnRzIHRvIG1ha2UgQVBJIHJlcXVlc3RzXHJcbiAgICAqIEBwYXJhbSBhdXRob3JpemF0aW9uIEJhc2ljIGF1dGhvcml6YXRpb24gdG9rZW4gKCYjMzk7QmFzaWMgJmx0O2NsaWVudF9rZXkmZ3Q7JiMzOTspXHJcbiAgICAqIEBwYXJhbSBncmFudFR5cGUgR3JhbnQgdHlwZSB1c2VkIHRvIG9idGFpbiB0aGUgdG9rZW4uXHJcbiAgICAqIEBwYXJhbSBhY2NlcHRMYW5ndWFnZSBDbGllbnQgbG9jYWxlLCBhcyBsYW5ndWFnZS1jb3VudHJ5XHJcbiAgICAqIEBwYXJhbSBkZXZpY2VJZCBEZXZpY2UgaWRlbnRpZmllciwgbXVzdCB1bmlxdWVseSBpZGVudGlmeSB0aGUgdXNlciBvciBkZXZpY2UgYWNjZXNzaW5nIHRoZSBBUEkuIFJlcXVpcmVkIG9ubHkgZm9yIFxcJnF1b3Q7ZGV2aWNlX2NyZWRlbnRpYWxzXFwmcXVvdDsgZ3JhbnQgdHlwZVxyXG4gICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIFJlZnJlc2ggdG9rZW4sIHVzZWQgdG8gaXNzdWUgYSBuZXcgdG9rZW4gd2l0aG91dCByZXNlbmRpbmcgY2xpZW50IGNyZWRlbnRpYWxzLiBSZXF1aXJlZCBvbmx5IGZvciBcXCZxdW90O3JlZnJlc2hfdG9rZW5cXCZxdW90OyBncmFudCB0eXBlXHJcbiAgICAqL1xyXG4gICAgRGl2ZUFQSUNsYXNzLnByb3RvdHlwZS5wb3N0VG9rZW4gPSBmdW5jdGlvbiAocGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICBleHBvcnRzLkRlZmF1bHRBcGlGcC5wb3N0VG9rZW4obmV3UGFyYW1zLCBvcHRpb25zKShfdGhpcy5mZXRjaCwgX3RoaXMuYmFzZVBhdGgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiVjIFJFU1QgZXJyb3IgLSBwb3N0VG9rZW5cIiwgXCJiYWNrZ3JvdW5kOiBibGFjazsgY29sb3I6ICNGRTJFRjc7IHBhZGRpbmc6IDAgMTBweDtcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDAxICYmIF90aGlzLnNlcnZpY2VSZXF1aXJlc1Rva2VuKFwicG9zdFRva2VuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmcmVzaFRva2VuKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucG9zdFRva2VuQW5kU2F2ZSh7IGdyYW50VHlwZTogXCJkZXZpY2VfY3JlZGVudGlhbHNcIiwgZGV2aWNlSWQ6IF90aGlzLmRldmljZUlkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zID0gX3RoaXMuZ2F0aGVyQ29tbW9uSGVhZGVycyhwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0QXBpRnAucG9zdFRva2VuKG5ld1BhcmFtcywgb3B0aW9ucykoX3RoaXMuZmV0Y2gsIF90aGlzLmJhc2VQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yUmVmcmVzaGluZ1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvclJlZnJlc2hpbmdUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLnNlcnZpY2VSZXF1aXJlc1Rva2VuID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub0F1dGhTZXJ2aWNlcy5pbmRleE9mKG1ldGhvZE5hbWUpID09PSAtMTtcclxuICAgIH07XHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLndyaXRlVG9rZW5Ub0Nvb2tpZSA9IGZ1bmN0aW9uIChuZXdUb2tlbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldENvb2tpZShcImRpdmVfdG9rZW5cIiwgSlNPTi5zdHJpbmdpZnkobmV3VG9rZW4pLCBuZXdUb2tlbi5leHBpcmVzX2luKTtcclxuICAgIH07XHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLndyaXRlVG9rZW5Ub1dlYlN0b3JhZ2UgPSBmdW5jdGlvbiAobmV3VG9rZW4pIHtcclxuICAgICAgICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkge1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJkaXZlX3Rva2VuXCIsIEpTT04uc3RyaW5naWZ5KG5ld1Rva2VuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUucmVmcmVzaFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXJyVG9rZW4gPSB0aGlzLmdldFNhdmVkVG9rZW4oKTtcclxuICAgICAgICB2YXIgYXV0aCA9IFwiQmFzaWMgXCIgKyB0aGlzLmFwaUtleTtcclxuICAgICAgICBpZiAoY3VyclRva2VuICYmIGN1cnJUb2tlbi5yZWZyZXNoX3Rva2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc3RUb2tlbkFuZFNhdmUoeyBncmFudFR5cGU6IFwicmVmcmVzaF90b2tlblwiLCByZWZyZXNoVG9rZW46IGN1cnJUb2tlbi5yZWZyZXNoX3Rva2VuIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zdFRva2VuQW5kU2F2ZSh7IGdyYW50VHlwZTogXCJkZXZpY2VfY3JlZGVudGlhbHNcIiwgZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUuc2V0Q29va2llID0gZnVuY3Rpb24gKGNuYW1lLCBjdmFsdWUsIGV4ZGF5cykge1xyXG4gICAgICAgIHZhciBkID0gbmV3IERhdGUoKTtcclxuICAgICAgICBkLnNldFRpbWUoZC5nZXRUaW1lKCkgKyAoZXhkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xyXG4gICAgICAgIHZhciBleHBpcmVzID0gXCJleHBpcmVzPVwiICsgZC50b1VUQ1N0cmluZygpO1xyXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNuYW1lICsgXCI9XCIgKyBjdmFsdWUgKyBcIjtcIiArIGV4cGlyZXMgKyBcIjtwYXRoPS9cIjtcclxuICAgIH07XHJcbiAgICBEaXZlQVBJQ2xhc3MucHJvdG90eXBlLmdldENvb2tpZSA9IGZ1bmN0aW9uIChjbmFtZSkge1xyXG4gICAgICAgIHZhciBuYW1lID0gY25hbWUgKyBcIj1cIjtcclxuICAgICAgICB2YXIgZGVjb2RlZENvb2tpZSA9IGRlY29kZVVSSUNvbXBvbmVudChkb2N1bWVudC5jb29raWUpO1xyXG4gICAgICAgIHZhciBjYSA9IGRlY29kZWRDb29raWUuc3BsaXQoJzsnKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gY2FbaV07XHJcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PSAnICcpIHtcclxuICAgICAgICAgICAgICAgIGMgPSBjLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYy5pbmRleE9mKG5hbWUpID09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lLmxlbmd0aCwgYy5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfTtcclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUuZ2V0VG9rZW5Gcm9tQ29va2llcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmdldENvb2tpZShcImRpdmVfdG9rZW5cIik7XHJcbiAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUuZ2V0VG9rZW5Gcm9tV2ViU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImRpdmVfdG9rZW5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGl2ZUFQSUNsYXNzLnByb3RvdHlwZS5kZWxldGVUb2tlbkZyb21XZWJTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcImRpdmVfdG9rZW5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERpdmVBUElDbGFzcy5wcm90b3R5cGUuZGVsZXRlVG9rZW5Gcm9tQ29va2llcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IFwiZGl2ZV90b2tlblwiO1xyXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IG5hbWUgKyAnPTtleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDEgR01UOyc7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERpdmVBUElDbGFzcztcclxufShEZWZhdWx0QXBpKSk7XHJcbmV4cG9ydHMuRGl2ZUFQSUNsYXNzID0gRGl2ZUFQSUNsYXNzO1xyXG5cblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuXG52YXIgcHVueWNvZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKG1vZHVsZSwgZ2xvYmFsKSB7dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHRydWVcblx0KSB7XG5cdFx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KShtb2R1bGUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gdGhlIHdoYXR3Zy1mZXRjaCBwb2x5ZmlsbCBpbnN0YWxscyB0aGUgZmV0Y2goKSBmdW5jdGlvblxuLy8gb24gdGhlIGdsb2JhbCBvYmplY3QgKHdpbmRvdyBvciBzZWxmKVxuLy9cbi8vIFJldHVybiB0aGF0IGFzIHRoZSBleHBvcnQgZm9yIHVzZSBpbiBXZWJwYWNrLCBCcm93c2VyaWZ5IGV0Yy5cbl9fd2VicGFja19yZXF1aXJlX18oMzgpO1xubW9kdWxlLmV4cG9ydHMgPSBzZWxmLmZldGNoLmJpbmQoc2VsZik7XG5cblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4oZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXVxuXG4gICAgdmFyIGlzRGF0YVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICAgIH1cblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgICAgfSwgdGhpcylcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IGl0ZW1zLnB1c2godmFsdWUpIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgcmF3SGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSAnc3RhdHVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiAyMDBcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuXG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xudmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG4gIHZhciBpbztcblxuICBpZiAobmV3Q29ubmVjdGlvbikge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuICBpZiAocGFyc2VkLnF1ZXJ5ICYmICFvcHRzLnF1ZXJ5KSB7XG4gICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeTtcbiAgfVxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuZXhwb3J0cy5Tb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbnZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1cmw7XG5cbi8qKlxuICogVVJMIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHVybCAodXJpLCBsb2MpIHtcbiAgdmFyIG9iaiA9IHVyaTtcblxuICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuICBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdXJpKSB7XG4gICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgwKSkge1xuICAgICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGxvYykge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZVxuICAgIGRlYnVnKCdwYXJzZSAlcycsIHVyaSk7XG4gICAgb2JqID0gcGFyc2V1cmkodXJpKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuICBpZiAoIW9iai5wb3J0KSB7XG4gICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc4MCc7XG4gICAgfSBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG4gICAgfVxuICB9XG5cbiAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cbiAgdmFyIGlwdjYgPSBvYmouaG9zdC5pbmRleE9mKCc6JykgIT09IC0xO1xuICB2YXIgaG9zdCA9IGlwdjYgPyAnWycgKyBvYmouaG9zdCArICddJyA6IG9iai5ob3N0O1xuXG4gIC8vIGRlZmluZSB1bmlxdWUgaWRcbiAgb2JqLmlkID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgJzonICsgb2JqLnBvcnQ7XG4gIC8vIGRlZmluZSBocmVmXG4gIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG5cblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xudmFyIGlzQnVmID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIGdsb2JhbC5CbG9iID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBnbG9iYWwuRmlsZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0cmluZy5jYWxsKGdsb2JhbC5GaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbmZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKCh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblxuLyoqKi8gfSksXG4vKiA0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG52YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG52YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBwYXJzZXVyaSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xudmFyIHBhcnNlanNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xudmFyIHBhcnNlcXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKHVyaSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodXJpICYmICdvYmplY3QnID09PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuICB9XG5cbiAgdGhpcy5zZWN1cmUgPSBudWxsICE9IG9wdHMuc2VjdXJlID8gb3B0cy5zZWN1cmVcbiAgICA6IChnbG9iYWwubG9jYXRpb24gJiYgJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuICB9XG5cbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG4gICAgKGdsb2JhbC5sb2NhdGlvbiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0XG4gICAgICA/IGxvY2F0aW9uLnBvcnRcbiAgICAgIDogKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcbiAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcbiAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG4gIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG4gIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbSB8fCAndCc7XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICB0aGlzLnRyYW5zcG9ydE9wdGlvbnMgPSBvcHRzLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG4gIHRoaXMucG9saWN5UG9ydCA9IG9wdHMucG9saWN5UG9ydCB8fCA4NDM7XG4gIHRoaXMucmVtZW1iZXJVcGdyYWRlID0gb3B0cy5yZW1lbWJlclVwZ3JhZGUgfHwgZmFsc2U7XG4gIHRoaXMuYmluYXJ5VHlwZSA9IG51bGw7XG4gIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBmYWxzZSAhPT0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA/IChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHt9KSA6IGZhbHNlO1xuXG4gIGlmICh0cnVlID09PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlKSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG4gIGlmICh0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmIG51bGwgPT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCA9IDEwMjQ7XG4gIH1cblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZSB8fCBudWxsO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcbiAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzIHx8IG51bGw7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSAhIW9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwpIHtcbiAgICBpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubG9jYWxBZGRyZXNzKSB7XG4gICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBvbiBoYW5kc2hha2VcbiAgdGhpcy5pZCA9IG51bGw7XG4gIHRoaXMudXBncmFkZXMgPSBudWxsO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBudWxsO1xuXG4gIC8vIHNldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5waW5nSW50ZXJ2YWxUaW1lciA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG5cbiAgdGhpcy5vcGVuKCk7XG59XG5cblNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuLyoqXG4gKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICovXG5cblNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5Tb2NrZXQuVHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblNvY2tldC50cmFuc3BvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5Tb2NrZXQucGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cbiAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG4gIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuICAvLyB0cmFuc3BvcnQgbmFtZVxuICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG4gIC8vIHBlci10cmFuc3BvcnQgb3B0aW9uc1xuICB2YXIgb3B0aW9ucyA9IHRoaXMudHJhbnNwb3J0T3B0aW9uc1tuYW1lXSB8fCB7fTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBxdWVyeTogcXVlcnksXG4gICAgc29ja2V0OiB0aGlzLFxuICAgIGFnZW50OiBvcHRpb25zLmFnZW50IHx8IHRoaXMuYWdlbnQsXG4gICAgaG9zdG5hbWU6IG9wdGlvbnMuaG9zdG5hbWUgfHwgdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiBvcHRpb25zLnBvcnQgfHwgdGhpcy5wb3J0LFxuICAgIHNlY3VyZTogb3B0aW9ucy5zZWN1cmUgfHwgdGhpcy5zZWN1cmUsXG4gICAgcGF0aDogb3B0aW9ucy5wYXRoIHx8IHRoaXMucGF0aCxcbiAgICBmb3JjZUpTT05QOiBvcHRpb25zLmZvcmNlSlNPTlAgfHwgdGhpcy5mb3JjZUpTT05QLFxuICAgIGpzb25wOiBvcHRpb25zLmpzb25wIHx8IHRoaXMuanNvbnAsXG4gICAgZm9yY2VCYXNlNjQ6IG9wdGlvbnMuZm9yY2VCYXNlNjQgfHwgdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiBvcHRpb25zLmVuYWJsZXNYRFIgfHwgdGhpcy5lbmFibGVzWERSLFxuICAgIHRpbWVzdGFtcFJlcXVlc3RzOiBvcHRpb25zLnRpbWVzdGFtcFJlcXVlc3RzIHx8IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IG9wdGlvbnMudGltZXN0YW1wUGFyYW0gfHwgdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiBvcHRpb25zLnBvbGljeVBvcnQgfHwgdGhpcy5wb2xpY3lQb3J0LFxuICAgIHBmeDogb3B0aW9ucy5wZnggfHwgdGhpcy5wZngsXG4gICAga2V5OiBvcHRpb25zLmtleSB8fCB0aGlzLmtleSxcbiAgICBwYXNzcGhyYXNlOiBvcHRpb25zLnBhc3NwaHJhc2UgfHwgdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IG9wdGlvbnMuY2VydCB8fCB0aGlzLmNlcnQsXG4gICAgY2E6IG9wdGlvbnMuY2EgfHwgdGhpcy5jYSxcbiAgICBjaXBoZXJzOiBvcHRpb25zLmNpcGhlcnMgfHwgdGhpcy5jaXBoZXJzLFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgfHwgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgfHwgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICBleHRyYUhlYWRlcnM6IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IHRoaXMuZXh0cmFIZWFkZXJzLFxuICAgIGZvcmNlTm9kZTogb3B0aW9ucy5mb3JjZU5vZGUgfHwgdGhpcy5mb3JjZU5vZGUsXG4gICAgbG9jYWxBZGRyZXNzOiBvcHRpb25zLmxvY2FsQWRkcmVzcyB8fCB0aGlzLmxvY2FsQWRkcmVzcyxcbiAgICByZXF1ZXN0VGltZW91dDogb3B0aW9ucy5yZXF1ZXN0VGltZW91dCB8fCB0aGlzLnJlcXVlc3RUaW1lb3V0LFxuICAgIHByb3RvY29sczogb3B0aW9ucy5wcm90b2NvbHMgfHwgdm9pZCAoMClcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBvW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYW5zcG9ydDtcbiAgaWYgKHRoaXMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoJ3dlYnNvY2tldCcpICE9PSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgJ05vIHRyYW5zcG9ydHMgYXZhaWxhYmxlJyk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgfVxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cbiAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuICB0cnkge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW4oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cmFuc3BvcnQub3BlbigpO1xuICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9KVxuICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pO1xuICB2YXIgZmFpbGVkID0gZmFsc2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuICgpIHtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT09IG1zZy50eXBlICYmICdwcm9iZScgPT09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgICBkZWJ1ZygnY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0Jyk7XG5cbiAgICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG4gICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcicpO1xuICAgICAgICBlcnIudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCAoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvLyBIYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IgKGVycikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3I6ICcgKyBlcnIpO1xuICAgIGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLCBuYW1lLCBlcnIpO1xuXG4gICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlICgpIHtcbiAgICBvbmVycm9yKCd0cmFuc3BvcnQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSAoKSB7XG4gICAgb25lcnJvcignc29ja2V0IGNsb3NlZCcpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlICh0bykge1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzb2NrZXQgb3BlbicpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgIHNlbGYucGluZygpO1xuICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG4gIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbn07XG5cbi8qKlxuKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuKlxuKiBAYXBpIHByaXZhdGVcbiovXG5cblNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbWl0KCdwaW5nJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG4gIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZGF0YSkge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuXG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBkYXRhLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcbiAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgaWYgKGZuKSB0aGlzLm9uY2UoJ2ZsdXNoJywgZm4pO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgIHNlbGYudHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UgKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlICgpIHtcbiAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiA1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKlxuICogTG9naWMgYm9ycm93ZWQgZnJvbSBNb2Rlcm5penI6XG4gKlxuICogICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9jb3JzLmpzXG4gKi9cblxudHJ5IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG59IGNhdGNoIChlcnIpIHtcbiAgLy8gaWYgWE1MSHR0cCBzdXBwb3J0IGlzIGRpc2FibGVkIGluIElFIHRoZW4gaXQgd2lsbCB0aHJvd1xuICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBQb2xsaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG52YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgaW5oZXJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG4gIG9wdHMueGQgPSB0aGlzLnhkO1xuICBvcHRzLnhzID0gdGhpcy54cztcbiAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG4gIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuICBvcHRzLmVuYWJsZXNYRFIgPSB0aGlzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBvcHRzLnJlcXVlc3RUaW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdCAob3B0cykge1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICB0aGlzLmNyZWF0ZSgpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgaWYgKCdQT1NUJyA9PT0gdGhpcy5tZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmluYXJ5KSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJyovKicpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0VGltZW91dCkge1xuICAgICAgeGhyLnRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDIpIHtcbiAgICAgICAgICB2YXIgY29udGVudFR5cGU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoNCAhPT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PT0geGhyLnN0YXR1cyB8fCAxMjIzID09PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5vbkVycm9yKGUpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XSA9IHRoaXM7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMuY2xlYW51cCh0cnVlKTtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGhvdXNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoZnJvbUVycm9yKSB7XG4gIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHhtbGh0dHByZXF1ZXN0XG4gIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgdGhpcy54aHIub25sb2FkID0gdGhpcy54aHIub25lcnJvciA9IGVtcHR5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICB9XG5cbiAgaWYgKGZyb21FcnJvcikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGxvYWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGF0YTtcbiAgdHJ5IHtcbiAgICB2YXIgY29udGVudFR5cGU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnRUeXBlID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlIHx8IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5SZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuXG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIgKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG4vKipcbiAqIEdldHMgdGhlIGtleXMgZm9yIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzIChvYmope1xuICB2YXIgYXJyID0gW107XG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwgaSkpIHtcbiAgICAgIGFyci5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUsIGdsb2JhbCkge3ZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0aWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuXHRcdFx0XHRjb2RlUG9pbnQgPSAweEZGRkQ7XG5cdFx0XHR9XG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG5cdFx0cmV0dXJuIHN5bWJvbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nLCBvcHRzKSB7XG5cdFx0b3B0cyA9IG9wdHMgfHwge307XG5cdFx0dmFyIHN0cmljdCA9IGZhbHNlICE9PSBvcHRzLnN0cmljdDtcblxuXHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHRcdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpO1xuXHRcdH1cblx0XHRyZXR1cm4gYnl0ZVN0cmluZztcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woc3RyaWN0KSB7XG5cdFx0dmFyIGJ5dGUxO1xuXHRcdHZhciBieXRlMjtcblx0XHR2YXIgYnl0ZTM7XG5cdFx0dmFyIGJ5dGU0O1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cblx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0XHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gYnl0ZTE7XG5cdFx0fVxuXG5cdFx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0cmV0dXJuIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpID8gY29kZVBvaW50IDogMHhGRkZEO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MDcpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdH1cblxuXHR2YXIgYnl0ZUFycmF5O1xuXHR2YXIgYnl0ZUNvdW50O1xuXHR2YXIgYnl0ZUluZGV4O1xuXHRmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcsIG9wdHMpIHtcblx0XHRvcHRzID0gb3B0cyB8fCB7fTtcblx0XHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKHN0cmljdCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4xLjInLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHRydWVcblx0KSB7XG5cdFx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHV0Zjg7XG5cdFx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMTQpKG1vZHVsZSksIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbigpe1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcblxuICAvLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG4gIHZhciBsb29rdXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgfVxuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICBlbmNvZGVkMiA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzEpXTtcbiAgICAgIGVuY29kZWQzID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMildO1xuICAgICAgZW5jb2RlZDQgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSszKV07XG5cbiAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuICB9O1xufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG4gKiBzdXBwb3J0IGl0IGluIHRoZSBCbG9iIGNvbnN0cnVjdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gYXJ5W2ldO1xuICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHN1YmFycmF5LCBtYWtlIGEgY29weSBzbyB3ZSBvbmx5XG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGFyeVtpXSA9IGJ1ZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuICB9XG5cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG4gIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGdsb2JhbC5CbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgUG9sbGluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xudmFyIGluaGVyaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTlBQb2xsaW5nO1xuXG4vKipcbiAqIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICovXG5cbnZhciByTmV3bGluZSA9IC9cXG4vZztcbnZhciByRXNjYXBlZE5ld2xpbmUgPSAvXFxcXG4vZztcblxuLyoqXG4gKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuICovXG5cbnZhciBjYWxsYmFja3M7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7IH1cblxuLyoqXG4gKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG4gIGlmICghY2FsbGJhY2tzKSB7XG4gICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2VcbiAgICBpZiAoIWdsb2JhbC5fX19laW8pIGdsb2JhbC5fX19laW8gPSBbXTtcbiAgICBjYWxsYmFja3MgPSBnbG9iYWwuX19fZWlvO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaWRlbnRpZmllclxuICB0aGlzLmluZGV4ID0gY2FsbGJhY2tzLmxlbmd0aDtcblxuICAvLyBhZGQgY2FsbGJhY2sgdG8ganNvbnAgZ2xvYmFsXG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKG1zZykge1xuICAgIHNlbGYub25EYXRhKG1zZyk7XG4gIH0pO1xuXG4gIC8vIGFwcGVuZCB0byBxdWVyeSBzdHJpbmdcbiAgdGhpcy5xdWVyeS5qID0gdGhpcy5pbmRleDtcblxuICAvLyBwcmV2ZW50IHNwdXJpb3VzIGVycm9ycyBmcm9tIGJlaW5nIGVtaXR0ZWQgd2hlbiB0aGUgd2luZG93IGlzIHVubG9hZGVkXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuLypcbiAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5mb3JtKSB7XG4gICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgfVxuXG4gIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHRoaXMudXJpKCk7XG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLCBlKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gIGlmIChpbnNlcnRBdCkge1xuICAgIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuICB9IGVsc2Uge1xuICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInICsgc2VsZi5pZnJhbWVJZCArICdcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIHBhcnNlcXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIGluaGVyaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHllYXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xudmFyIEJyb3dzZXJXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG52YXIgTm9kZVdlYlNvY2tldDtcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICB0cnkge1xuICAgIE5vZGVXZWJTb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcbiAgfSBjYXRjaCAoZSkgeyB9XG59XG5cbi8qKlxuICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcbmlmICghV2ViU29ja2V0ICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIFdlYlNvY2tldCA9IE5vZGVXZWJTb2NrZXQ7XG59XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG4gIHRoaXMucHJvdG9jb2xzID0gb3B0cy5wcm90b2NvbHM7XG4gIGlmICghdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vKlxuICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuICovXG5cbldTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogT3BlbnMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdXJpID0gdGhpcy51cmkoKTtcbiAgdmFyIHByb3RvY29scyA9IHRoaXMucHJvdG9jb2xzO1xuICB2YXIgb3B0cyA9IHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG4gIH1cbiAgaWYgKHRoaXMubG9jYWxBZGRyZXNzKSB7XG4gICAgb3B0cy5sb2NhbEFkZHJlc3MgPSB0aGlzLmxvY2FsQWRkcmVzcztcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy53cyA9IHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID8gKHByb3RvY29scyA/IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpIDogbmV3IFdlYlNvY2tldCh1cmkpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHBhY2tldHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgKCd3cycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiA2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiAoaWdub3JlZCkgKi9cblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXHJcbiAqIEpTT04gcGFyc2UuXHJcbiAqXHJcbiAqIEBzZWUgQmFzZWQgb24galF1ZXJ5I3BhcnNlSlNPTiAoTUlUKSBhbmQgSlNPTjJcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxudmFyIHJ2YWxpZGNoYXJzID0gL15bXFxdLDp7fVxcc10qJC87XHJcbnZhciBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xyXG52YXIgcnZhbGlkdG9rZW5zID0gL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nO1xyXG52YXIgcnZhbGlkYnJhY2VzID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nO1xyXG52YXIgcnRyaW1MZWZ0ID0gL15cXHMrLztcclxudmFyIHJ0cmltUmlnaHQgPSAvXFxzKyQvO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xyXG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSB8fCAhZGF0YSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJ0cmltTGVmdCwgJycpLnJlcGxhY2UocnRyaW1SaWdodCwgJycpO1xyXG5cclxuICAvLyBBdHRlbXB0IHRvIHBhcnNlIHVzaW5nIHRoZSBuYXRpdmUgSlNPTiBwYXJzZXIgZmlyc3RcclxuICBpZiAoZ2xvYmFsLkpTT04gJiYgSlNPTi5wYXJzZSkge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgfVxyXG5cclxuICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXHJcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZHRva2VucywgJ10nKVxyXG4gICAgICAucmVwbGFjZShydmFsaWRicmFjZXMsICcnKSkpIHtcclxuICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xyXG4gIH1cclxufTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuXG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG5cblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNikuT2JqZWN0LmFzc2lnbjtcblxuXG4vKioqLyB9KSxcbi8qIDY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KSB9KTtcblxuXG4vKioqLyB9KSxcbi8qIDY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbnZhciBjdHggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBrZXkgaW4gZXhwb3J0cykgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZFAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG4vKiA3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXygxMikoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19yZXF1aXJlX18oNzMpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcbi8qIDczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG52YXIgZ09QUyA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xudmFyIHBJRSA9IF9fd2VicGFja19yZXF1aXJlX18oODkpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MCk7XG52YXIgSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygxMikoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG4vKioqLyB9KSxcbi8qIDc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA3OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG52YXIgYXJyYXlJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSkoZmFsc2UpO1xudmFyIElFX1BST1RPID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCkoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDgwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuLyogODIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA4NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSkoJ2tleXMnKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDg2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogODcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cblxuLyoqKi8gfSksXG4vKiA4OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuLyogODkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKi8gfSksXG4vKiA5MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9kYW5pZWwubWFyaW5vL0Rlc2t0b3AvUkVBQ1QvYXBpLXR5cGVzY3JpcHQtbGlicmFyeS9kaXN0L2FwaS5qc1xuLy8gbW9kdWxlIGlkID0gMjc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGNyZWF0ZUJyb3dzZXJIaXN0b3J5IH0gZnJvbSAnaGlzdG9yeSc7XG5pbXBvcnQgU2hhZG93RE9NIGZyb20gJ3JlYWN0LXNoYWRvdyc7XG5cbmltcG9ydCB7IHN0b3JlIH0gZnJvbSAnLi9zdG9yZS9zdG9yZSc7XG5pbXBvcnQgeyBBcHAgfSBmcm9tICdDb250YWluZXJzJztcbmltcG9ydCB7IEFjY2Vzc1Rva2VuLCBEaXZlQVBJQ2xhc3MgfSBmcm9tIFwiQGRpdmUtdHYvYXBpLXR5cGVzY3JpcHQtbGlicmFyeVwiO1xuaW1wb3J0IHsgQ2FyZCB9IGZyb20gJ1NlcnZpY2VzJztcblxuY29uc3QgaGlzdG9yeSA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCk7XG4vLyBsZXQgRGl2ZUFQSTogZGl2ZUFwaS5EaXZlQVBJO1xuXG5leHBvcnQgY29uc3QgaW5pdCA9IChwYXJhbXM6IHsgYXBpS2V5OiBzdHJpbmcsIGRldmljZUlkOiBzdHJpbmcsIHNlbGVjdG9yOiBzdHJpbmcgfSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3Ugc2hvdWxkIHByb3ZpZGUgaW5pdGlhbGl6YXRpb24gcGFyYW1ldGVycyBhcyBhbiBvYmplY3QuXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3Ugc2hvdWxkIHByb3ZpZGUgaW5pdGlhbGl6YXRpb24gcGFyYW1ldGVycyBhcyBhbiBvYmplY3QuXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5hcGlLZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBzaG91bGQgcHJvdmlkZSBhIERpdmUgQVBJIEtFWSBpbiB0aGUgaW5pdGlhbGl6YXRpb24gcGFyYW1ldGVyICdhcGlLZXlcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBzaG91bGQgcHJvdmlkZSBhIERpdmUgQVBJIEtFWSBpbiB0aGUgaW5pdGlhbGl6YXRpb24gcGFyYW1ldGVyICdhcGlLZXlcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyYW1zLmRldmljZUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFlvdSBzaG91bGQgcHJvdmlkZSBhIHVuaXF1ZSBjbGllbnQgaWQgaW4gb3JkZXIgdG8gYXV0aGVudGljYXRlIGhpbSxcbiAgICAgIHByb3ZpZGUgaXQgdGhyb3VnaCB0aGUgaW5pdGlhbGl6YXRpb24gcGFyYW1ldGVyICdjbGllbnRJZCdgKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3Ugc2hvdWxkIHByb3ZpZGUgYSB1bmlxdWUgY2xpZW50IGlkIGluIG9yZGVyIHRvIGF1dGhlbnRpY2F0ZSBoaW0sXG4gICAgICBwcm92aWRlIGl0IHRocm91Z2ggdGhlIGluaXRpYWxpemF0aW9uIHBhcmFtZXRlciAnY2xpZW50SWQnYCk7XG4gICAgfVxuICAgIGNvbnN0IEFQSWluc3RhbmNlID0gbmV3IERpdmVBUElDbGFzcyhcbiAgICAgICAgeyBlbnY6IFwiUFJFXCIsIHN0b3JlVG9rZW46IFwiY29va2llc1wiLCBhcGlLZXk6IHBhcmFtcy5hcGlLZXksIGRldmljZUlkOiBwYXJhbXMuZGV2aWNlSWQgfSxcbiAgICApO1xuICAgIEFQSWluc3RhbmNlLnNldExvY2FsZShcImVzLUVTXCIpO1xuICAgICh3aW5kb3cgYXMgYW55KS5EaXZlQVBJID0gQVBJaW5zdGFuY2U7XG4gICAgQVBJaW5zdGFuY2UucG9zdFRva2VuQW5kU2F2ZSh7IGRldmljZUlkOiB0aGlzLmRldmljZUlkLCBncmFudFR5cGU6IFwiZGV2aWNlX2NyZWRlbnRpYWxzXCIgfSlcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlOiBBY2Nlc3NUb2tlbikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJBdXRob3JpemVkIVwiKTtcbiAgICAgICAgICAgICh3aW5kb3cgYXMgYW55KS5EaXZlQVBJID0gQVBJaW5zdGFuY2U7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJEaXZlQVBJIGdlbmVyYXRlZCwgYXZhaWxhYmxlIHRocm91Z2ggRGl2ZVNESy5BUEkgb3Igd2luZG93LkRpdmVBUEkgKGdsb2JhbClcIik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5zZWxlY3RvciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFlvdSBzaG91bGQgcHJvdmlkZSBhIHNlbGVjdG9yIHRoYXQgcmVzb2x2ZXMgdG8gYW4gZXhpc3RpbmcgRE9NIEVsZW1lbnRcbiAgICAgICAgaW4gdGhlIGluaXRpYWxpemF0aW9uIHBhcmFtZXRlciAnc2VsZWN0b3InYCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3Ugc2hvdWxkIHByb3ZpZGUgYSBzZWxlY3RvciB0aGF0IHJlc29sdmVzIHRvIGFuIGV4aXN0aW5nIERPTSBFbGVtZW50XG4gICAgICAgIGluIHRoZSBpbml0aWFsaXphdGlvbiBwYXJhbWV0ZXIgJ3NlbGVjdG9yJ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvL0FQSWluc3RhbmNlLmdldFN0YXRpY01vdmllU2NlbmUoeyByZWxhdGlvbnM6IHRydWUsIGNsaWVudE1vdmllSWQ6IFwibTAwMDAxXCIsIHRpbWVzdGFtcDogNDAwMCB9KVxuICAgICAgICAgICAgLy8udGhlbigocmVzcG9uc2U6IENhcmRbXSkgPT4ge1xuICAgICAgICAgICAgLypjb25zdCBuZXdDYXJkczogYW55W10gPSBbXG4gICAgICAgICAgICAgICAgeyBjYXJkX2lkOiBcIjI4ZTdjYjUyLTAxYTItM2U5NS1hNzFmLTRmYzJkM2U0NmY4NlwiLCB2ZXJzaW9uOiBcIjBqT2VVSWVMQ2FPY1NJNEZTZWJOajQrRTdWWlwiIH0sXG4gICAgICAgICAgICAgICAgeyBjYXJkX2lkOiBcImJkNGYyNmJhLTBjMmEtM2ExNi1iYjdiLTc5YWEwNjZhYmY0NFwiLyosIHZlcnNpb246IFwiMGpPZVVJZUxDYU9jU0k0RlNlYk5qNCtFN1ZaXCIgKi8vL30sXG4gICAgICAgICAgICAvL3sgY2FyZF9pZDogXCJlMDE0M2Q3Yi0xZTc2LTExZTYtOTdhYy0wNjg0OTg1Y2JiZTNcIi8qLCB2ZXJzaW9uOiBcIjBqT2VVSWVMQ2FPY1NJNEZTZWJOajQrRTdWWlwiICovfSxcblxuICAgICAgICAgICAgLy9dO1xuICAgICAgICAgICAgLy9yZXNwb25zZSA9IFsuLi5uZXdDYXJkcywgLi4ucmVzcG9uc2VdO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInJlc3BvbnNlOiBcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgUmVhY3RET00ucmVuZGVyKFxuICAgICAgICAgICAgICAgIDxTaGFkb3dET00gaW5jbHVkZT17J3N0eWxlcy5jc3MnfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkaXZlQ29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8UHJvdmlkZXIgc3RvcmU9e3N0b3JlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QXBwIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L1Byb3ZpZGVyPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L1NoYWRvd0RPTSA+LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyYW1zLnNlbGVjdG9yKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDQVJEUyBGUk9NIE1PVklFIEVSUk9SXCIsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgLypEaXZlQVBJLmdldENhcmQoe2NhcmRJZDogXCJjNThiYmYxZi02ZmY1LTExZTUtYjdjMi0wNjg0OTg1Y2JiZTNcIn0pLmNhdGNoKChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKHJlc3BvbnNlKTtcbiAgICB9KTsqL1xuICAgIC8vRGl2ZUFQSS5nZXRTdGF0aWNNb3ZpZVNjZW5lKHtyZWxhdGlvbnM6IHRydWUsIGNsaWVudE1vdmllSWQ6IFwiXCIsIHRpbWVzdGFtcDogMTUwMH0pO1xuICAgIC8vIGNvbnNvbGUubG9nKFwiU1RZTEVTXCIsIHN0eWxlcyk7XG4gICAgLy99KTtcbn07XG5cbi8vIGluaXQoeyBzZWxlY3RvcjogXCIjcm9vdFwiLCBhcGlLZXk6IFwiZEc5MVkyaDJhV1ZmWVhCcE9rWXlVVWhNWlRoWWRFZDJSMWhSYW01MFYzRk1WWEZqZEdJNVFtUlZkRFJUXCIsIGRldmljZUlkOiBcInRlc3RcIiB9KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL21haW4udHN4IiwiZXhwb3J0ICogZnJvbSBcIi4vaGVscGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9sb2NhbGl6ZWRfdGV4dHNcIjtcbmV4cG9ydCAqIGZyb20gXCJAZGl2ZS10di9hcGktdHlwZXNjcmlwdC1saWJyYXJ5XCI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zZXJ2aWNlcy9pbmRleC50c3giLCJpbXBvcnQgeyBjcmVhdGVTdG9yZSwgY29tYmluZVJlZHVjZXJzLCBhcHBseU1pZGRsZXdhcmUsIGNvbXBvc2UgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgdGh1bmsgZnJvbSBcInJlZHV4LXRodW5rXCI7XG5pbXBvcnQgc29ja2V0TWlkZGxld2FyZSBmcm9tICcuLi9taWRkbGV3YXJlL3NvY2tldC5taWRkbGV3YXJlJztcblxuXG5pbXBvcnQge1xuICAgIElOYXZTdGF0ZSwgTmF2UmVkdWNlciwgSVN5bmNTdGF0ZSwgU3luY1JlZHVjZXIsIElVSVN0YXRlLCBVSVJlZHVjZXJcbn0gZnJvbSAnUmVkdWNlcnMnO1xuXG5kZWNsYXJlIGNvbnN0IF9fRU5WX186IHN0cmluZztcblxuY29uc3Qgd2luZG93SWZEZWZpbmVkID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93IGFzIGFueTtcbmNvbnN0IGNvbXBvc2VFbmhhbmNlcnMgPSB3aW5kb3dJZkRlZmluZWQuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIHx8IGNvbXBvc2U7XG5cbmNvbnN0IGdldE1pZGRsZXdhcmVzID0gKCkgPT4ge1xuICAvLyBpZiAoX19FTlZfXyAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgLy8gICByZXR1cm4gYXBwbHlNaWRkbGV3YXJlKC8qY3JlYXRlTG9nZ2VyKHtcbiAgLy8gICAgICAgICBwcmVkaWNhdGU6ICgpID0+ICh3aW5kb3cgYXMgYW55KS5lbmFibGVBY3Rpb25Mb2dnZXIsXG4gIC8vICAgICB9KSwqLyB0aHVuayAvKiwgcGVyc2lzdGVkU3RhdGUqLy8qLCBzb2NrZXRNaWRkbGV3YXJlKCkqLyk7XG4gIC8vIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFwcGx5TWlkZGxld2FyZSh0aHVuayAvKiwgcGVyc2lzdGVkU3RhdGUsKi8sIHNvY2tldE1pZGRsZXdhcmUoKSk7XG4gIC8vIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlKFxuICBjb21iaW5lUmVkdWNlcnMoe1xuICAgIG5hdjogTmF2UmVkdWNlcixcbiAgICBjYXJvdXNlbDogU3luY1JlZHVjZXIsXG4gICAgdWk6IFVJUmVkdWNlcixcbiAgfSksXG4gIGNvbXBvc2VFbmhhbmNlcnMoZ2V0TWlkZGxld2FyZXMoKSksXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3RvcmUvc3RvcmUudHMiLCJpbXBvcnQgeyBTb2NrZXRBY3Rpb25zIH0gZnJvbSAnQWN0aW9ucyc7XG5pbXBvcnQgeyBTdG9yZSwgRGlzcGF0Y2ggfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgKiBhcyBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCB7ICBESVZFX0VOVklST05NRU5UIH0gZnJvbSAnQ29uc3RhbnRzJztcbmltcG9ydCB7IERpdmVBUElDbGFzcyB9IGZyb20gJ1NlcnZpY2VzJztcblxuXG5kZWNsYXJlIGNvbnN0IERpdmVBUEk6IERpdmVBUElDbGFzcztcblxuY29uc3Qgc29ja2V0TWlkZGxld2FyZSA9ICgpID0+IHtcbiAgICBsZXQgc29ja2V0OiBTb2NrZXRJT0NsaWVudC5Tb2NrZXQgfCB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBvbk9wZW4gPSAoc29ja2V0SW86IFNvY2tldElPQ2xpZW50LlNvY2tldCwgc3RvcmU6IFN0b3JlPGFueT4sIGNoYW5uZWw6IHN0cmluZykgPT4gKGV2dDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgIC8vIFNlbmQgYSBoYW5kc2hha2UsIG9yIGF1dGhlbnRpY2F0ZSB3aXRoIHJlbW90ZSBlbmQgVGVsbCB0aGUgc3RvcmUgd2UncmVcbiAgICAgICAgLy8gY29ubmVjdGVkXG4gICAgICAgIHN0b3JlLmRpc3BhdGNoKFNvY2tldEFjdGlvbnMuc29ja2V0Q29ubmVjdGVkKCkpO1xuICAgICAgICBpZiAoc29ja2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNvY2tldC5vbignY2hhbm5lbFN0YXR1cycsIG9uTWVzc2FnZShzb2NrZXQsIHN0b3JlKSk7XG4gICAgICAgICAgICBzb2NrZXQuZW1pdCgndHVuZUNoYW5uZWwnLCBjaGFubmVsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvbkNsb3NlID0gKHNvY2tldElvOiBTb2NrZXRJT0NsaWVudC5Tb2NrZXQsIHN0b3JlOiBTdG9yZTxhbnk+KSA9PiAoZXZ0OiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChzb2NrZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVsbCB0aGUgc3RvcmUgd2UndmUgZGlzY29ubmVjdGVkXG4gICAgICAgIHN0b3JlLmRpc3BhdGNoKFNvY2tldEFjdGlvbnMuc29ja2V0RGlzY29ubmVjdGVkKCkpO1xuICAgIH07XG4gICAgY29uc3Qgb25FbmQgPSAoc29ja2V0SW86IFNvY2tldElPQ2xpZW50LlNvY2tldCwgc3RvcmU6IFN0b3JlPGFueT4pID0+IChldnQ6IENsb3NlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHNvY2tldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZS5kaXNwYXRjaChTb2NrZXRBY3Rpb25zLnNvY2tldERpc2Nvbm5lY3RlZCgpKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRXJyb3IgPSAoc29ja2V0SW86IFNvY2tldElPQ2xpZW50LlNvY2tldCwgc3RvcmU6IFN0b3JlPGFueT4pID0+IChldnQ6IENsb3NlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHNvY2tldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZS5kaXNwYXRjaChTb2NrZXRBY3Rpb25zLnNvY2tldERpc2Nvbm5lY3RlZCgpKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25UaW1lb3V0ID0gKHNvY2tldElvOiBTb2NrZXRJT0NsaWVudC5Tb2NrZXQsIHN0b3JlOiBTdG9yZTxhbnk+KSA9PiAoZXZ0OiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChzb2NrZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goU29ja2V0QWN0aW9ucy5zb2NrZXREaXNjb25uZWN0ZWQoKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTWVzc2FnZSA9IChzb2NrZXRJbzogU29ja2V0SU9DbGllbnQuU29ja2V0LCBzdG9yZTogU3RvcmU8YW55PikgPT4gKGV2dDogYW55KSA9PiB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtdmFyaWFibGVcbiAgICAgICAgY29uc3QgbmV4dCA9IHN0b3JlLmRpc3BhdGNoO1xuICAgICAgICAvLyBQYXJzZSB0aGUgSlNPTiBtZXNzYWdlIHJlY2VpdmVkIG9uIHRoZSB3ZWJzb2NrZXRcbiAgICAgICAgY29uc3QgZGF0YSA9IGV2dDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gZGF0YS5zdGF0dXM7XG4gICAgICAgIFxuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImF1dGhlbnRpY2F0ZWRcIjpcbiAgICAgICAgICAgICAgICAvLyBEaXNwYXRjaCBhbiBhY3Rpb24gdGhhdCBhZGRzIHRoZSByZWNlaXZlZCBtZXNzYWdlIHRvIG91ciBzdGF0ZVxuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKFNvY2tldEFjdGlvbnMuYXV0aFJlY2VpdmVkKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVuYXV0aG9yaXplZFwiOlxuICAgICAgICAgICAgICAgIC8vIERpc3BhdGNoIGFuIGFjdGlvbiB0aGF0IGFkZHMgdGhlIHJlY2VpdmVkIG1lc3NhZ2UgdG8gb3VyIHN0YXRlXG4gICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goU29ja2V0QWN0aW9ucy51bmF1dGhSZWNlaXZlZCh7bWVzc2FnZTogZGF0YS5tZXNzYWdlLCBjb2RlOiBkYXRhLmNvZGUsIHR5cGU6IGRhdGEudHlwZX0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIC8vIERpc3BhdGNoIGFuIGFjdGlvbiB0aGF0IGFkZHMgdGhlIHJlY2VpdmVkIG1lc3NhZ2UgdG8gb3VyIHN0YXRlXG4gICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goU29ja2V0QWN0aW9ucy5lcnJvclJlY2VpdmVkKHsgc3RhdHVzOiBkYXRhLnN0YXR1cywgZGVzY3JpcHRpb246IGRhdGEuZGVzY3JpcHRpb24gfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1vdmllX3N0YXJ0XCI6XG4gICAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggYW4gYWN0aW9uIHRoYXQgYWRkcyB0aGUgcmVjZWl2ZWQgbWVzc2FnZSB0byBvdXIgc3RhdGVcbiAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaChTb2NrZXRBY3Rpb25zLm1vdmllU3RhcnRSZWNlaXZlZCh7bW92aWVfaWQ6IGRhdGEubW92aWVfaWR9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibW92aWVfZW5kXCI6XG4gICAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggYW4gYWN0aW9uIHRoYXQgYWRkcyB0aGUgcmVjZWl2ZWQgbWVzc2FnZSB0byBvdXIgc3RhdGVcbiAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaChTb2NrZXRBY3Rpb25zLm1vdmllRW5kUmVjaWV2ZWQoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2NlbmVfc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAvLyBEaXNwYXRjaCBhbiBhY3Rpb24gdGhhdCBhZGRzIHRoZSByZWNlaXZlZCBtZXNzYWdlIHRvIG91ciBzdGF0ZVxuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKFNvY2tldEFjdGlvbnMuc2NlbmVTdGFydFJlY2VpdmVkKHtjYXJkczogZGF0YS5jYXJkc30pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzY2VuZV91cGRhdGVcIjpcbiAgICAgICAgICAgICAgICAvLyBEaXNwYXRjaCBhbiBhY3Rpb24gdGhhdCBhZGRzIHRoZSByZWNlaXZlZCBtZXNzYWdlIHRvIG91ciBzdGF0ZVxuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKFNvY2tldEFjdGlvbnMuc2NlbmVVcGRhdGVSZWNlaXZlZCh7Y2FyZHM6IGRhdGEuY2FyZHN9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2NlbmVfZW5kXCI6XG4gICAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggYW4gYWN0aW9uIHRoYXQgYWRkcyB0aGUgcmVjZWl2ZWQgbWVzc2FnZSB0byBvdXIgc3RhdGVcbiAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaChTb2NrZXRBY3Rpb25zLnNjZW5lRW5kUmVjZWl2ZWQoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGdldFVybCA9IChlbnY6IFwiREVWXCIgfCBcIlBSRVwiIHwgXCJQUk9cIik6IHN0cmluZyA9PiB7XG4gICAgICAgIGNvbnN0IHNvY2tldFBhdGg6IHN0cmluZyA9ICdzdHJlYW0uZGl2ZS50dic7XG4gICAgICAgIHN3aXRjaCAoZW52KSB7XG4gICAgICAgICAgICBjYXNlIFwiREVWXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9kZXYtXCIgKyBzb2NrZXRQYXRoO1xuICAgICAgICAgICAgY2FzZSBcIlBSRVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi8vcHJlLVwiICsgc29ja2V0UGF0aDtcbiAgICAgICAgICAgIGNhc2UgXCJQUk9cIjpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdodHRwczovLycgKyBzb2NrZXRQYXRoO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlciA9IChzdG9yZTogU3RvcmU8YW55PikgPT4gKG5leHQ6IERpc3BhdGNoPGFueT4pID0+IChhY3Rpb246IGFueSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIHdhbnRzIHVzIHRvIGNvbm5lY3RcbiAgICAgICAgICAgIGNhc2UgJ0NPTk5FQ1QnOlxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VuZCBhbiBhY3Rpb24gdGhhdCBzaG93cyBhIFwiY29ubmVjdGluZy4uLlwiIHN0YXR1cyBmb3Igbm93XG4gICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goU29ja2V0QWN0aW9ucy5zb2NrZXRDb25uZWN0aW5nKCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBjb25uZWN0ICh3ZSBjb3VsZCBzZW5kIGEgJ2ZhaWxlZCcgYWN0aW9uIG9uIGVycm9yKSBzb2NrZXQgPSBuZXdcbiAgICAgICAgICAgICAgICAvLyBXZWJTb2NrZXQoYWN0aW9uLnBheWxvYWQudXJsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXZlVG9rZW4gPSBEaXZlQVBJLmdldFNhdmVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGl2ZVRva2VuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIHRva2VuIHByZXNlbnQgd2hpbGUgdHJ5aW5nIHRvIGNvbm5lY3QgdGhlIHNvY2tldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9rZW4gcHJlc2VudCB3aGlsZSB0cnlpbmcgdG8gY29ubmVjdCB0aGUgc29ja2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGFjdGlvbi5wYXlsb2FkLnVybCAhPT0gdW5kZWZpbmVkID8gYWN0aW9uLnBheWxvYWQudXJsIDogZ2V0VXJsKERJVkVfRU5WSVJPTk1FTlQpO1xuXG4gICAgICAgICAgICAgICAgc29ja2V0ID0gaW8uY29ubmVjdCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VOZXc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBgdG9rZW49JHtkaXZlVG9rZW4uYWNjZXNzX3Rva2VufWAsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0czogW1wid2Vic29ja2V0XCIsIFwieGhyLXBvbGxpbmdcIiwgXCJwb2xsaW5nXCIsIFwiaHRtbGZpbGVcIl0sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gYWN0aW9uLnBheWxvYWQuY2hhbm5lbElkO1xuICAgICAgICAgICAgICAgIHNvY2tldC5vbignY29ubmVjdCcsIG9uT3Blbihzb2NrZXQsIHN0b3JlLCBjaGFubmVsKSk7XG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdjb25uZWN0X2Vycm9yJywgb25FcnJvcihzb2NrZXQsIHN0b3JlKSk7XG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIG9uRXJyb3Ioc29ja2V0LCBzdG9yZSkpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5vbignY29ubmVjdF90aW1lb3V0Jywgb25UaW1lb3V0KHNvY2tldCwgc3RvcmUpKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQub24oJ2Rpc2Nvbm5lY3QnLCBvbkNsb3NlKHNvY2tldCwgc3RvcmUpKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQub24oJ2VuZCcsIG9uRW5kKHNvY2tldCwgc3RvcmUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gVGhlIHVzZXIgd2FudHMgdXMgdG8gZGlzY29ubmVjdFxuICAgICAgICAgICAgY2FzZSAnRElTQ09OTkVDVCc6XG4gICAgICAgICAgICAgICAgaWYgKHNvY2tldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNvY2tldCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIC8vIFNldCBvdXIgc3RhdGUgdG8gZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goU29ja2V0QWN0aW9ucy5zb2NrZXREaXNjb25uZWN0ZWQoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIFRoaXMgYWN0aW9uIGlzIGlycmVsZXZhbnQgdG8gdXMsIHBhc3MgaXQgb24gdG8gdGhlIG5leHQgbWlkZGxld2FyZVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBoYW5kbGVyO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc29ja2V0TWlkZGxld2FyZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL21pZGRsZXdhcmUvc29ja2V0Lm1pZGRsZXdhcmUudHN4IiwiaW1wb3J0IHsgSVVJQWN0aW9uIH0gZnJvbSAnLi8uLi9yZWR1Y2Vycy91aS5yZWR1Y2VyJztcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IE1hcERpc3BhdGNoVG9Qcm9wc09iamVjdCwgQWN0aW9uQ3JlYXRvciB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbiB9IGZyb20gJ3JlZHV4LWFjdGlvbnMnO1xuXG5pbXBvcnQgeyBVSUFjdGlvblR5cGVzLCBJVUlHcm91cCB9IGZyb20gJ1JlZHVjZXJzJztcbmltcG9ydCB7IENhcmQsIERpdmVBUElDbGFzcyB9IGZyb20gXCJTZXJ2aWNlc1wiO1xuXG5kZWNsYXJlIGNvbnN0IERpdmVBUEk6IERpdmVBUElDbGFzcztcblxuZXhwb3J0IGludGVyZmFjZSBJVUlBY3Rpb25zIGV4dGVuZHMgTWFwRGlzcGF0Y2hUb1Byb3BzT2JqZWN0IHtcbiAgICBnb0JhY2s6IEFjdGlvbkNyZWF0b3I8SVVJQWN0aW9uPjtcbiAgICBvcGVuQ2FyZDogQWN0aW9uQ3JlYXRvcjx2b2lkPjtcbiAgICBwZXJmb3JtT3BlbkNhcmQ6IEFjdGlvbkNyZWF0b3I8SVVJQWN0aW9uPjtcbiAgICBvcGVuU3luYzogQWN0aW9uQ3JlYXRvcjxJVUlBY3Rpb24+O1xuICAgIG9wZW46IEFjdGlvbkNyZWF0b3I8dm9pZD47XG4gICAgYWRkVGVzdENhcmRzOiBBY3Rpb25DcmVhdG9yPElVSUFjdGlvbj47XG59XG5cbi8vXG4vLyAgQWN0aW9uIENyZWF0b3JzXG4vL1xuZXhwb3J0IGNvbnN0IHVpQ3JlYXRlQWN0aW9uID0gKHR5cGU6IFVJQWN0aW9uVHlwZXMsIHBheWxvYWQ/OiBhbnkpOiBSZWR1eEFjdGlvbnMuQWN0aW9uRnVuY3Rpb24wPEFjdGlvbj4gPT4ge1xuICAgIHJldHVybiBjcmVhdGVBY3Rpb24odHlwZSwgcGF5bG9hZCk7XG59O1xuXG5leHBvcnQgY29uc3QgVUlBY3Rpb25zOiBJVUlBY3Rpb25zID0ge1xuICAgIGdvQmFjazogdWlDcmVhdGVBY3Rpb24oXCJVSS9VSV9CQUNLXCIsICgpID0+ICgwKSksXG4gICAgc2V0RGl2aWRlcjogdWlDcmVhdGVBY3Rpb24oXCJVSS9TRVRfRElWSURFUlwiLCAoZGl2aWRlcjogbnVtYmVyKSA9PiAoZGl2aWRlcikpLFxuICAgIG9wZW5DYXJkOiAoY2FyZElkOiBzdHJpbmcsIHJlbGF0aW9uczogc3RyaW5nKSA9PiAoZGlzcGF0Y2g6IGFueSkgPT4ge1xuICAgICAgICBpZiAoY2FyZElkICYmIGNhcmRJZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkaXNwYXRjaChVSUFjdGlvbnMucGVyZm9ybU9wZW5DYXJkKCkpO1xuICAgICAgICB9XG4gICAgICAgIERpdmVBUEkuZ2V0Q2FyZCh7IGNhcmRJZCB9KVxuICAgICAgICAgICAgLnRoZW4oKGNhcmQ6IENhcmQpID0+IHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChVSUFjdGlvbnMucGVyZm9ybU9wZW5DYXJkKGNhcmQpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBjYXJkXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBkaXNwbGF5IGVycm9yP1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBwZXJmb3JtT3BlbkNhcmQ6IHVpQ3JlYXRlQWN0aW9uKFwiVUkvT1BFTl9DQVJEXCIsIChjYXJkOiBDYXJkKSA9PiAoY2FyZCkpLFxuICAgIG9wZW5TeW5jOiB1aUNyZWF0ZUFjdGlvbihcIlVJL09QRU5fU1lOQ1wiKSxcbiAgICBvcGVuOiAoZ3JvdXA6IElVSUdyb3VwKSA9PiAoZGlzcGF0Y2g6IGFueSkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goVUlBY3Rpb25zLnBlcmZvcm1PcGVuKGdyb3VwKSk7XG4gICAgfSxcbiAgICBwZXJmb3JtT3BlbjogdWlDcmVhdGVBY3Rpb24oXCJVSS9PUEVOXCIsIChncm91cDogSVVJR3JvdXApID0+IChncm91cCkpLFxuICAgIGFkZFRlc3RDYXJkczogdWlDcmVhdGVBY3Rpb24oXCJVSS9BRERfVEVTVF9DQVJEU1wiLCAoY2FyZHM6IENhcmRbXSkgPT4oY2FyZHMpKSxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hY3Rpb25zL3VpLmFjdGlvbnMudHMiLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBNYXBEaXNwYXRjaFRvUHJvcHNPYmplY3QsIEFjdGlvbkNyZWF0b3IgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG4vLyBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJTmF2QWN0aW9uLCBOYXZBY3Rpb25UeXBlcyB9IGZyb20gJ1JlZHVjZXJzJztcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbiB9IGZyb20gJ3JlZHV4LWFjdGlvbnMnO1xuaW1wb3J0IHsgSU5hdmlnYWJsZSB9IGZyb20gXCJIT0NcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJTmF2QWN0aW9ucyBleHRlbmRzIE1hcERpc3BhdGNoVG9Qcm9wc09iamVjdCB7XG4gICAgYWRkTm9kZTogQWN0aW9uQ3JlYXRvcjxJTmF2QWN0aW9uPjtcbiAgICBkZWxldGVOb2RlOiBBY3Rpb25DcmVhdG9yPElOYXZBY3Rpb24+O1xuICAgIHNldExhc3RLZXk6IEFjdGlvbkNyZWF0b3I8SU5hdkFjdGlvbj47XG4gICAgc2V0U2VsZWN0ZWQ6IEFjdGlvbkNyZWF0b3I8SU5hdkFjdGlvbj47XG4gICAgc2V0QWN0aXZhdGVkOiBBY3Rpb25DcmVhdG9yPElOYXZBY3Rpb24+O1xuICAgIG1vdmVIb3Jpem9udGFsOiBBY3Rpb25DcmVhdG9yPElOYXZBY3Rpb24+O1xuICAgIG1vdmVWZXJ0aWNhbDogQWN0aW9uQ3JlYXRvcjxJTmF2QWN0aW9uPjtcbiAgICBzZXROb2RlQnlJZDogQWN0aW9uQ3JlYXRvcjxJTmF2QWN0aW9uPjtcbiAgICBzZXROb2RlQnlOYW1lOiBBY3Rpb25DcmVhdG9yPElOYXZBY3Rpb24+O1xufVxuXG4vL1xuLy8gIEFjdGlvbiBDcmVhdG9yc1xuLy9cbmV4cG9ydCBjb25zdCBuYXZDcmVhdGVBY3Rpb24gPSAodHlwZTogTmF2QWN0aW9uVHlwZXMsIHBheWxvYWQ/OiBhbnkpOiBSZWR1eEFjdGlvbnMuQWN0aW9uRnVuY3Rpb24wPEFjdGlvbj4gPT4ge1xuICAgIHJldHVybiBjcmVhdGVBY3Rpb24odHlwZSwgcGF5bG9hZCk7XG59O1xuXG5leHBvcnQgY29uc3QgTmF2QWN0aW9uczogSU5hdkFjdGlvbnMgPSB7XG4gICAgYWRkTm9kZTogbmF2Q3JlYXRlQWN0aW9uKCdOQVYvQUREX05PREUnLCAobmF2OiBJTmF2aWdhYmxlKSA9PiBuYXYpLFxuICAgIHNldExhc3RLZXk6IG5hdkNyZWF0ZUFjdGlvbignTkFWL0tFWScsIChrZXk6IHN0cmluZykgPT4ga2V5KSxcbiAgICBzZXRTZWxlY3RlZDogbmF2Q3JlYXRlQWN0aW9uKCdOQVYvU0VMRUNURUQnLCAoaWQ6IG51bWJlcikgPT4gaWQpLFxuICAgIHNldExlYWY6IG5hdkNyZWF0ZUFjdGlvbignTkFWL1NFTEVDVF9MRUFGJywgKGlkOiBudW1iZXIpID0+IGlkKSxcbiAgICBzZXRBY3RpdmF0ZWQ6IG5hdkNyZWF0ZUFjdGlvbignTkFWL0FDVElWQVRFRCcsIChpZDogbnVtYmVyKSA9PiBpZCksXG4gICAgbW92ZUhvcml6b250YWw6IG5hdkNyZWF0ZUFjdGlvbignTkFWL01PVkVfSE9SSVpPTlRBTCcsIChpZDogMSB8IC0xKSA9PiBpZCksXG4gICAgbW92ZVZlcnRpY2FsOiBuYXZDcmVhdGVBY3Rpb24oJ05BVi9NT1ZFX1ZFUlRJQ0FMJywgKGlkOiAxIHwgLTEpID0+IGlkKSxcbiAgICBkZWxldGVOb2RlOiBuYXZDcmVhdGVBY3Rpb24oJ05BVi9ERUxFVEVfTk9ERScsIChpZDogbnVtYmVyKSA9PiBpZCksXG4gICAgc2V0Tm9kZUJ5TmFtZTogbmF2Q3JlYXRlQWN0aW9uKCdOQVYvU0VMRUNUX0JZX05BTUUnLCAobmFtZTogc3RyaW5nKSA9PiBuYW1lKSxcbiAgICBzZXROb2RlQnlJZDogbmF2Q3JlYXRlQWN0aW9uKCdOQVYvU0VMRUNUX0JZX0lEJywgKGlkOiBudW1iZXIpID0+IGlkKSxcblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FjdGlvbnMvbmF2LmFjdGlvbnMudHMiLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBNYXBEaXNwYXRjaFRvUHJvcHNPYmplY3QsIEFjdGlvbkNyZWF0b3IgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBTeW5jQWN0aW9uVHlwZXMsIElTeW5jQWN0aW9uIH0gZnJvbSAnUmVkdWNlcnMnO1xuaW1wb3J0IHsgY3JlYXRlQWN0aW9uIH0gZnJvbSAncmVkdXgtYWN0aW9ucyc7XG4vLyBpbXBvcnQgeyBEaXZlQVBJLCBJbmxpbmVSZXNwb25zZTIwMCwgVHZFdmVudFJlc3BvbnNlLCBDaHVuayB9IGZyb20gJ1NlcnZpY2VzJztcbmltcG9ydCB7IENhcmQsIERpdmVBUElDbGFzcyB9IGZyb20gJ1NlcnZpY2VzJztcbi8vIGltcG9ydCAqIGFzIGNodW5rRXhhbXBsZSBmcm9tICcuLy4uLy4uL3NlcnZpY2VzL19fbW9ja3NfXy9jaHVua0V4YW1wbGUuanNvbic7XG4vLyBpbXBvcnQgeyBJQ2h1bmssIElDaHVua1NjZW5lIH0gZnJvbSBcInNyYy9hcHAvdHlwZXMvY2h1bmtcIjtcblxuZGVjbGFyZSBjb25zdCBEaXZlQVBJOiBEaXZlQVBJQ2xhc3M7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVN5bmNBY3Rpb25zIGV4dGVuZHMgTWFwRGlzcGF0Y2hUb1Byb3BzT2JqZWN0IHtcbiAgICBvcGVuQ2FyZDogQWN0aW9uQ3JlYXRvcjxJU3luY0FjdGlvbj47XG4gICAgZGF0YVN5bmM6IEFjdGlvbkNyZWF0b3I8dm9pZD47XG4gICAgc3RhcnRTY2VuZTogQWN0aW9uQ3JlYXRvcjxJU3luY0FjdGlvbj47XG4gICAgdXBkYXRlU2NlbmU6IEFjdGlvbkNyZWF0b3I8SVN5bmNBY3Rpb24+O1xuICAgIHNldE1vdmllOiBBY3Rpb25DcmVhdG9yPElTeW5jQWN0aW9uPjtcbiAgICBzeW5jQ2hhbm5lbDogQWN0aW9uQ3JlYXRvcjx2b2lkPjtcbiAgICBzZXRTeW5jVHlwZTogQWN0aW9uQ3JlYXRvcjxJU3luY0FjdGlvbj47XG4gICAgc2V0Q2h1bmtTdGF0dXM6IEFjdGlvbkNyZWF0b3I8SVN5bmNBY3Rpb24+O1xuICAgIHNldFNlbGVjdGVkT25TY2VuZUNoYW5nZTogQWN0aW9uQ3JlYXRvcjxJU3luY0FjdGlvbj47XG59O1xuXG4vL1xuLy8gIEFjdGlvbiBDcmVhdG9yc1xuLy9cbmV4cG9ydCBjb25zdCBzeW5jQ3JlYXRlQWN0aW9uID0gKHR5cGU6IFN5bmNBY3Rpb25UeXBlcywgcGF5bG9hZDogYW55KTogUmVkdXhBY3Rpb25zLkFjdGlvbkZ1bmN0aW9uMDxBY3Rpb24+ID0+IHtcbiAgICByZXR1cm4gY3JlYXRlQWN0aW9uKHR5cGUsIHBheWxvYWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IFN5bmNBY3Rpb25zOiBJU3luY0FjdGlvbnMgPSB7XG4gICAgb3BlbkNhcmQ6IHN5bmNDcmVhdGVBY3Rpb24oXCJTWU5DL09QRU5fQ0FSRFwiLCAoY2FyZElkOiBzdHJpbmcpID0+IChjYXJkSWQpKSxcbiAgICBzZXRNb3ZpZTogc3luY0NyZWF0ZUFjdGlvbihcIlNZTkMvU0VUX01PVklFXCIsIChtb3ZpZUlkOiBzdHJpbmcpID0+IChtb3ZpZUlkKSksXG4gICAgLy9zb2NrZXRDb25uZWN0ZWQ6IHN5bmNDcmVhdGVBY3Rpb24oXCJTT0NLRVQvQVVUSEVOVElDQVRFRFwiLCAobW92aWVJZDogc3RyaW5nKSA9PiAobW92aWVJZCkpLFxuICAgIHNldENodW5rU3RhdHVzOiBzeW5jQ3JlYXRlQWN0aW9uKFwiU1lOQy9TRVRfQ0hVTktfU1RBVFVTXCIsIChjaHVua1N0YXR1czogc3RyaW5nKSA9PiAoY2h1bmtTdGF0dXMpKSxcbiAgICBzZXRTeW5jVHlwZTogc3luY0NyZWF0ZUFjdGlvbihcIlNZTkMvU0VUX1NZTkNfVFlQRVwiLCAoc3luY1R5cGU6IFwiU09DS0VUXCIgfCBcIllPVVRVQkVcIikgPT4gKHN5bmNUeXBlKSksXG4gICAgc2V0U2VsZWN0ZWRPblNjZW5lQ2hhbmdlOiBzeW5jQ3JlYXRlQWN0aW9uKFwiU1lOQy9TRVRfU0VMRUNURURfT05fU0NFTkVfQ0hBTkdFXCIsICh2YWw6IGJvb2xlYW4pID0+ICh2YWwpKSxcbiAgICBzeW5jQ2hhbm5lbDogKHR2RXZlbnQ6IGFueS8qVHZFdmVudFJlc3BvbnNlKi8pID0+IChkaXNwYXRjaDogYW55KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1NPQ0tFVF1cIik7IFxuICAgICAgICBkaXNwYXRjaChTeW5jQWN0aW9ucy5zZXRTeW5jVHlwZShcIlNPQ0tFVFwiKSk7XG4gICAgICAgIERpdmVBUEkuc3luY1dpdGhNb3ZpZVN0cmVhbWluZyh7XG4gICAgICAgICAgICBjaGFubmVsSWQ6IFwibGEyXCIsIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgICAgIG9uRXJyb3I6ICgpID0+IHsgY29uc29sZS5sb2coXCJbU09DS0VUXSBvbkVycm9yXCIpOyB9LFxuICAgICAgICAgICAgICAgIG9uTW92aWVTdGFydDogKG1vdmllOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmllICYmIG1vdmllLm1vdmllX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChTeW5jQWN0aW9ucy5zZXRNb3ZpZShtb3ZpZS5tb3ZpZV9pZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbk1vdmllRW5kOiAoKSA9PiB7IGNvbnNvbGUubG9nKFwiW1NPQ0tFVF0gb25Nb3ZpZUVuZFwiKTsgfSxcbiAgICAgICAgICAgICAgICBvblNjZW5lU3RhcnQ6IChzY2VuZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NPQ0tFVF0gb25TY2VuZVN0YXJ0XCIsIHNjZW5lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjZW5lICYmIHNjZW5lLmNhcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChTeW5jQWN0aW9ucy5zdGFydFNjZW5lKHNjZW5lLmNhcmRzKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TY2VuZVVwZGF0ZTogKHNjZW5lOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU09DS0VUXSBvblNjZW5lVXBkYXRlXCIsIHNjZW5lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjZW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChTeW5jQWN0aW9ucy51cGRhdGVTY2VuZShzY2VuZSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uU2NlbmVFbmQ6ICgpID0+IHsgY29uc29sZS5sb2coXCJbU09DS0VUXSBvblNjZW5lRW5kXCIpOyB9LFxuICAgICAgICAgICAgICAgIG9uUGF1c2VTdGFydDogKCkgPT4geyBjb25zb2xlLmxvZyhcIltTT0NLRVRdIG9uUGF1c2VTdGFydFwiKTsgfSxcbiAgICAgICAgICAgICAgICBvblBhdXNlRW5kOiAoKSA9PiB7IGNvbnNvbGUubG9nKFwiW1NPQ0tFVF0gb25QYXVzZUVuZFwiKTsgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBkYXRhU3luYzogKG1vdmllSWQ6IHN0cmluZykgPT4gKGRpc3BhdGNoOiBhbnkpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goU3luY0FjdGlvbnMuc2V0Q2h1bmtTdGF0dXMoXCJMT0FESU5HXCIpKTtcbiAgICAgICAgLy8gZGlzcGF0Y2goU3luY0FjdGlvbnMuc2V0TW92aWUobW92aWVJZCkpO1xuICAgICAgICAvLyBkaXNwYXRjaChTeW5jQWN0aW9ucy51cGRhdGVUaW1lKDU1NTUpKTsgLy8gRXN0byBoYXkgcXVlIHF1aXRhcmxvLiBlcyBwYXJhIHByb2Jhci5cbiAgICB9LFxuICAgIHN0YXJ0U2NlbmU6IHN5bmNDcmVhdGVBY3Rpb24oXCJTWU5DL1NUQVJUX1NDRU5FXCIsIChjYXJkczogQXJyYXk8Q2FyZD5bXSkgPT4gKGNhcmRzKSksXG4gICAgdXBkYXRlU2NlbmU6IHN5bmNDcmVhdGVBY3Rpb24oXCJTWU5DL1VQREFURV9TQ0VORVwiLCAoY2FyZHM6IEFycmF5PENhcmQ+W10pID0+IChjYXJkcykpLFxuICAgIGVuZFNjZW5lOiBzeW5jQ3JlYXRlQWN0aW9uKFwiU1lOQy9FTkRfU0NFTkVcIiwgKGNhcmRzOiBBcnJheTxDYXJkPltdKSA9PiAoY2FyZHMpKSxcbiAgICBzZXRUaW1lOiBzeW5jQ3JlYXRlQWN0aW9uKFwiU1lOQy9TRVRfVElNRVwiLCAodGltZTogbnVtYmVyKSA9PiAodGltZSkpLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FjdGlvbnMvc3luYy5hY3Rpb25zLnRzeCIsImltcG9ydCB7IEFjdGlvbiB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IC8qTWFwRGlzcGF0Y2hUb1Byb3BzLCAqL01hcERpc3BhdGNoVG9Qcm9wc09iamVjdCwgQWN0aW9uQ3JlYXRvciB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbi8qLCBBY3Rpb25GdW5jdGlvbjAqLyB9IGZyb20gJ3JlZHV4LWFjdGlvbnMnO1xuaW1wb3J0IHtDYXJkfSBmcm9tICdTZXJ2aWNlcydcblxuZXhwb3J0IHR5cGUgU29ja2V0QWN0aW9uVHlwZXMgPSBcIlNPQ0tFVC9BVVRIRU5USUNBVEVEXCIgfCBcIlNPQ0tFVC9VTkFVVEhPUklaRURcIiB8IFwiU09DS0VUL0VSUk9SXCJcbiAgICB8IFwiU09DS0VUL01PVklFX1NUQVJUXCIgfCBcIlNPQ0tFVC9NT1ZJRV9FTkRcIiB8IFwiU09DS0VUL1NDRU5FX1NUQVJUXCJcbiAgICB8IFwiU09DS0VUL1NDRU5FX1VQREFURVwiIHwgXCJTT0NLRVQvU0NFTkVfRU5EXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNvY2tldERhdGFVbmF1dGggZXh0ZW5kcyBPYmplY3Qge1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICBjb2RlOiBzdHJpbmc7XG4gICAgdHlwZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElTb2NrZXREYXRhRXJyb3IgZXh0ZW5kcyBPYmplY3Qge1xuICAgIHN0YXR1czogbnVtYmVyO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNvY2tldERhdGFNb3ZpZVN0YXJ0IGV4dGVuZHMgT2JqZWN0IHtcbiAgICBtb3ZpZV9pZDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNvY2tldERhdGFDYXJkcyBleHRlbmRzIE9iamVjdCB7XG4gICAgY2FyZHM/OiBDYXJkW11cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIElTb2NrZXRBY3Rpb25zIGV4dGVuZHMgTWFwRGlzcGF0Y2hUb1Byb3BzT2JqZWN0IHtcblxuICAgIHVuYXV0aFJlY2VpdmVkOiBBY3Rpb25DcmVhdG9yPElTb2NrZXRBY3Rpb24+O1xuICAgIGVycm9yUmVjZWl2ZWQ6IEFjdGlvbkNyZWF0b3I8SVNvY2tldEFjdGlvbj47XG4gICAgbW92aWVTdGFydFJlY2VpdmVkOiBBY3Rpb25DcmVhdG9yPElTb2NrZXRBY3Rpb24+O1xuICAgIHNjZW5lU3RhcnRSZWNlaXZlZDogQWN0aW9uQ3JlYXRvcjxJU29ja2V0QWN0aW9uPjtcbiAgICBzY2VuZVVwZGF0ZVJlY2VpdmVkOiBBY3Rpb25DcmVhdG9yPElTb2NrZXRBY3Rpb24+O1xuXG59XG5cbiBleHBvcnQgaW50ZXJmYWNlIElTb2NrZXRBY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xuICAgICAgdHlwZTogU29ja2V0QWN0aW9uVHlwZXM7XG4gICAgICBwYXlsb2FkPzogSVNvY2tldERhdGFVbmF1dGggfCBJU29ja2V0RGF0YUVycm9yIHwgSVNvY2tldERhdGFNb3ZpZVN0YXJ0IHwgSVNvY2tldERhdGFDYXJkc1xufVxuXG5mdW5jdGlvbiBzb2NrZXRDcmVhdGVBY3Rpb24oXG4gICAgdHlwZTogU29ja2V0QWN0aW9uVHlwZXMsXG4gICAgcGF5bG9hZD86IElTb2NrZXREYXRhVW5hdXRoIHwgSVNvY2tldERhdGFFcnJvciB8IElTb2NrZXREYXRhTW92aWVTdGFydCB8IElTb2NrZXREYXRhQ2FyZHMgfCBhbnksXG4pOiBSZWR1eEFjdGlvbnMuQWN0aW9uRnVuY3Rpb24wPEFjdGlvbj4ge1xuICAgIHJldHVybiBjcmVhdGVBY3Rpb24odHlwZSwgcGF5bG9hZCk7XG59XG5cbmV4cG9ydCBjb25zdCBTb2NrZXRBY3Rpb25zOiBJU29ja2V0QWN0aW9ucyA9IHtcblxuICAgIGF1dGhSZWNlaXZlZDogc29ja2V0Q3JlYXRlQWN0aW9uKFwiU09DS0VUL0FVVEhFTlRJQ0FURURcIiksXG4gICAgdW5hdXRoUmVjZWl2ZWQ6IHNvY2tldENyZWF0ZUFjdGlvbihcIlNPQ0tFVC9VTkFVVEhPUklaRURcIiwgKHBheWxvYWQ6IElTb2NrZXREYXRhVW5hdXRoKTogSVNvY2tldERhdGFVbmF1dGggPT4gKHBheWxvYWQpKSxcbiAgICBlcnJvclJlY2VpdmVkOiBzb2NrZXRDcmVhdGVBY3Rpb24oXCJTT0NLRVQvRVJST1JcIiwgKHBheWxvYWQ6IElTb2NrZXREYXRhRXJyb3IpOiBJU29ja2V0RGF0YUVycm9yID0+IChwYXlsb2FkKSksXG5cbiAgICBtb3ZpZVN0YXJ0UmVjZWl2ZWQ6IHNvY2tldENyZWF0ZUFjdGlvbihcIlNPQ0tFVC9NT1ZJRV9TVEFSVFwiLCAocGF5bG9hZDogSVNvY2tldERhdGFNb3ZpZVN0YXJ0KTogSVNvY2tldERhdGFNb3ZpZVN0YXJ0ID0+IChwYXlsb2FkKSksXG4gICAgbW92aWVFbmRSZWNlaXZlZDogc29ja2V0Q3JlYXRlQWN0aW9uKFwiU09DS0VUL01PVklFX0VORFwiKSxcbiAgICBcbiAgICBzY2VuZVN0YXJ0UmVjZWl2ZWQ6IHNvY2tldENyZWF0ZUFjdGlvbihcIlNPQ0tFVC9TQ0VORV9TVEFSVFwiLCAocGF5bG9hZDogSVNvY2tldERhdGFDYXJkcyk6IElTb2NrZXREYXRhQ2FyZHMgPT4gKHBheWxvYWQpKSxcbiAgICBzY2VuZVVwZGF0ZVJlY2VpdmVkOiBzb2NrZXRDcmVhdGVBY3Rpb24oXCJTT0NLRVQvU0NFTkVfVVBEQVRFXCIsIChwYXlsb2FkOiBJU29ja2V0RGF0YUNhcmRzKTogSVNvY2tldERhdGFDYXJkcyA9PiAocGF5bG9hZCkpLFxuICAgIHNjZW5lRW5kUmVjZWl2ZWQ6IHNvY2tldENyZWF0ZUFjdGlvbihcIlNPQ0tFVC9TQ0VORV9FTkRcIiksIFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FjdGlvbnMvc29ja2V0LmFjdGlvbnMudHN4IiwiaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgTWFwRGlzcGF0Y2hUb1Byb3BzT2JqZWN0LCBBY3Rpb25DcmVhdG9yIH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgY3JlYXRlQWN0aW9uIH0gZnJvbSAncmVkdXgtYWN0aW9ucyc7XG5cbmltcG9ydCB7IElVc2VyQWN0aW9uLCBVc2VyQWN0aW9uVHlwZXMsIElVc2VyU3RhdGUgfSBmcm9tIFwiUmVkdWNlcnNcIjtcbmltcG9ydCB7ICBDYXJkLCBEaXZlQVBJQ2xhc3MgfSBmcm9tIFwiQGRpdmUtdHYvYXBpLXR5cGVzY3JpcHQtbGlicmFyeVwiO1xuXG5kZWNsYXJlIGNvbnN0IERpdmVBUEk6IERpdmVBUElDbGFzcztcblxuZXhwb3J0IGludGVyZmFjZSBJVXNlckFjdGlvbnMgZXh0ZW5kcyBNYXBEaXNwYXRjaFRvUHJvcHNPYmplY3Qge1xuICAgIHNldFVzZXI6IEFjdGlvbkNyZWF0b3I8SVVzZXJBY3Rpb24+O1xuICAgIGxpa2VDYXJkOiBBY3Rpb25DcmVhdG9yPGFueT47XG59XG5cbmV4cG9ydCBjb25zdCB1c2VyQ3JlYXRlQWN0aW9uID0gKHR5cGU6IFVzZXJBY3Rpb25UeXBlcywgcGF5bG9hZD86IGFueSk6IFJlZHV4QWN0aW9ucy5BY3Rpb25GdW5jdGlvbjA8QWN0aW9uPiA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUFjdGlvbih0eXBlLCBwYXlsb2FkKTtcbn07XG4vKlxuZXhwb3J0IGNvbnN0IFVzZXJBY3Rpb25zOiBJVXNlckFjdGlvbnMgPSB7XG4gICAgLy8gc2V0VXNlcjogdXNlckNyZWF0ZUFjdGlvbihcIlVTRVIvU0VUX1VTRVJcIiwgKHVzZXI6IFVzZXJQcm9maWxlUmVzcG9uc2UpID0+ICh1c2VyIGFzIElVc2VyU3RhdGUpKSxcbiAgICBsaWtlQ2FyZDogKGNhcmQ6IENhcmQpID0+IChkaXNwYXRjaDogYW55KSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBEaXZlQVBJLnBvc3RMaWtlcyh7IGNhcmRJZDogY2FyZC5jYXJkX2lkIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBCb3R0b20gbWVzc2FnZSBcIkxpa2VkXCIgPyBvciBqdXN0IGNoYW5nZSB0aGUgaWNvbj87XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBHbyB0byBsb2dpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkdPIFRPIExPR0lOXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIGNhcmRcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG59OyovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hY3Rpb25zL3VzZXIuYWN0aW9ucy50c3giLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyB3cyAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDUxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgKiBmcm9tICcuL25hdi5yZWR1Y2VyJztcbmV4cG9ydCAqIGZyb20gJy4vdWkucmVkdWNlcic7XG5leHBvcnQgKiBmcm9tICcuL3N5bmMucmVkdWNlcic7XG5leHBvcnQgKiBmcm9tICcuL3VzZXIucmVkdWNlcic7XG5cbmV4cG9ydCAqIGZyb20gJy4vcmVkdWNlcic7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZWR1Y2Vycy9pbmRleC50cyIsImltcG9ydCB7IEFjdGlvbiB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IElOYXZpZ2FibGUgfSBmcm9tICdIT0MnO1xuLy9cbi8vICBBY3Rpb25zXG4vL1xuZXhwb3J0IHR5cGUgTmF2QWN0aW9uVHlwZXMgPSBcIk5BVi9BRERfTk9ERVwiIHwgXCJOQVYvREVMRVRFX05PREVcIiB8IFwiTkFWL0tFWVwiIHwgXCJOQVYvU0VMRUNURURcIiB8IFwiTkFWL0FDVElWQVRFRFwiIHxcbiAgICBcIk5BVi9TRUxFQ1RfTEVBRlwiIHxcbiAgICBcIk5BVi9NT1ZFX0hPUklaT05UQUxcIiB8IFwiTkFWL01PVkVfVkVSVElDQUxcIiB8IFwiTkFWL1NFTEVDVF9CWV9JRFwiIHwgXCJOQVYvU0VMRUNUX0JZX05BTUVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJTmF2QWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgICB0eXBlOiBOYXZBY3Rpb25UeXBlcztcbiAgICBwYXlsb2FkPzogYW55O1xufVxuZXhwb3J0IGludGVyZmFjZSBJTmF2U3RhdGUge1xuICAgIG5hdmlnYXRpb246IE1hcDxudW1iZXIsIElOYXZpZ2FibGU+O1xuICAgIGxhc3RLZXk6IHN0cmluZztcbiAgICBzZWxlY3RlZDogbnVtYmVyO1xuICAgIHNlbGVjdGVkTmF2OiBJTmF2aWdhYmxlIHwgdW5kZWZpbmVkO1xuICAgIGxhc3RTZWxlY3RlZDogbnVtYmVyO1xuICAgIGFjdGl2YXRlZDogbnVtYmVyO1xuICAgIGxhc3RBY3RpdmF0ZWQ6IG51bWJlcjtcbiAgICBuYXZOYW1lczogTWFwPHN0cmluZywgbnVtYmVyPjtcbn1cblxudHlwZSBLZXlBcnJvd3MgPSBcIlVQXCIgfCBcIkRPV05cIiB8IFwiUklHSFRcIiB8IFwiTEVGVFwiO1xuXG5leHBvcnQgY29uc3QgTmF2UmVkdWNlciA9IChzdGF0ZTogSU5hdlN0YXRlID0gaW5pdGlhbE5hdlN0YXRlLCBhY3Rpb246IElOYXZBY3Rpb24pOiBJTmF2U3RhdGUgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiW0NVUlJFTlRdW05hdlJlZHVjZXJdIHN0YXRlOiBcIiwgc3RhdGUpO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnTkFWL0FERF9OT0RFJzpcbiAgICAgICAgICAgIGNvbnN0IG5hdjogSU5hdmlnYWJsZSA9IGFjdGlvbi5wYXlsb2FkIGFzIElOYXZpZ2FibGU7XG5cbiAgICAgICAgICAgIC8vIElOSVQgUEFSRU5UIElGIElTIE5PVCBTRVRURUQuIFVQREFURSBQQVJFTlQgSUYgSVMgU0VUVEVEXG4gICAgICAgICAgICBpZiAobmF2LnBhcmVudElkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFN0YXRlOiBJTmF2aWdhYmxlID0gc3RhdGUubmF2aWdhdGlvbi5nZXQobmF2LnBhcmVudElkKSBhcyBJTmF2aWdhYmxlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm5hdmlnYXRpb24uc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2LnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwYXJlbnRJZDogLTEsIGlkOiBuYXYucGFyZW50SWQsIGNoaWxkcmVuOiBbW25hdi5pZF1dLCBjb2x1bW5zOiAxIH0sXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdENoaWxkcmVuVHVwbGFJbmRleCA9IHBhcmVudFN0YXRlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZHJlblR1cGxhTGVuZ3RoOiBudW1iZXIgPSBwYXJlbnRTdGF0ZS5jaGlsZHJlbltsYXN0Q2hpbGRyZW5UdXBsYUluZGV4XS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYXYuY29sdW1ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXYuY29sdW1ucyA9PT0gbGFzdENoaWxkcmVuVHVwbGFMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFN0YXRlLmNoaWxkcmVuID0gWy4uLnBhcmVudFN0YXRlLmNoaWxkcmVuLCBbbmF2LmlkXV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmF2LmZvcmNlT3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc28gZW4gZWwgcXVlIHF1ZXJlbW9zIGZvcnphciBlbCBvcmRlbiBkZWwgZWxlbWVudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnI6IG51bWJlcltdID0gWy4uLnBhcmVudFN0YXRlLmNoaWxkcmVuW2xhc3RDaGlsZHJlblR1cGxhSW5kZXhdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIuc3BsaWNlKG5hdi5mb3JjZU9yZGVyLCAwLCBuYXYuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFN0YXRlLmNoaWxkcmVuW2xhc3RDaGlsZHJlblR1cGxhSW5kZXhdID0gYXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXNvIG5vcm1hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFN0YXRlLmNoaWxkcmVuW2xhc3RDaGlsZHJlblR1cGxhSW5kZXhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWy4uLnBhcmVudFN0YXRlLmNoaWxkcmVuW2xhc3RDaGlsZHJlblR1cGxhSW5kZXhdLCBuYXYuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnNldChwYXJlbnRTdGF0ZS5pZCwgcGFyZW50U3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSU5JVCBDVVJSRU5UIEVMRU1FTlQgSUYgSVMgTk9UIFNFVFRFRC5cbiAgICAgICAgICAgIGNvbnN0IG5hdlN0YXRlOiBJTmF2aWdhYmxlIHwgdW5kZWZpbmVkID0gc3RhdGUubmF2aWdhdGlvbi5nZXQobmF2LmlkKTtcbiAgICAgICAgICAgIGlmIChuYXZTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUubmF2aWdhdGlvbi5zZXQobmF2LmlkLCBuYXYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnNldChuYXYuaWQsIHsgLi4ubmF2LCAuLi5uYXZTdGF0ZSwgcGFyZW50SWQ6IG5hdi5wYXJlbnRJZCB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5hdi5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5uYXZOYW1lcy5zZXQobmF2Lm5hbWUsIG5hdi5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcblxuICAgICAgICBjYXNlICdOQVYvREVMRVRFX05PREUnOlxuICAgICAgICAgICAgY29uc3QgZGVsZXRlTmF2OiBJTmF2aWdhYmxlIHwgdW5kZWZpbmVkID0gc3RhdGUubmF2aWdhdGlvbi5nZXQoYWN0aW9uLnBheWxvYWQpO1xuICAgICAgICAgICAgLy8gREVMRVRFIEZST00gUEFSRU5UXG4gICAgICAgICAgICBpZiAoZGVsZXRlTmF2ICE9PSB1bmRlZmluZWQgJiYgZGVsZXRlTmF2LnBhcmVudElkID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVOYXZQYXJlbnQ6IElOYXZpZ2FibGUgfCB1bmRlZmluZWQgPSBzdGF0ZS5uYXZpZ2F0aW9uLmdldChkZWxldGVOYXYucGFyZW50SWQpO1xuICAgICAgICAgICAgICAgIGlmIChkZWxldGVOYXZQYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbGV0ZU5hdlBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpbmRleE9mKGRlbGV0ZU5hdlBhcmVudC5jaGlsZHJlbltpXSwgYWN0aW9uLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFsuLi5kZWxldGVOYXZQYXJlbnQuY2hpbGRyZW5baV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZU5hdlBhcmVudC5jaGlsZHJlbltpXSA9IGNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlTmF2UGFyZW50LmNoaWxkcmVuLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5uYXZpZ2F0aW9uLnNldChkZWxldGVOYXZQYXJlbnQuaWQsIGRlbGV0ZU5hdlBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBERUxFVEUgQ1VSUkVOVFxuICAgICAgICAgICAgaWYgKGRlbGV0ZU5hdiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUubmF2aWdhdGlvbi5kZWxldGUoZGVsZXRlTmF2LmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuXG4gICAgICAgIGNhc2UgJ05BVi9LRVknOlxuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGxhc3RLZXk6IGFjdGlvbi5wYXlsb2FkIH07XG5cbiAgICAgICAgY2FzZSAnTkFWL1NFTEVDVEVEJzpcbiAgICAgICAgICAgIGlmIChpc091dE9mTW9kYWwoc3RhdGUubmF2aWdhdGlvbiwgc3RhdGUuc2VsZWN0ZWQsIGFjdGlvbi5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBsYXN0U2VsZWN0ZWQ6IHN0YXRlLnNlbGVjdGVkLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE5hdjogc3RhdGUubmF2aWdhdGlvbi5nZXQoYWN0aW9uLnBheWxvYWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnTkFWL1NFTEVDVF9MRUFGJzpcbiAgICAgICAgICAgIGNvbnN0IGlkOiBudW1iZXIgPSBnZXRGaXJzdExlYWYoc3RhdGUsIGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgbGFzdFNlbGVjdGVkOiBzdGF0ZS5zZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogaWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWROYXY6IHN0YXRlLm5hdmlnYXRpb24uZ2V0KGlkKSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgY2FzZSAnTkFWL0FDVElWQVRFRCc6XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSwgbGFzdEFjdGl2YXRlZDogc3RhdGUuYWN0aXZhdGVkLCBhY3RpdmF0ZWQ6IGFjdGlvbi5wYXlsb2FkIH07XG5cbiAgICAgICAgY2FzZSAnTkFWL01PVkVfSE9SSVpPTlRBTCc6XG4gICAgICAgICAgICBsZXQgbmV3U2VsZWN0ZWQgPSBzdGF0ZS5zZWxlY3RlZDtcbiAgICAgICAgICAgIGxldCBsb29wU2VsZWN0ZWQgPSBzdGF0ZS5zZWxlY3RlZDtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQ6IElOYXZpZ2FibGUgfCB1bmRlZmluZWQgPSBzdGF0ZS5uYXZpZ2F0aW9uLmdldChzdGF0ZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnQucGFyZW50SWQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQ6IElOYXZpZ2FibGUgfCB1bmRlZmluZWQgPSBzdGF0ZS5uYXZpZ2F0aW9uLmdldChjdXJyZW50LnBhcmVudElkKTtcbiAgICAgICAgICAgICAgICBsZXQgbG9vcGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBsb29wV2hpbGU6XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxvb3BpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9vcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbG9vcDE6XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdCBvZiBwYXJlbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGlzdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bTogbnVtYmVyID0gbGlzdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtID09PSBsb29wU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW4gZWwgY2FzbyBkZSBxdWUgZWwgZWxlbWVudG8gcG9yIGVsIHF1ZSBzZSB2YSBhIHBhc2FyIHNlYSBtb2RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0b3JuYW1vcyBlbCBzdGF0ZSBhbnRlcmlvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzdGF0ZS5uYXZpZ2F0aW9uLmdldChsb29wU2VsZWN0ZWQpIGFzIElOYXZpZ2FibGUpLm1vZGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLnBheWxvYWQgPT09IDEgJiYgaiA8IGxpc3QubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBzZWxlY3RlZCB0aGUgZWxlbWVudCwgZ28gZG93biBpbiBub2RlcyB1bnRpbCBsZWFmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RlZCA9IGdldEZpcnN0TGVhZihzdGF0ZSwgbGlzdFtqICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgbG9vcFdoaWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbi5wYXlsb2FkID09PSAtMSAmJiBqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBzZWxlY3RlZCB0aGUgZWxlbWVudCwgZ28gZG93biBpbiBub2RlcyB1bnRpbCBsZWFmKHRoZSBsYXN0IG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGVkID0gZ2V0TGFzdExlYWYoc3RhdGUsIGxpc3RbaiAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3BXaGlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5wYXJlbnRJZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcFNlbGVjdGVkID0gcGFyZW50LmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHN0YXRlLm5hdmlnYXRpb24uZ2V0KHBhcmVudC5wYXJlbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgbG9vcDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsIGxhc3RTZWxlY3RlZDogc3RhdGUuc2VsZWN0ZWQsIHNlbGVjdGVkOiBuZXdTZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE5hdjogc3RhdGUubmF2aWdhdGlvbi5nZXQobmV3U2VsZWN0ZWQpLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdOQVYvTU9WRV9WRVJUSUNBTCc6XG4gICAgICAgICAgICBsZXQgbmV3U2VsZWN0ZWQyID0gc3RhdGUuc2VsZWN0ZWQ7XG4gICAgICAgICAgICBsZXQgbG9vcFNlbGVjdGVkMiA9IHN0YXRlLnNlbGVjdGVkO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudDI6IElOYXZpZ2FibGUgfCB1bmRlZmluZWQgPSBzdGF0ZS5uYXZpZ2F0aW9uLmdldChzdGF0ZS5zZWxlY3RlZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudDIgIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50Mi5wYXJlbnRJZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudDogSU5hdmlnYWJsZSB8IHVuZGVmaW5lZCA9IHN0YXRlLm5hdmlnYXRpb24uZ2V0KGN1cnJlbnQyLnBhcmVudElkKTtcbiAgICAgICAgICAgICAgICBsZXQgbG9vcGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBsb29wV2hpbGU6XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxvb3BpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9vcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbG9vcDE6XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkcmVuW2pdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gaW5kZXhPZihwYXJlbnQuY2hpbGRyZW5bal0sIGxvb3BTZWxlY3RlZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtOiBudW1iZXIgPSBwYXJlbnQuY2hpbGRyZW5bal1baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW0gPT09IGxvb3BTZWxlY3RlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW4gZWwgY2FzbyBkZSBxdWUgZWwgZWxlbWVudG8gcG9yIGVsIHF1ZSBzZSB2YSBhIHBhc2FyIHNlYSBtb2RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0b3JuYW1vcyBlbCBzdGF0ZSBhbnRlcmlvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzdGF0ZS5uYXZpZ2F0aW9uLmdldChsb29wU2VsZWN0ZWQyKSBhcyBJTmF2aWdhYmxlKS5tb2RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24ucGF5bG9hZCA9PT0gMSAmJiBqIDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9uY2Ugc2VsZWN0ZWQgdGhlIGVsZW1lbnQsIGdvIGRvd24gaW4gbm9kZXMgdW50aWwgbGVhZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0ZWQyID0gZ2V0Rmlyc3RMZWFmKHN0YXRlLCBwYXJlbnQuY2hpbGRyZW5baiArIDFdWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3BXaGlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24ucGF5bG9hZCA9PT0gLTEgJiYgaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9uY2Ugc2VsZWN0ZWQgdGhlIGVsZW1lbnQsIGdvIGRvd24gaW4gbm9kZXMgdW50aWwgbGVhZih0aGUgbGFzdCBvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RlZDIgPSBnZXRMYXN0TGVhZihzdGF0ZSwgcGFyZW50LmNoaWxkcmVuW2ogLSAxXVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wV2hpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnBhcmVudElkID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wU2VsZWN0ZWQyID0gcGFyZW50LmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHN0YXRlLm5hdmlnYXRpb24uZ2V0KHBhcmVudC5wYXJlbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgbG9vcDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsIGxhc3RTZWxlY3RlZDogc3RhdGUuc2VsZWN0ZWQsIHNlbGVjdGVkOiBuZXdTZWxlY3RlZDIsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWROYXY6IHN0YXRlLm5hdmlnYXRpb24uZ2V0KG5ld1NlbGVjdGVkMiksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ05BVi9TRUxFQ1RfQllfTkFNRSc6XG4gICAgICAgICAgICBjb25zdCBuYW1lOiBzdHJpbmcgPSBhY3Rpb24ucGF5bG9hZCBhcyBzdHJpbmc7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25CeU5hbWU6IG51bWJlciA9IGdldEZpcnN0TGVhZihzdGF0ZSwgc3RhdGUubmF2TmFtZXMuZ2V0KG5hbWUpIGFzIG51bWJlcik7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uQnlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZSwgbGFzdFNlbGVjdGVkOiBzdGF0ZS5zZWxlY3RlZCwgc2VsZWN0ZWQ6IHNlbGVjdGlvbkJ5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWROYXY6IHN0YXRlLm5hdmlnYXRpb24uZ2V0KHNlbGVjdGlvbkJ5TmFtZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ05BVi9TRUxFQ1RfQllfSUQnOlxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uQnlJZDogbnVtYmVyID0gZ2V0Rmlyc3RMZWFmKHN0YXRlLCBhY3Rpb24ucGF5bG9hZCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uQnlJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsIGxhc3RTZWxlY3RlZDogc3RhdGUuc2VsZWN0ZWQsIHNlbGVjdGVkOiBzZWxlY3Rpb25CeUlkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE5hdjogc3RhdGUubmF2aWdhdGlvbi5nZXQoc2VsZWN0aW9uQnlJZCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufTtcblxuLy8gR2V0IGNoaWxkcmVuIHJlY3Vyc2l2ZWx5IGFuZCByZXR1cm4gYWxsIG9mIHRoZW0gaW4gYW4gYXJyYXlcbmNvbnN0IGdldFJlY3Vyc2l2ZUNoaWxkcmVuID0gKG5hdmlnYXRpb246IE1hcDxudW1iZXIsIElOYXZpZ2FibGU+LCBpZDogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xuICAgIC8vIERFTEVURSBSRUNVUlNJVkUgQ0hJTERTXG4gICAgbGV0IGJlZm9yZTogbnVtYmVyW10gPSBbXTtcbiAgICBjb25zdCBub2RlOiBJTmF2aWdhYmxlIHwgdW5kZWZpbmVkID0gbmF2aWdhdGlvbi5nZXQoaWQpO1xuICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1mb3Itb2ZcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cHJlZmVyLWZvci1vZlxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmNoaWxkcmVuW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlID0gWy4uLmJlZm9yZSwgbm9kZS5jaGlsZHJlbltpXVtqXV07XG4gICAgICAgICAgICAgICAgYmVmb3JlID0gWy4uLmJlZm9yZSwgLi4uZ2V0UmVjdXJzaXZlQ2hpbGRyZW4obmF2aWdhdGlvbiwgbm9kZS5jaGlsZHJlbltpXVtqXSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlZm9yZTtcbn07XG5cbi8vIFRPRE8gR0VUIEZJUlNUIGNoaWxkIHRoYXQgaXMgbGVhZi5cbmNvbnN0IGdldEZpcnN0TGVhZiA9IChzdGF0ZTogSU5hdlN0YXRlLCBpZDogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICBsZXQgY3VycmVudDogSU5hdmlnYWJsZSB8IHVuZGVmaW5lZCA9IHN0YXRlLm5hdmlnYXRpb24uZ2V0KGlkKTtcbiAgICBsZXQgbG9vcGluZyA9IHRydWU7XG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCAmJiBsb29waW5nKSB7XG4gICAgICAgIGlmIChjdXJyZW50LmNoaWxkcmVuWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBzdGF0ZS5uYXZpZ2F0aW9uLmdldChjdXJyZW50LmNoaWxkcmVuWzBdWzBdKSBhcyBJTmF2aWdhYmxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9vcGluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICB9XG4gICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY3VycmVudC5pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG59O1xuXG4vLyBHZXQgbGFzdCBjaGlsZCBsZWFmXG5jb25zdCBnZXRMYXN0TGVhZiA9IChzdGF0ZTogSU5hdlN0YXRlLCBpZDogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICBsZXQgY3VycmVudDogSU5hdmlnYWJsZSB8IHVuZGVmaW5lZCA9IHN0YXRlLm5hdmlnYXRpb24uZ2V0KGlkKTtcbiAgICBsZXQgbG9vcGluZyA9IHRydWU7XG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCAmJiBsb29waW5nKSB7XG4gICAgICAgIGlmIChjdXJyZW50LmZvcmNlRmlyc3QgPT09IHRydWUgJiYgY3VycmVudC5jaGlsZHJlblswXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gc3RhdGUubmF2aWdhdGlvbi5nZXQoY3VycmVudC5jaGlsZHJlblswXVswXSkgYXMgSU5hdmlnYWJsZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50LmNoaWxkcmVuW2N1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcG9zOiBudW1iZXIgPSBjdXJyZW50LmNoaWxkcmVuW2N1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV1bY3VycmVudC5jaGlsZHJlblswXS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBzdGF0ZS5uYXZpZ2F0aW9uLmdldChwb3MpIGFzIElOYXZpZ2FibGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb29waW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LmlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG59O1xuXG5jb25zdCBpbmRleE9mID0gKGFycmF5OiBudW1iZXJbXSwgbnVtOiBudW1iZXIpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gbnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5jb25zdCBpc091dE9mTW9kYWwgPSAobmF2aWdhdGlvbjogTWFwPG51bWJlciwgSU5hdmlnYWJsZT4sIGlkOiBudW1iZXIsIG5ld0lkOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgICBsZXQgaWRNb2RhbDogbnVtYmVyID0gLTE7XG4gICAgbGV0IG5hdjogSU5hdmlnYWJsZTtcbiAgICAvLyBNaXJhbW9zIHNpIGxhIHNlbGVjY2nDs24gYWN0dWFsIHRpZW5lIGFsZ8O6biBwYWRyZSBtb2RhbFxuICAgIGRvIHtcbiAgICAgICAgbmF2ID0gbmF2aWdhdGlvbi5nZXQoaWQpICBhcyBJTmF2aWdhYmxlO1xuICAgICAgICBpZiAobmF2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hdi5tb2RhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWRNb2RhbCA9IG5hdi5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZCA9IG5hdi5wYXJlbnRJZDtcbiAgICB9IHdoaWxlIChpZE1vZGFsIDwgMCAmJiBpZCAhPT0gdW5kZWZpbmVkKTtcblxuICAgIGlmIChpZE1vZGFsID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTWlyYW1vcyBzaSBlbiBsYSBudWV2YSBzZWxlY2Npw7NuIGVzdMOhIGVsIHBhZHJlIG1vZGFsLCBzaSBzZSBoYSBlbmNvbnRyYWRvIHVubyBwcmV2aWFtZW50ZS5cbiAgICBpZiAoaWRNb2RhbCA+PSAwKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5hdiA9IG5hdmlnYXRpb24uZ2V0KG5ld0lkKSAgYXMgSU5hdmlnYWJsZTtcbiAgICAgICAgICAgIGlmIChuYXYuaWQgPT09IGlkTW9kYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZCA9IG5hdi5wYXJlbnRJZDtcbiAgICAgICAgfSB3aGlsZSAoaWRNb2RhbCA8IDAgJiYgaWQgIT09IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbE5hdlN0YXRlOiBJTmF2U3RhdGUgPSB7XG4gICAgbmF2aWdhdGlvbjogbmV3IE1hcDxudW1iZXIsIElOYXZpZ2FibGU+KCksXG4gICAgbGFzdEtleTogJycsXG4gICAgc2VsZWN0ZWQ6IDMsXG4gICAgc2VsZWN0ZWROYXY6IHVuZGVmaW5lZCxcbiAgICBhY3RpdmF0ZWQ6IC0xLFxuICAgIGxhc3RTZWxlY3RlZDogLTEsXG4gICAgbGFzdEFjdGl2YXRlZDogLTEsXG4gICAgbmF2TmFtZXM6IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCksXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVkdWNlcnMvbmF2LnJlZHVjZXIudHMiLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBDYXJkLCBMb2NhbGl6ZSB9IGZyb20gJ1NlcnZpY2VzJztcbi8vXG4vLyAgQWN0aW9uc1xuLy9cbmV4cG9ydCB0eXBlIFVJQWN0aW9uVHlwZXMgPSBcIlVJL1NFVF9ESVZJREVSXCIgfCBcIlVJL1VJX0JBQ0tcIiB8IFwiVUkvT1BFTl9TWU5DXCIgfFxuICAgIFwiVUkvT1BFTl9DQVJEXCIgfCBcIlVJL09QRU5cIiB8IFwiVUkvQUREX1RFU1RfQ0FSRFNcIjtcblxuZXhwb3J0IHR5cGUgVUlMYXllclRvcFR5cGVzID0gXCJUVlwiIHwgXCJFTVBUWVwiO1xuZXhwb3J0IHR5cGUgVUlMYXllckJvdHRvbVR5cGVzID0gXCJDQVJPVVNFTFwiIHwgXCJDQVJEXCIgfCBcIkNBUkRTXCIgfFxuICAgIFwiUFJPRklMRVwiIHwgXCJIRUxQXCIgfCBcIkVSUk9SXCIgfCBcIkVNUFRZXCI7XG5cbnR5cGUgS2V5QXJyb3dzID0gXCJVUFwiIHwgXCJET1dOXCIgfCBcIlJJR0hUXCIgfCBcIkxFRlRcIjtcbmV4cG9ydCB0eXBlIE1lbnVWaXN1YWxTdGF0ZSA9IFwiVklTSUJMRVwiIHwgXCJISURFXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU1lbnVFbGVtZW50IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgc2VjdGlvbnM6IElVSUdyb3VwO1xuICAgIGljb246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVUlTdGF0ZSB7XG4gICAgY29udGFpbmVyczogSVVJQ29udGFpbmVyW107XG4gICAgZGl2aWRlcjogRGl2aWRlclNpemU7XG4gICAgY2FyZD86IENhcmQ7XG4gICAgdGVzdENhcmRzOiBBcnJheTx7IGNhcmRfaWQ6IHN0cmluZywgdmVyc2lvbj86IHN0cmluZyB9Pjtcbn1cblxuLy9cbi8vICBBY3Rpb25zXG4vL1xuZXhwb3J0IGludGVyZmFjZSBJVUlHcm91cCB7XG4gICAgdG9wOiBVSUxheWVyVG9wVHlwZXM7XG4gICAgYm90dG9tOiBVSUxheWVyQm90dG9tVHlwZXM7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIElVSUNvbnRhaW5lciB7XG4gICAgY29tcG9uZW50OiBVSUxheWVyVG9wVHlwZXMgfCBVSUxheWVyQm90dG9tVHlwZXM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVVJQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcbiAgICB0eXBlOiBVSUFjdGlvblR5cGVzO1xuICAgIHBheWxvYWQ/OiBhbnkgfCBJVUlHcm91cDtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSU1lbnVTdGF0ZSB7XG4gICAgZWxlbWVudHM6IEFycmF5PHsgdGl0bGU6IHN0cmluZywgc2VjdGlvbnM6IElVSUdyb3VwLCBpY29uOiBzdHJpbmcgfT47XG59XG5cbnR5cGUgRGl2aWRlclNpemUgPSAwIHwgNjAgfCAxMDA7XG5cbmV4cG9ydCBjb25zdCBVSVJlZHVjZXIgPSAoc3RhdGU6IElVSVN0YXRlID0gaW5pdGlhbFVJU3RhdGUsIGFjdGlvbjogSVVJQWN0aW9uKTogSVVJU3RhdGUgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiVUlSZWR1Y2VyOiBcIiwgYWN0aW9uKTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJVSS9TRVRfRElWSURFUlwiOlxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVSS9TRVRfRElWSURFUlwiLCBhY3Rpb24ucGF5bG9hZCk7XG4gICAgICAgICAgICBpZiAoYWN0aW9uLnBheWxvYWQgPT09IHN0YXRlLmRpdmlkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSwgZGl2aWRlcjogYWN0aW9uLnBheWxvYWQgfTtcbiAgICAgICAgY2FzZSAnVUkvT1BFTl9TWU5DJzpcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRhaW5lcnM6IElVSUNvbnRhaW5lcltdID0gWy4uLnN0YXRlLmNvbnRhaW5lcnNdO1xuICAgICAgICAgICAgbmV3Q29udGFpbmVyc1sxXS5jb21wb25lbnQgPSAnQ0FST1VTRUwnO1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGRpdmlkZXI6IDYwLCBjb250YWluZXJzOiBuZXdDb250YWluZXJzIH07XG4gICAgICAgIGNhc2UgJ1VJL09QRU4nOlxuICAgICAgICAgICAgY29uc3QgbmV3Q29udGFpbmVyczI6IElVSUNvbnRhaW5lcltdID0gW1xuICAgICAgICAgICAgICAgIHsgY29tcG9uZW50OiBhY3Rpb24ucGF5bG9hZC50b3AgfSwgeyBjb21wb25lbnQ6IGFjdGlvbi5wYXlsb2FkLmJvdHRvbSB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBkaXZpZGVyVmFsOiBEaXZpZGVyU2l6ZSA9IDEwMDtcblxuICAgICAgICAgICAgaWYgKFtcIkdSSURcIiwgXCJDQVJPVVNFTFwiLCBcIkhPTUVcIiwgXCJDQVJEU1wiLCBcIkNBUkRcIiwgXCJQUk9GSUxFXCIsIFwiSEVMUFwiXS5pbmRleE9mKGFjdGlvbi5wYXlsb2FkLmJvdHRvbSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGRpdmlkZXJWYWwgPSA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXZpZGVyVmFsICE9PSBzdGF0ZS5kaXZpZGVyIHx8XG4gICAgICAgICAgICAgICAgc3RhdGUuY29udGFpbmVyc1swXS5jb21wb25lbnQgIT09IG5ld0NvbnRhaW5lcnMyWzBdLmNvbXBvbmVudCB8fFxuICAgICAgICAgICAgICAgIHN0YXRlLmNvbnRhaW5lcnNbMF0uY29tcG9uZW50ICE9PSBuZXdDb250YWluZXJzMlsxXS5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSwgZGl2aWRlcjogZGl2aWRlclZhbCwgY29udGFpbmVyczogbmV3Q29udGFpbmVyczIgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ1VJL09QRU5fQ0FSRCc6XG4gICAgICAgICAgICBjb25zdCBuZXdDb250YWluZXJzMzogSVVJQ29udGFpbmVyW10gPSBbc3RhdGUuY29udGFpbmVyc1swXSwgeyBjb21wb25lbnQ6IFwiQ0FSRFwiIH1dO1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGRpdmlkZXI6IDYwLCBjb250YWluZXJzOiBuZXdDb250YWluZXJzMywgY2FyZDogYWN0aW9uLnBheWxvYWQgfTtcblxuICAgICAgICBjYXNlICdVSS9BRERfVEVTVF9DQVJEUyc6XG5cbiAgICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLCB0ZXN0Q2FyZHM6IFsuLi5zdGF0ZS50ZXN0Q2FyZHMsIGFjdGlvbi5wYXlsb2FkXSB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbFVJU3RhdGU6IElVSVN0YXRlID0ge1xuICAgIGNvbnRhaW5lcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgY29tcG9uZW50OiBcIkVNUFRZXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogXCJDQVJPVVNFTFwiLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgY2FyZDogdW5kZWZpbmVkLFxuICAgIHRlc3RDYXJkczogW1xuICAgICAgICB7IGNhcmRfaWQ6IFwiMjhlN2NiNTItMDFhMi0zZTk1LWE3MWYtNGZjMmQzZTQ2Zjg2XCIsIHZlcnNpb246IFwiMGpPZVVJZUxDYU9jU0k0RlNlYk5qNCtFN1ZaXCIgfSxcbiAgICAgICAgeyBjYXJkX2lkOiBcImJkNGYyNmJhLTBjMmEtM2ExNi1iYjdiLTc5YWEwNjZhYmY0NFwiLyosIHZlcnNpb246IFwiMGpPZVVJZUxDYU9jU0k0RlNlYk5qNCtFN1ZaXCIgKi8gfSxcbiAgICAgICAgeyBjYXJkX2lkOiBcImUwMTQzZDdiLTFlNzYtMTFlNi05N2FjLTA2ODQ5ODVjYmJlM1wiLyosIHZlcnNpb246IFwiMGpPZVVJZUxDYU9jU0k0RlNlYk5qNCtFN1ZaXCIgKi8gfSxcbiAgICAgICAgeyBcImNhcmRfaWRcIjogXCJkZjViOWRkMS0xZTc2LTExZTYtOTdhYy0wNjg0OTg1Y2JiZTNcIiwgXCJ2ZXJzaW9uXCI6IFwiMGpPZVVJZUxDYU9jU0k0RlNlYk5qNCtFN1ZaXCIgfSxcbiAgICAgICAgeyBcImNhcmRfaWRcIjogXCJmMjY2ZWUwYS0xZTc2LTExZTYtOTdhYy0wNjg0OTg1Y2JiZTNcIiwgXCJ2ZXJzaW9uXCI6IFwiMGpPZVVJZUxDYU9jU0k0RlNlYk5qNCtFN1ZaXCIgfSxcbiAgICAgICAgeyBcImNhcmRfaWRcIjogXCJkZTU3YzIzOS0xZTc2LTExZTYtOTdhYy0wNjg0OTg1Y2JiZTNcIiwgXCJ2ZXJzaW9uXCI6IFwiMGpPZVVJZUxDYU9jU0k0RlNlYk5qNCtFN1ZaXCIgfSxcbiAgICAgICAgeyBcImNhcmRfaWRcIjogXCJmMDkxMzM5NS0xZTc2LTExZTYtOTdhYy0wNjg0OTg1Y2JiZTNcIiwgXCJ2ZXJzaW9uXCI6IFwiMGpPZVVJZUxDYU9jU0k0RlNlYk5qNCtFN1ZaXCIgfSxcbiAgICAgICAgLyp7IFwiY2FyZF9pZFwiOiBcImYxYzdjOWQ0LTFlNzYtMTFlNi05N2FjLTA2ODQ5ODVjYmJlM1wiLCBcInZlcnNpb25cIjogXCIwak9lVUllTENhT2NTSTRGU2ViTmo0K0U3VlpcIiB9LFxuICAgICAgICB7IFwiY2FyZF9pZFwiOiBcImYyZjRmN2ZmLTFlNzYtMTFlNi05N2FjLTA2ODQ5ODVjYmJlM1wiLCBcInZlcnNpb25cIjogXCIwak9lVUllTENhT2NTSTRGU2ViTmo0K0U3VlpcIiB9LFxuICAgICAgICB7IFwiY2FyZF9pZFwiOiBcImVmZWRiODJjLTFlNzYtMTFlNi05N2FjLTA2ODQ5ODVjYmJlM1wiLCBcInZlcnNpb25cIjogXCIwak9lVUllTENhT2NTSTRGU2ViTmo0K0U3VlpcIiB9LFxuICAgICAgICB7IFwiY2FyZF9pZFwiOiBcImUxM2ZkYzQxLTFlNzYtMTFlNi05N2FjLTA2ODQ5ODVjYmJlM1wiLCBcInZlcnNpb25cIjogXCIwak9lVUllTENhT2NTSTRGU2ViTmo0K0U3VlpcIiB9LFxuICAgICAgICB7IFwiY2FyZF9pZFwiOiBcIjRmNTk0NjJmLTdjZTktMTFlNS1iN2MyLTA2ODQ5ODVjYmJlM1wiLCBcInZlcnNpb25cIjogXCIwak9lVUllTENhT2NTSTRGU2ViTmo0K0U3VlpcIiB9LFxuICAgICAgICB7IFwiY2FyZF9pZFwiOiBcIjZlNDU1OWI3LTc0MGItMTFlNS1iN2MyLTA2ODQ5ODVjYmJlM1wiLCBcInZlcnNpb25cIjogXCIwak9lVUllTENhT2NTSTRGU2ViTmo0K0U3VlpcIiB9LFxuICAgICAgICB7IFwiY2FyZF9pZFwiOiBcImVlYzk1YWM0LTFlNzYtMTFlNi05N2FjLTA2ODQ5ODVjYmJlM1wiLCBcInZlcnNpb25cIjogXCIwak9lVUllTENhT2NTSTRGU2ViTmo0K0U3VlpcIiB9Ki9cblxuICAgIF0sXG4gICAgZGl2aWRlcjogNjAsXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3JlZHVjZXJzL3VpLnJlZHVjZXIudHMiLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBTb2NrZXRBY3Rpb25UeXBlcyB9IGZyb20gJ0FjdGlvbnMnO1xuaW1wb3J0IHsgQ2FyZCB9IGZyb20gJ1NlcnZpY2VzJztcbmV4cG9ydCB0eXBlIENoYW5uZWxTdGF0dXMgPSBcIm9mZlwiIHwgXCJwbGF5aW5nXCIgfCBcInBhdXNlZFwiIHwgXCJlbmRcIiB8IFwicmVhZHlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJU3luY1N0YXRlIHtcbiAgICB0eXBlPzogXCJTT0NLRVRcIiB8IFwiWU9VVFVCRVwiO1xuICAgIHNvY2tldFN0YXR1czogc3RyaW5nO1xuICAgIC8vY2h1bmtTdGF0dXM6IFNlcnZpY2VTdGF0dXM7XG4gICAgbW92aWVJZD86IHN0cmluZztcbiAgICBjYXJkczogQ2FyZFtdO1xuICAgIGRlbW86IHN0cmluZztcbiAgICBjdXJyZW50VGltZTogbnVtYmVyOyAvLyBUaW1lIGluIHNlY29uZHNcbiAgICB0aW1lTW92aWU6IG51bWJlcjsgLy8gVGltZSBvZiBzb2NrZXQgKG1pbGlzKVxuICAgIHRpbWVNb3ZpZVN5bmNlZDogbnVtYmVyOyAvLyBkYXRlLm5vdyB3aGVuIHNvY2tldChtaWxpcylcbiAgICB0aW1lUmF0aW86IG51bWJlcjtcbiAgICBsYXN0VXBkYXRlZFRpbWU6IG51bWJlcjtcbiAgICBjaGFubmVsU3RhdHVzPzogQ2hhbm5lbFN0YXR1cztcbiAgICBzZWxlY3RlZE9uU2NlbmVDaGFuZ2U6IGJvb2xlYW47XG4gICAgLy8gdGltZU5vdzogbnVtYmVyO1xufVxuZXhwb3J0IGludGVyZmFjZSBJU3luY0FjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG4gICAgdHlwZTogU3luY0FjdGlvblR5cGVzO1xuICAgIHBheWxvYWQ/OiBhbnk7XG59XG5cbmV4cG9ydCB0eXBlIFN5bmNBY3Rpb25UeXBlcyA9IFwiU1lOQy9PUEVOX0NBUkRcIiB8IFwiU1lOQy9TVEFSVFwiIHwgXCJTWU5DL1NFVF9USU1FXCIgfCBcIlNZTkMvVVBEQVRFX1RJTUVcIiB8XG4gICAgXCJTWU5DL1NUQVJUX1NDRU5FXCIgfCBcIlNZTkMvVVBEQVRFX1NDRU5FXCIgfCBcIlNZTkMvRU5EX1NDRU5FXCIgfCBcIlNZTkMvU0VUX01PVklFXCIgfCBcIlNZTkMvQ0hVTktfRkFJTEVEXCIgfCBcIlNZTkMvSU5JVF9USU1FXCIgfFxuICAgIFwiU1lOQy9TRVRfU0VMRUNURURfT05fU0NFTkVfQ0hBTkdFXCIgfFxuICAgIFwiU09DS0VUL0NPTk5FQ1RFRFwiIHwgXCJTWU5DL1NFVF9UUkFJTEVSXCIgfCBcIlNZTkMvU0VUX1NZTkNfVFlQRVwiIHwgXCJTWU5DL1NFVF9DSFVOS19TVEFUVVNcIiB8IFNvY2tldEFjdGlvblR5cGVzO1xuXG5leHBvcnQgY29uc3QgU3luY1JlZHVjZXIgPSAoc3RhdGU6IElTeW5jU3RhdGUgPSBpbml0aWFsU3luY1N0YXRlLCBhY3Rpb246IElTeW5jQWN0aW9uKTogSVN5bmNTdGF0ZSA9PiB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdTWU5DL1NFVF9NT1ZJRSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLCBtb3ZpZUlkOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgICAgICAgICBjYXJkczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdTWU5DL1VQREFURV9USU1FJzogLy8gVVBEQVRFQSBFTCBUSUVNUE8gQ09OIEVMIE5PV1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGltZTogY2FsY1RpbWUoc3RhdGUsIERhdGUubm93KCkpLFxuICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkVGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ1NZTkMvU1RBUlRfU0NFTkUnOlxuICAgICAgICAgICAgaWYgKHN0YXRlLmNhcmRzIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLnBheWxvYWQgaW5zdGFuY2VvZiBBcnJheSAmJlxuICAgICAgICAgICAgICAgIHN0YXRlLmNhcmRzLmxlbmd0aCAhPT0gYWN0aW9uLnBheWxvYWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGNhcmRzOiBhY3Rpb24ucGF5bG9hZCB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1NZTkMvVVBEQVRFX1NDRU5FJzpcbiAgICAgICAgICAgIGlmIChhY3Rpb24ucGF5bG9hZCBpbnN0YW5jZW9mIEFycmF5ICYmIGFjdGlvbi5wYXlsb2FkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBjYXJkczogWy4uLnN0YXRlLmNhcmRzLCAuLi5hY3Rpb24ucGF5bG9hZF0gfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICdTWU5DL0VORF9TQ0VORSc6XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSwgY2FyZHM6IFtdIH07XG5cbiAgICAgICAgY2FzZSAnU1lOQy9TRVRfVFJBSUxFUic6XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSwgZGVtbzogYWN0aW9uLnBheWxvYWQgfTtcbiAgICAgICAgY2FzZSAnU1lOQy9TRVRfU1lOQ19UWVBFJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsIHR5cGU6IGFjdGlvbi5wYXlsb2FkLCBzb2NrZXRTdGF0dXM6ICdJTklUJyxcbiAgICAgICAgICAgICAgICB0aW1lTW92aWVTeW5jZWQ6IGluaXRpYWxTeW5jU3RhdGUudGltZU1vdmllU3luY2VkLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lOiBpbml0aWFsU3luY1N0YXRlLmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkVGltZTogaW5pdGlhbFN5bmNTdGF0ZS5sYXN0VXBkYXRlZFRpbWUsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGNhc2UgJ1NZTkMvU0VUX1NFTEVDVEVEX09OX1NDRU5FX0NIQU5HRSc6XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSwgc2VsZWN0ZWRPblNjZW5lQ2hhbmdlOiBhY3Rpb24ucGF5bG9hZCB9O1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufTtcblxuY29uc3QgY2FsY1RpbWUgPSAoc3RhdGU6IElTeW5jU3RhdGUsIHRpbWU6IG51bWJlcikgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiW2NhbGNUaW1lXSBzdGF0ZTogXCIsIHN0YXRlKTtcbiAgICAvLyBjb25zb2xlLmxvZyhcIltjYWxjVGltZV0gdGltZTogXCIsIHRpbWUpO1xuICAgIHJldHVybiAoc3RhdGUudGltZU1vdmllICsgKHRpbWUgLSBzdGF0ZS50aW1lTW92aWVTeW5jZWQpICogc3RhdGUudGltZVJhdGlvKSAvIDEwMDA7XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbFN5bmNTdGF0ZTogSVN5bmNTdGF0ZSA9IHtcbiAgICBzZWxlY3RlZE9uU2NlbmVDaGFuZ2U6IHRydWUsXG4gICAgc29ja2V0U3RhdHVzOiAnSU5JVCcsXG4gICAgbW92aWVJZDogXCJtMDAwMDFcIixcbiAgICBjYXJkczogW10sXG4gICAgZGVtbzogXCJcIixcbiAgICBjdXJyZW50VGltZTogMCxcbiAgICB0aW1lTW92aWU6IDAsXG4gICAgdGltZU1vdmllU3luY2VkOiAwLFxuICAgIHRpbWVSYXRpbzogMSxcbiAgICBsYXN0VXBkYXRlZFRpbWU6IDAsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVkdWNlcnMvc3luYy5yZWR1Y2VyLnRzeCIsImltcG9ydCB7IEFjdGlvbiB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IENhcmRVc2VyIH0gZnJvbSAnU2VydmljZXMnO1xuXG4vL1xuLy8gIEFjdGlvbiB0eXBlc1xuLy9cbmV4cG9ydCB0eXBlIFVzZXJBY3Rpb25UeXBlcyA9IFwiVVNFUi9TRVRfVVNFUlwiIHwgXCJVU0VSL0xJS0VfQ0FSRFwiO1xuZXhwb3J0IGludGVyZmFjZSBJVXNlckFjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG4gICAgdHlwZTogdW5kZWZpbmVkIHwgVXNlckFjdGlvblR5cGVzO1xuICAgIHBheWxvYWQ/OiBhbnk7XG59XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1lbXB0eS1pbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSVVzZXJTdGF0ZSB7XG59XG5cbmV4cG9ydCBjb25zdCBVc2VyUmVkdWNlciA9XG4oc3RhdGU6IElVc2VyU3RhdGUgfCB7fSA9IGluaXRpYWxVc2VyU3RhdGUsIGFjdGlvbjogSVVzZXJBY3Rpb24pOiBJVXNlclN0YXRlIHwge30gPT4ge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIlVTRVIvU0VUX1VTRVJcIjpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24ucGF5bG9hZCBhcyBJVXNlclN0YXRlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsVXNlclN0YXRlID0ge307XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZWR1Y2Vycy91c2VyLnJlZHVjZXIudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcblxuaW1wb3J0IHsgQ2FyZERldGFpbCB9IGZyb20gJ0NvbXBvbmVudHMnO1xuaW1wb3J0IHsgQ2Fyb3VzZWwsIENhcmREZXRhaWxDb250YWluZXIgfSBmcm9tICdDb250YWluZXJzJztcbmltcG9ydCB7IElTdGF0ZSwgSVVJU3RhdGUsIFVJTGF5ZXJCb3R0b21UeXBlcywgVUlMYXllclRvcFR5cGVzLyosIElFcnJvclN0YXRlKi8gfSBmcm9tICdSZWR1Y2Vycyc7XG5pbXBvcnQgeyBVSUFjdGlvbnMsIElVSUFjdGlvbnMgfSBmcm9tICdBY3Rpb25zJztcbmltcG9ydCB7IG5hdmlnYWJsZSB9IGZyb20gJ0hPQyc7XG5pbXBvcnQgeyBDYXJkIH0gZnJvbSBcIlNlcnZpY2VzXCI7XG5cbnR5cGUgTGF5b3V0UHJvcHMgPSB7IHVpOiBJVUlTdGF0ZS8qLCBlcnJvcjogSUVycm9yU3RhdGUqLywgdGVzdENhcmRzOiBDYXJkW10gfSAmIElVSUFjdGlvbnM7XG5leHBvcnQgY2xhc3MgTGF5b3V0Q2xhc3MgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PExheW91dFByb3BzLCB7fT4ge1xuICAgIHByaXZhdGUgbGFzdFRpbWVNZW51Q2xpY2tlZDogbnVtYmVyO1xuXG4gICAgcHVibGljIHJlbmRlcigpOiBhbnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltMYXlvdXRDbGFzc10gUmVuZGVyIFwiLCB0aGlzLnByb3BzLnVpKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMgJiYgdGhpcy5wcm9wcy51aSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbTGF5b3V0Q2xhc3NdIFJlbmRlciBPS1wiKTtcbiAgICAgICAgICAgIC8vIFRvcCBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICBjb25zdCB0b3BUeXBlOiBVSUxheWVyVG9wVHlwZXMgPSB0aGlzLnByb3BzLnVpLmNvbnRhaW5lcnNbMF0uY29tcG9uZW50IGFzIFVJTGF5ZXJUb3BUeXBlcztcbiAgICAgICAgICAgIGNvbnN0IHRvcFN0eWxlOiBSZWFjdC5DU1NQcm9wZXJ0aWVzID0geyBoZWlnaHQ6IGAke3RoaXMucHJvcHMudWkuZGl2aWRlcn0lYCB9O1xuXG4gICAgICAgICAgICAvLyBCb3R0b20gY29uZmlndXJhdGlvblxuICAgICAgICAgICAgY29uc3QgYm90dG9tVHlwZTogVUlMYXllckJvdHRvbVR5cGVzID0gdGhpcy5wcm9wcy51aS5jb250YWluZXJzWzFdLmNvbXBvbmVudCBhcyBVSUxheWVyQm90dG9tVHlwZXM7XG4gICAgICAgICAgICBjb25zdCBib3R0b21TdHlsZTogUmVhY3QuQ1NTUHJvcGVydGllcyA9IHsgaGVpZ2h0OiBgJHsxMDAgLSB0aGlzLnByb3BzLnVpLmRpdmlkZXJ9JWAgfTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXJMYXlvdXRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsYXlvdXRUb3BcIiBzdHlsZT17dG9wU3R5bGV9PlxuICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuZ2V0VG9wKHRvcFR5cGUpfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxheW91dEJvdHRvbVwiIHN0eWxlPXtib3R0b21TdHlsZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5nZXRCb3R0b20oYm90dG9tVHlwZSl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldFRvcChjb21wb25lbnRUeXBlOiBVSUxheWVyVG9wVHlwZXMpOiBKU1guRWxlbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Qm90dG9tKGNvbXBvbmVudFR5cGU6IFVJTGF5ZXJCb3R0b21UeXBlcykge1xuICAgICAgICBzd2l0Y2ggKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0NBUk9VU0VMJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gPENhcm91c2VsIGtleT17YGNhcm91c2VsIyR7dGhpcy5sYXN0VGltZU1lbnVDbGlja2VkfWB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudD17dGhpc31cbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17MX1cbiAgICAgICAgICAgICAgICAgICAgbmFtZT1cIkNBUk9VU0VMXCIgZ3JvdXBOYW1lPVwiQ0FST1VTRUxcIiBpc0RlZmF1bHQ9e3RydWV9IC8+O1xuICAgICAgICAgICAgY2FzZSAnQ0FSRCc6XG4gICAgICAgICAgICAgICAgLypyZXR1cm4gPENhcmREZXRhaWwga2V5PXtcImNhcmREZXRhaWxcIn1cbiAgICAgICAgICAgICAgICAgICAgY2FyZD17dGhpcy5wcm9wcy51aS5jYXJkfVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ9e3RoaXN9XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnM9ezF9XG4gICAgICAgICAgICAgICAgICAgIGlzRGVmYXVsdD17dHJ1ZX1cbiAgICAgICAgICAgICAgICAvPjsqL1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgY2FyZHM6IENhcmRbXSB8IHtjYXJkX2lkOiBzdHJpbmcsIHZlcnNpb24/OnN0cmluZ31bXSAgPSBbLi4udGhpcy5wcm9wcy51aS50ZXN0Q2FyZHMsIC4uLnRoaXMucHJvcHMuc2NlbmVDYXJkc107XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2NhcmRzJywgY2FyZHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnVpLnRlc3RDYXJkcy5tYXAoKGNhcmQ6IENhcmR8IHtjYXJkX2lkOiBzdHJpbmcsIHZlcnNpb24/OnN0cmluZ30sIGlkeDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA8Q2FyZERldGFpbENvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZElkPXtjYXJkLmNhcmRfaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uPXtjYXJkLnZlcnNpb259XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2BjYXJkRGV0YWlsXyR7aWR4fWB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZDbGFzcz1cImNhcmREZXRhaWxOYXZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50PXt0aGlzfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17MX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVmYXVsdD17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgLz47XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltMYXlvdXRdIGNvbXBvbmVudFdpbGxNb3VudDpcIiwgdGhpcy5wcm9wcyk7XG4gICAgICAgIHRoaXMucHJvcHMuc2V0RGl2aWRlcih0aGlzLnByb3BzLnVpLmRpdmlkZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wczogUmVhZG9ubHk8TGF5b3V0UHJvcHM+LCBuZXh0U3RhdGU6IFJlYWRvbmx5PExheW91dFByb3BzPikge1xuICAgICAgICB0aGlzLmxhc3RUaW1lTWVudUNsaWNrZWQgPSBEYXRlLm5vdygpO1xuICAgIH1cbn1cblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlOiBJU3RhdGUpOiB7IHVpOiBJVUlTdGF0ZS8qLCBlcnJvcjogSUVycm9yU3RhdGUqLyB9ID0+IHtcbiAgICByZXR1cm4geyB1aTogc3RhdGUudWksIH07XG59O1xuXG5leHBvcnQgY29uc3QgTGF5b3V0ID0gbmF2aWdhYmxlKGNvbm5lY3QoXG4gICAgbWFwU3RhdGVUb1Byb3BzLFxuICAgIFVJQWN0aW9ucyxcbikoTGF5b3V0Q2xhc3MpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbnRhaW5lcnMvbGF5b3V0L2xheW91dC5jb250YWluZXIudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCAqIGFzIGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBjb25uZWN0LCBDb21wb25lbnREZWNvcmF0b3IgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5cbmltcG9ydCB7IElOYXZTdGF0ZSwgSVN0YXRlIH0gZnJvbSAnUmVkdWNlcnMnO1xuaW1wb3J0IHsgTmF2QWN0aW9ucywgSU5hdkFjdGlvbnMgfSBmcm9tICdBY3Rpb25zJztcblxuKHdpbmRvdyBhcyBhbnkpLmN1cnJlbnROYXZJZCA9IDA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU5hdmlnYWJsZVByb3BzIHtcbiAgICBwYXJlbnQ6IFJlYWN0LkNvbXBvbmVudDxhbnkgJiBJTmF2aWdhYmxlUHJvcHMsIGFueT4sXG4gICAgaWR4PzogbnVtYmVyLCAvLyBJZGVudGlmaWNhZG9yIMO6bmljbyBkZWwgbmF2aWdhYmxlXG4gICAgY29sdW1ucz86IG51bWJlciwgLy8gTnVtZXJvIGRlIGNvbHVtbmFzIHF1ZSBoYXkgZW4gZWwgZW50b3JubyBkZWwgZWxlbWVudG8gYWN0dWFsXG4gICAgdGFiSW5kZXg/OiBudW1iZXIsIC8vIE9yZGVuIGRlIHRhYnVsYWNpw7NuXG4gICAgY2xpY2tBY3Rpb24/OiBhbnksXG4gICAgbmFtZT86IHN0cmluZywgLy8gTm9tYnJlIGlkZW50aWZpY2F0aXZvXG4gICAgaXNEZWZhdWx0PzogYm9vbGVhbiwgLy9QYXJhIHF1ZSBzZSBzZWxlY2Npb25lIGVzZSBlbGVtZW50byBwb3IgZGVmZXRvIHNpIG5vIGhheSBuaW5nw7puIG90cm8gIGVuIGVzZSBsaXN0YWRvLlxuICAgIGdyb3VwTmFtZT86IHN0cmluZywgLy8gTm9tYnJlIGRlIGdydXBvIHBlcnRlbmVjaWVudGVcbiAgICBvbkZvY3VzQ2FsbGJhY2s/OiAoKSA9PiB2b2lkO1xuICAgIG9uRm9jdXNDYWxsYmFja1JlcGVhdD86IGJvb2xlYW47XG4gICAgZm9yY2VGaXJzdD86IGJvb2xlYW47XG4gICAgZm9yY2VPcmRlcj86IG51bWJlcjtcbiAgICBtb2RhbD86IGJvb2xlYW47IC8vIFBhcmEgYmxvcXVlYXIgbGEgc2VsZWNjacOzbiBkZW50cm8gZGUgZXN0ZSBuYXZpZ2FibGVcbiAgICBvbkJlZm9yZVVubW91bnQ/OiAobmF2OiBJTmF2aWdhYmxlKSA9PiB2b2lkO1xuICAgIGZvY3VzQ2hhaW5DbGFzcz86IHN0cmluZztcbiAgICBhY3RpdmVHcm91cENsYXNzPzogc3RyaW5nO1xuICAgIGlzU2Nyb2xsYWJsZT86IGJvb2xlYW47IC8vIEVsZW1lbnRvIHNvYnJlIGVsIHF1ZSBzZSBoYWNlIHVuIHNjcm9sbC5cbiAgICBuYXZDbGFzcz86IHN0cmluZztcbiAgICBzY3JvbGxQYWRkaW5nPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElOYXZpZ2FibGUge1xuICAgIHBhcmVudElkOiBudW1iZXI7XG4gICAgaWQ6IG51bWJlcjtcbiAgICBjaGlsZHJlbjogbnVtYmVyW11bXTtcbiAgICBjb2x1bW5zPzogbnVtYmVyO1xuICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgZ3JvdXBOYW1lPzogc3RyaW5nO1xuICAgIGZvcmNlRmlyc3Q/OiBib29sZWFuO1xuICAgIGZvcmNlT3JkZXI/OiBudW1iZXI7XG4gICAgbW9kYWw/OiBib29sZWFuO1xuICAgIGlzU2Nyb2xsYWJsZT86IGJvb2xlYW47XG59XG5cbnR5cGUgSW5qZWN0ZWRQcm9wcyA9IElOYXZpZ2FibGVQcm9wcyAmIElOYXZBY3Rpb25zICYgSU5hdlN0YXRlO1xuXG5jb25zdCBOYXZpZ2FibGVDbGFzcyA9IDxUT3JpZ2luYWxQcm9wcyBleHRlbmRzIHt9PihcbiAgICBJbm5lckNvbXBvbmVudDogKFJlYWN0LkNvbXBvbmVudENsYXNzPFRPcmlnaW5hbFByb3BzPiB8XG4gICAgICAgIFJlYWN0LlN0YXRlbGVzc0NvbXBvbmVudDxUT3JpZ2luYWxQcm9wcz4gfFxuICAgICAgICBDb21wb25lbnREZWNvcmF0b3I8VE9yaWdpbmFsUHJvcHMsIGFueT5cbiAgICApLFxuKSA9PiB7XG4gICAgdHlwZSBSZXN1bHRQcm9wcyA9IFRPcmlnaW5hbFByb3BzICYgSW5qZWN0ZWRQcm9wcztcbiAgICBjbGFzcyBOYXZpZ2FibGUgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFJlc3VsdFByb3BzLCB7fT4ge1xuICAgICAgICAvLyBjb25zdCBzdGF0ZTpJVUlTdGF0ZSA9IHRoaXMuc3RvcmVcbiAgICAgICAgcHVibGljIGxhc3ROYXZMZXZlbDogSU5hdmlnYWJsZTtcbiAgICAgICAgcHVibGljIHdyYXBwZXI6IGFueTtcbiAgICAgICAgcHVibGljIG5hdklkOiBudW1iZXIgPSAwO1xuICAgICAgICBwdWJsaWMgcmVmQ29tcG9uZW50OiBhbnk7XG4gICAgICAgIHByaXZhdGUgZm9jdXNUcmFja2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3RydWN0b3IocHJvcHM6IGFueSkge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5uYXZJZCA9IHRoaXMuZ2V0TmV3SWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1YmxpYyBnZXROZXdJZCA9ICgpOiBudW1iZXIgPT4gKysod2luZG93IGFzIGFueSkuY3VycmVudE5hdklkO1xuXG4gICAgICAgIHB1YmxpYyBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJZCgpID09PSB0aGlzLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvU2VsZlNjcm9sbCh0cnVlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwKTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwdWJsaWMgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wczogYW55KSB7XG4gICAgICAgIC8vICAgICBjb25zdCB0aGlzSWQgPSB0aGlzLmdldElkKCk7XG4gICAgICAgIC8vICAgICBjb25zdCBuYXYgPSB0aGlzLnByb3BzLm5hdmlnYXRpb24uZ2V0KHRoaXNJZCk7XG4gICAgICAgIC8vICAgICBpZiAoIXRoaXMud3JhcHBlcikge1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgaWYgKG5hdi5jaGlsZHJlblswXS5sZW5ndGggPT09IDAgJiYgdGhpcy5wcm9wcy5zZWxlY3RlZCAhPT0gdGhpc0lkICYmIG5leHRQcm9wcy5zZWxlY3RlZCAhPT0gdGhpc0lkKSB7XG4gICAgICAgIC8vICAgICAgICAgY29uc29sZS5sb2coXCJVcGRhdGVkISBsZWFmIGFuZCBub3QgcHJldiBzZWxlY3RlZFwiLCB0aGlzSWQpO1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBjb25zdCB0aGlzSWQgPSB0aGlzLmdldElkKCk7XG4gICAgICAgIC8vIGlmICghdGhpcy53cmFwcGVyKSB7XG4gICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gfSBlbHNlIGlmIChuZXh0UHJvcHMuc2VsZWN0ZWQgPT09IHRoaXNJZCkge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJVcGRhdGVkISBjdXJyU2VsZWN0aW9uXCIsIHRoaXNJZCk7XG4gICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChuZXh0UHJvcHMuYWN0aXZhdGVkID09PSB0aGlzSWQgfHwgdGhpcy5wcm9wcy5hY3RpdmF0ZWQgPT09IHRoaXNJZCkge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJVcGRhdGVkISBpcyBhY3RpdmF0ZWRcIiwgdGhpc0lkKTtcbiAgICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGNvbnN0IG5hdiA9IHRoaXMucHJvcHMubmF2aWdhdGlvbi5nZXQodGhpc0lkKTtcbiAgICAgICAgLy8gaWYgKG5hdi5jaGlsZHJlblswXS5sZW5ndGggPT09IDAgJiYgdGhpcy5wcm9wcy5zZWxlY3RlZCAhPT0gdGhpc0lkKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcIlVwZGF0ZWQhIGxlYWYgYW5kIG5vdCBwcmV2IHNlbGVjdGVkXCIsIHRoaXNJZCk7XG4gICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmICh0aGlzLmluRm9jdXNDaGFpbih0aGlzLnByb3BzLnNlbGVjdGVkTmF2KSB8fCB0aGlzLmluRm9jdXNDaGFpbihuZXh0UHJvcHMuc2VsZWN0ZWROYXYpKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcIlVwZGF0ZWQhIGlzIGluIGZvY3VzIGNoYWluXCIsIHRoaXNJZCk7XG4gICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBNQVlCRSwgT04gRlVUVVJFIFNIT1VMRCBCRSBBTFdBWVMgVFJVRVxuICAgICAgICAvLyByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIElOSVQgREFUQSBPTiBNT1VOVCBDT01QT05FTlRcbiAgICAgICAgcHVibGljIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0lkID0gdGhpcy5nZXRJZCgpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Q29tcG9uZW50OiBOYXZpZ2FibGUgPSB0aGlzLnByb3BzLnBhcmVudCBhcyBOYXZpZ2FibGU7XG4gICAgICAgICAgICBsZXQgcGFyZW50SWQ6IG51bWJlciA9IC0xO1xuICAgICAgICAgICAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQucHJvcHMgJiYgcGFyZW50Q29tcG9uZW50LnByb3BzLmlkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50SWQgPSBwYXJlbnRDb21wb25lbnQucHJvcHMuaWR4IGFzIG51bWJlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgb2JqOiBJTmF2aWdhYmxlID0ge1xuICAgICAgICAgICAgICAgIHBhcmVudElkLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbW11dLFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzSWQsXG4gICAgICAgICAgICAgICAgY29sdW1uczogdGhpcy5wcm9wcy5jb2x1bW5zLFxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHROYW1lOiB0aGlzLnByb3BzLmRlZmF1bHROYW1lLFxuICAgICAgICAgICAgICAgIGdyb3VwTmFtZTogdGhpcy5wcm9wcy5ncm91cE5hbWUsXG4gICAgICAgICAgICAgICAgZm9yY2VGaXJzdDogdGhpcy5wcm9wcy5mb3JjZUZpcnN0LFxuICAgICAgICAgICAgICAgIGZvcmNlT3JkZXI6IHRoaXMucHJvcHMuZm9yY2VPcmRlcixcbiAgICAgICAgICAgICAgICBtb2RhbDogdGhpcy5wcm9wcy5tb2RhbCxcbiAgICAgICAgICAgICAgICBpc1Njcm9sbGFibGU6IHRoaXMucHJvcHMuaXNTY3JvbGxhYmxlLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQWRkIG5vZGUgdG8gc3RhdGVcbiAgICAgICAgICAgIHRoaXMucHJvcHMuYWRkTm9kZShvYmopO1xuXG4gICAgICAgICAgICAvLyBTZXQgZm9jdXNcbiAgICAgICAgICAgIGlmICh0aGlzSWQgPT09IHRoaXMucHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXIuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2VsZWN0IGRlZmF1bHQgZWxlbWVudCBieSBkZWZhdWx0TmFtZSBwcm9wLCBhZGRlZCBpbiBjb21wb25lbnRcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmlzRGVmYXVsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc2V0Tm9kZUJ5SWQodGhpc0lkKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnNlbGVjdGVkTmF2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBDQVNPIERFIFFVRSBFTCBQQURSRSBFU1TDiSBTRUxFQ0NJT05BRE8gQUwgTU9OVEFSIEVTVEU6XG4gICAgICAgICAgICAgICAgY29uc3QgbmF2U2VsZWN0ZWQ6IElOYXZpZ2FibGUgPSB0aGlzLnByb3BzLnNlbGVjdGVkTmF2IGFzIElOYXZpZ2FibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgbmF2OiBJTmF2aWdhYmxlID0gdGhpcy5wcm9wcy5uYXZpZ2F0aW9uLmdldCh0aGlzSWQpIGFzIElOYXZpZ2FibGU7XG4gICAgICAgICAgICAgICAgaWYgKG5hdlNlbGVjdGVkLmlkID09PSBuYXYucGFyZW50SWQgJiYgbmF2U2VsZWN0ZWQuY2hpbGRyZW5bMF1bMF0gPT09IHRoaXNJZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnNldE5vZGVCeUlkKHRoaXNJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVibGljIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0lkID0gdGhpcy5nZXRJZCgpO1xuICAgICAgICAgICAgLy8gQU5URVMgREUgQm9ycmFyIGVsIG5vZG8sIHNpIHRpZW5lIGVsIGZvY28sIGhheSBxdWUgcGFzw6Fyc2VsbyBhICBvdHJvIGNvbiBlc3RhIHByZWZlcmVuY2lhOlxuICAgICAgICAgICAgLy8gYWwgc2lndWllbnRlLCBzaW5vLCBhbCBhbnRlcmlvciwgc2lubyBhbCBwYWRyZVxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25CZWZvcmVVbm1vdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQmVmb3JlVW5tb3VudCh0aGlzLnByb3BzLnNlbGVjdGVkTmF2IGFzIElOYXZpZ2FibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuc2VsZWN0ZWROYXYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIENBU08gREUgUVVFIEVMIFBBRFJFIEVTVMOJIFNFTEVDQ0lPTkFETyBBTCBNT05UQVIgRVNURTpcbiAgICAgICAgICAgICAgICBjb25zdCBuYXZTZWxlY3RlZDogSU5hdmlnYWJsZSA9IHRoaXMucHJvcHMuc2VsZWN0ZWROYXYgYXMgSU5hdmlnYWJsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYXY6IElOYXZpZ2FibGUgPSB0aGlzLnByb3BzLm5hdmlnYXRpb24uZ2V0KHRoaXNJZCkgYXMgSU5hdmlnYWJsZTtcbiAgICAgICAgICAgICAgICBpZiAobmF2U2VsZWN0ZWQuaWQgPT09IHRoaXNJZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnNldE5vZGVCeUlkKG5hdi5wYXJlbnRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9wcy5kZWxldGVOb2RlKHRoaXNJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBwdWJsaWMgcmVuZGVyKCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0lkID0gdGhpcy5nZXRJZCgpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmOiBib29sZWFuID0gdGhpcy5wcm9wcy5zZWxlY3RlZE5hdiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5ncm91cE5hbWUgIT09IHRoaXMucHJvcHMuc2VsZWN0ZWROYXYuZ3JvdXBOYW1lO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlOiBib29sZWFuID0gdGhpc0lkID09PSB0aGlzLnByb3BzLmFjdGl2YXRlZDtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXM6IGFueSA9IHtcbiAgICAgICAgICAgICAgICBuYXZpZ2FibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgbmF2QWN0aXZlOiBhY3RpdmUsXG4gICAgICAgICAgICAgICAgLy8gc2Nyb2xsYWJsZTogdGhpcy5wcm9wcy5pc1Njcm9sbGFibGUsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5uYXZDbGFzcykge1xuICAgICAgICAgICAgICAgIGNsYXNzZXNbdGhpcy5wcm9wcy5uYXZDbGFzc10gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKHRoaXMucHJvcHMuZm9jdXNDaGFpbkNsYXNzICYmIHRoaXMucHJvcHMuZm9jdXNDaGFpbkNsYXNzLmxlbmd0aCkgJiYgdGhpcy5wcm9wcy5zZWxlY3RlZE5hdikge1xuICAgICAgICAgICAgICAgIGNsYXNzZXNbdGhpcy5wcm9wcy5mb2N1c0NoYWluQ2xhc3NdID0gdGhpcy5pbkZvY3VzQ2hhaW4odGhpcy5wcm9wcy5zZWxlY3RlZE5hdik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgodGhpcy5wcm9wcy5hY3RpdmVHcm91cENsYXNzICYmIHRoaXMucHJvcHMuYWN0aXZlR3JvdXBDbGFzcy5sZW5ndGggJiYgIW9mZikpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzW3RoaXMucHJvcHMuYWN0aXZlR3JvdXBDbGFzc10gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzQXBwbGllZCA9IGNsYXNzTmFtZXMoY2xhc3Nlcyk7XG5cbiAgICAgICAgICAgIC8vIGNvbnN0IHsga2V5LCBvbkZvY3VzQ2FsbGJhY2ssIG9uRm9jdXNDYWxsYmFja1JlcGVhdCwgcGFyZW50LCAuLi5jaGlsZFByb3BzIH0gPSB0aGlzLnByb3BzIGFzIGFueTtcbiAgICAgICAgICAgIC8vIE5BViBQUk9QU1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGlkeCwgY29sdW1ucywgdGFiSW5kZXgsIGNsaWNrQWN0aW9uLCBpc0RlZmF1bHQsIC8qZ3JvdXBOYW1lLCovIG9uRm9jdXNDYWxsYmFjayxcbiAgICAgICAgICAgICAgICBvbkZvY3VzQ2FsbGJhY2tSZXBlYXQsIGZvcmNlRmlyc3QsIGZvcmNlT3JkZXIsIG1vZGFsLCBvbkJlZm9yZVVubW91bnQsXG4gICAgICAgICAgICAgICAgZm9jdXNDaGFpbkNsYXNzLCBuYXZDbGFzcywgLi4ubm9OYXZPd25Qcm9wcyxcbiAgICAgICAgICAgIH0gPSB0aGlzLnByb3BzIGFzIGFueTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uLCBsYXN0S2V5LCBzZWxlY3RlZCwgc2VsZWN0ZWROYXYsIGxhc3RTZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZWQsIGxhc3RBY3RpdmF0ZWQsIG5hdk5hbWVzLCAuLi5jaGlsZFByb3BzLFxuICAgICAgICAgICAgfSA9IG5vTmF2T3duUHJvcHM7XG5cbiAgICAgICAgICAgIGNvbnN0IENoaWxkQ29tcG9uZW50OiBhbnkgPSBJbm5lckNvbXBvbmVudDtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8ZGl2IHJlZj17KGVsKSA9PiB7IGlmIChlbCkgeyB0aGlzLndyYXBwZXIgPSBlbDsgfSB9fSBjbGFzc05hbWU9e2NsYXNzZXNBcHBsaWVkfSB0YWJJbmRleD17LTF9XG4gICAgICAgICAgICAgICAgICAgIGtleT17dGhpcy5wcm9wcy5rZXkgPyB0aGlzLnByb3BzLmtleSArICdfTmF2JyA6IFwiXCJ9XG4gICAgICAgICAgICAgICAgICAgIG9uS2V5VXA9e3RoaXMub25LZXlQcmVzc31cbiAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duPXt0aGlzLm9uS2V5UHJlc3NEb3dufVxuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMub25Nb3VzZUVudGVyfVxuICAgICAgICAgICAgICAgICAgICAvLyBvbkNsaWNrPXt0aGlzLm9uQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXt0aGlzLm9uQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgIG9uRm9jdXM9eyhlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Gb2N1cyhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgaWQ9e3RoaXNJZC50b1N0cmluZygpfVxuICAgICAgICAgICAgICAgIC8qYXV0b0ZvY3VzPXtmb2N1c30qLz5cbiAgICAgICAgICAgICAgICAgICAgPENoaWxkQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuYXZDb21wb25lbnQgPSB7dGhpcy53cmFwcGVyfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmQ29tcG9uZW50OiB0eXBlb2YgSW5uZXJDb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZkNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZDb21wb25lbnQgPSByZWZDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB7Li4uY2hpbGRQcm9wcyBhcyBhbnkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWR4PXt0aGlzSWR9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1YmxpYyBvbk1vdXNlRW50ZXIgPSAoKTogYW55ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNJZCA9IHRoaXMuZ2V0SWQoKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdjogSU5hdmlnYWJsZSB8IHVuZGVmaW5lZCA9IHRoaXMucHJvcHMubmF2aWdhdGlvbi5nZXQodGhpc0lkKTtcbiAgICAgICAgICAgIGlmIChuYXYgIT09IHVuZGVmaW5lZCAmJiBuYXYuY2hpbGRyZW5bMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zZXRTZWxlY3RlZCh0aGlzSWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHJvYmFtb3Mgc2kgc2UgaGEgY29tcGxldGFkbyBsYSBzZWxlY2Npw7NuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNJZCA9PT0gdGhpcy5wcm9wcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwdWJsaWMgb25DbGljayA9IChlOiBhbnkpOiBhbnkgPT4ge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbnMgIT09IDEgJiYgIWUua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hdjogSU5hdmlnYWJsZSB8IHVuZGVmaW5lZCA9IHRoaXMucHJvcHMubmF2aWdhdGlvbi5nZXQodGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgIGxldCBldmVudENvbnN1bWVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmF2ICE9PSB1bmRlZmluZWQgJiYgbmF2LmNoaWxkcmVuWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc2V0QWN0aXZhdGVkKG5hdi5pZCk7XG4gICAgICAgICAgICAgICAgZXZlbnRDb25zdW1lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5jbGlja0FjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuY2xpY2tBY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBldmVudENvbnN1bWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudENvbnN1bWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVibGljIG9uRm9jdXMgPSAoZTogYW55KTogYW55ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5nZXRJZCgpO1xuICAgICAgICAgICAgY29uc3QgbmF2OiBJTmF2aWdhYmxlIHwgdW5kZWZpbmVkID0gdGhpcy5wcm9wcy5uYXZpZ2F0aW9uLmdldChpZCk7XG4gICAgICAgICAgICAvLyBzY3JvbGwgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5zZWxlY3RlZE5hdiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuc2VsZWN0ZWROYXYuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9TZWxmU2Nyb2xsKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGwgY2FsbGJhY2sgaWYgc2V0XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkZvY3VzQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiAoIXRoaXMuZm9jdXNUcmFja2VkIHx8IHRoaXMucHJvcHMub25Gb2N1c0NhbGxiYWNrUmVwZWF0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAodGhpcy5wcm9wcy5vbkZvY3VzQ2FsbGJhY2sgYXMgKCkgPT4gdm9pZCkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmICdsZWFmJyBub2RlXG4gICAgICAgICAgICBpZiAobmF2ICE9PSB1bmRlZmluZWQgJiYgbmF2LmNoaWxkcmVuWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgLy8gZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSAwO1xuXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy8gcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVibGljIGdldElkID0gKCk6IG51bWJlciA9PiB0aGlzLm5hdklkO1xuXG4gICAgICAgIHB1YmxpYyBvbktleVByZXNzID0gKGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVibGljIG9uS2V5UHJlc3NEb3duID0gKGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICAoUmVhY3RET00uZmluZERPTU5vZGUodGhpcy5yZWZDb21wb25lbnQpIGFzIGFueSkuY2xpY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5tb3ZlVmVydGljYWwoLTEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5tb3ZlSG9yaXpvbnRhbCgxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5tb3ZlSG9yaXpvbnRhbCgtMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMubW92ZVZlcnRpY2FsKDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHJvYmFtb3Mgc2kgZWwgZWxlbWVudG8gZXMgc2Nyb2xsYWJsZSBvIHNpIGFsZ3VubyBkZSBzdXMgcGFkcmVzIGxvIGVzLlxuICAgICAgICBwcml2YXRlIGlzU2Nyb2xsYWJsZSA9ICgpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIGxldCBuYXY6IElOYXZpZ2FibGUgfCB1bmRlZmluZWQgPSB0aGlzLnByb3BzLnNlbGVjdGVkTmF2O1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hdiAhPT0gdW5kZWZpbmVkICYmIG5hdi5wYXJlbnRJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYXYgJiYgbmF2LmlzU2Nyb2xsYWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2ID0gdGhpcy5wcm9wcy5uYXZpZ2F0aW9uLmdldChuYXYucGFyZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAobmF2ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaXZhdGUgaXNTZWxlY3RlZCA9ICgpOiBib29sZWFuID0+IHRoaXMucHJvcHMuc2VsZWN0ZWQgPT09IHRoaXMuZ2V0SWQoKTtcblxuICAgICAgICAvL0NvZ2Vtb3MgZWwgZWxlbWVudG8gcGFkcmUgc2Nyb2xsYWJsZSBtw6FzIGNlcmNhbm8uXG4gICAgICAgIHByaXZhdGUgZ2V0U2Nyb2xsYWJsZUVsZW1lbnQgPSAoKTogRWxlbWVudCB8IG51bGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudDogSFRNTEVsZW1lbnQgfCBudWxsID0gdGhpcy53cmFwcGVyO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gbnVsbCAmJiBlbGVtZW50LmNsb3Nlc3QgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNsb3Nlc3QoJy5zY3JvbGxhYmxlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9DYWxjdWxhbW9zIGVsIG51ZXZvIHNjcm9sbCBwYXJhIGN1YW5kbyBlbCBlbGVtZW50byBzY3JvbGxhYmxlIHNlIHNhbGUgZGUgbGEgcGFudGFsbGEuXG4gICAgICAgIHByaXZhdGUgY2FsY3VsYXRlU2Nyb2xsID0gKEhUTUxMaXN0OiBIVE1MRWxlbWVudCB8IG51bGwsIEhUTUxTY3JvbGxhYmxlOiBIVE1MRWxlbWVudCB8IG51bGwpOiBudW1iZXIgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTY3JvbGxhYmxlKCkgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbnN0IEhUTUxTY3JvbGxhYmxlOiBIVE1MRWxlbWVudCB8IG51bGwgPSB0aGlzLmdldFNjcm9sbGFibGVFbGVtZW50KCkgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmIChkb2N1bWVudCAhPT0gbnVsbCAmJiBIVE1MU2Nyb2xsYWJsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IEhUTUxMaXN0OiBIVE1MRWxlbWVudCB8IG51bGwgPSBSZWFjdERPTS5maW5kRE9NTm9kZShIVE1MU2Nyb2xsYWJsZSkucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoSFRNTExpc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmdpbjogbnVtYmVyID0gMTAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5zY3JvbGxQYWRkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IHRoaXMucHJvcHMuc2Nyb2xsUGFkZGluZyBhcyBudW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0OiBudW1iZXIgPSBIVE1MU2Nyb2xsYWJsZS5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodDogbnVtYmVyID0gSFRNTFNjcm9sbGFibGUub2Zmc2V0V2lkdGggKyBIVE1MU2Nyb2xsYWJsZS5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aDogbnVtYmVyID0gSFRNTFNjcm9sbGFibGUub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50TGVmdDogbnVtYmVyID0gSFRNTExpc3Qub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UmlnaHQ6IG51bWJlciA9IEhUTUxMaXN0Lm9mZnNldFdpZHRoICsgSFRNTExpc3Qub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50V2lkdGg6IG51bWJlciA9IEhUTUxMaXN0Lm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWw6IG51bWJlciA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodCArIG1hcmdpbiA+IHBhcmVudFJpZ2h0ICsgSFRNTExpc3Quc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2kgZWwgZWxlbWVudG8gc2Ugc2FsZSBwb3IgbGEgZGVyZWNoYS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJpZ2h0IC0gcGFyZW50V2lkdGggKyBtYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAtIG1hcmdpbiA8IEhUTUxMaXN0LnNjcm9sbExlZnQgKyBwYXJlbnRMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaSBlbCBlbGVtZW50byBzZSBzYWxlIHBvciBsYSBpenF1aWVyZGEuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBsZWZ0IC0gbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gSFRNTExpc3Quc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVqZWN1dGFtb3MgZWwgc2Nyb2xsIHRlbmllbmRvIGVuIGN1ZW50YSBzaSBzZSBxdWllcmUgYXPDrW5jcm9uYW1lbnRlIG8gbm8geSBhbCBmaW5hbFxuICAgICAgICAvLyBMbGFtYW1vcyBhIGxhIGZ1bmNpw7NuIGNhbGxiYWNrIHF1ZSBzZSBoYXlhIHBhc2FkbyBjb21vIHBhcsOhbWV0cm8uXG4gICAgICAgIHByaXZhdGUgZG9TZWxmU2Nyb2xsID0gKGFzeW5jOiBib29sZWFuLCBjYWxsYmFjaz86ICgpID0+IHZvaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrT2s6ICgpID0+IHZvaWQgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gKCkgPT4gMCA6IGNhbGxiYWNrO1xuICAgICAgICAgICAgY29uc3QgSFRNTEl0ZW06IEhUTUxFbGVtZW50IHwgbnVsbCA9IHRoaXMuZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IEhUTUxMaXN0OiBIVE1MRWxlbWVudCB8IG51bGwgPSBIVE1MSXRlbSA/IFJlYWN0RE9NLmZpbmRET01Ob2RlKEhUTUxJdGVtKS5wYXJlbnRFbGVtZW50IDogbnVsbDtcblxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsOiBudW1iZXIgPSB0aGlzLmNhbGN1bGF0ZVNjcm9sbChIVE1MTGlzdCwgSFRNTEl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoc2Nyb2xsID49IDAgJiYgSFRNTExpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEN1YW5kbyBlcyBhc8OtbmNyb25hIGxhIGxsYW1hZGEuXG4gICAgICAgICAgICAgICAgaWYgKGFzeW5jID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgSFRNTExpc3Quc2Nyb2xsTGVmdCA9IHNjcm9sbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFja09rKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEN1YW5kbyBlcyBzw61uY3JvbmEuXG4gICAgICAgICAgICAgICAgICAgIEhUTUxMaXN0LnNjcm9sbExlZnQgPSBzY3JvbGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFja09rKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tPaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJpdmF0ZSBpbkZvY3VzQ2hhaW4obmF2aWdhdGlvbj86IElOYXZpZ2FibGUpOiBib29sZWFuIHtcbiAgICAgICAgICAgIGNvbnN0IG5hdiA9IG5hdmlnYXRpb247XG4gICAgICAgICAgICBjb25zdCBteUlkID0gdGhpcy5nZXRJZCgpO1xuICAgICAgICAgICAgaWYgKG5hdikge1xuICAgICAgICAgICAgICAgIGlmIChuYXYuaWQgPT09IG15SWQgfHwgbmF2LnBhcmVudElkID09PSBteUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmF2LnBhcmVudElkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbkZvY3VzQ2hhaW4odGhpcy5wcm9wcy5uYXZpZ2F0aW9uLmdldChuYXYucGFyZW50SWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtYXBJVUlTdGF0ZVRvUHJvcHMgPSAoc3RhdGU6IElTdGF0ZSk6IElOYXZTdGF0ZSA9PiAoc3RhdGUubmF2KTtcbiAgICBjb25zdCBjb25uZWN0ZWQ6IFJlYWN0LkNvbXBvbmVudENsYXNzPFRPcmlnaW5hbFByb3BzICYgSU5hdmlnYWJsZVByb3BzICYgeyBjbGFzc05hbWU/OiBhbnkgfS8qICYgSU5hdkFjdGlvbnMgJiBJTmF2U3RhdGUqLz4gPSBjb25uZWN0KFxuICAgICAgICBtYXBJVUlTdGF0ZVRvUHJvcHMsIE5hdkFjdGlvbnMsIHVuZGVmaW5lZCwgeyB3aXRoUmVmOiB0cnVlIH0sXG4gICAgKShOYXZpZ2FibGUgYXMgYW55KSBhcyBhbnk7XG5cbiAgICByZXR1cm4gY29ubmVjdGVkO1xufTtcblxuZXhwb3J0IGNvbnN0IG5hdmlnYWJsZSA9IE5hdmlnYWJsZUNsYXNzO1xuXG5leHBvcnQgZGVmYXVsdCBuYXZpZ2FibGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9IT0MvbmF2aWdhYmxlL25hdmlnYWJsZS5IT0MudHN4IiwiZXhwb3J0IGZ1bmN0aW9uIHN0YXRpY3MoYTogYW55KSB7XG4gICAgcmV0dXJuIChiOiBhbnkpID0+IE9iamVjdC5hc3NpZ24oYiwgYSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0hPQy9zdGF0aWNzL3N0YXRpY3MuSE9DLnRzeCIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBSb3V0ZUNvbXBvbmVudFByb3BzIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmltcG9ydCB7IE1hcFN0YXRlVG9Qcm9wc1BhcmFtIH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XG5cbmltcG9ydCB7IENhcmREZXRhaWxDb250YWluZXIsIExheW91dCB9IGZyb20gJ0NvbnRhaW5lcnMnO1xuaW1wb3J0IHsgQ2FyZCB9IGZyb20gJ1NlcnZpY2VzJztcbmltcG9ydCB7IG5hdmlnYWJsZSB9IGZyb20gJ0hPQyc7XG5pbXBvcnQgeyBVSUFjdGlvbnMsIElVSUFjdGlvbnMgfSBmcm9tICdBY3Rpb25zJztcblxuZXhwb3J0IG5hbWVzcGFjZSBBcHAge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgSU93blByb3BzIHtcbiAgICAgICAgLy8gY2FyZHM6IENhcmRbXTtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIElBY3Rpb25Qcm9wcyBleHRlbmRzIElVSUFjdGlvbnMge1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgSVN0YXRlIHtcbiAgICAgICAgLyogZW1wdHkgKi9cbiAgICB9XG59XG4vLyBGcmllbmRzKFNlcmllKTogZTkwZjEyNGUtYWY2OS0zNzU3LTkyMWItZDViYWMxOGU1YTMxXG4vLyBDYXJyeShQZXJzb24pOiAyOGU3Y2I1Mi0wMWEyLTNlOTUtYTcxZi00ZmMyZDNlNDZmODZcbi8vIGM1OGJiZjFmLTZmZjUtMTFlNS1iN2MyLTA2ODQ5ODVjYmJlM1xuLy8gU2V4byBlbiBOWSAoTW92aWUpOiBiZDRmMjZiYS0wYzJhLTNhMTYtYmI3Yi03OWFhMDY2YWJmNDRcbi8vIEdhbWUgb2YgdGhyb25lcyhTZXJpZSkgZDYxMjQzMTgtOWRiMi0zNDFhLTk0OWYtMjVmYTY3YTAzMmQ3XG4vLyBNaW5pc3RlcmlvIGRlbCB0aWVtcG8oU2VyaWUpOiAwY2U3M2Y2ZC02NjE2LTM4ZTMtYmEyMi0yMTAwOWM5MWJhODFcblxuXG4vKkBuYXZpZ2FibGVcbkBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpKi9cbmV4cG9ydCBjbGFzcyBBcHBDbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxBcHAuSU93blByb3BzICYgQXBwLklBY3Rpb25Qcm9wcywgQXBwLklTdGF0ZT4ge1xuICAgIHB1YmxpYyBjb21wb25lbnRXaWxsTW91bnQoKXtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVuZGVyKCk6IGFueSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFwcFwiPlxuICAgICAgICAgICAgICAgIDxMYXlvdXQgY29sdW1ucz17MX0gcGFyZW50PXt0aGlzfS8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZTogYW55KSB7XG4gICAgcmV0dXJuIHtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2g6IGFueSk6IEFwcC5JQWN0aW9uUHJvcHMge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLlVJQWN0aW9uc1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoc3RhdGVQcm9wczogYW55LCBkaXNwYXRjaFByb3BzOiBhbnksIG93blByb3BzOiBhbnkpOiBBcHAuSU93blByb3BzIHtcbiAgICByZXR1cm4geyAuLi5zdGF0ZVByb3BzLCAuLi5vd25Qcm9wcywgLi4uZGlzcGF0Y2hQcm9wcyB9O1xufVxuXG5leHBvcnQgY29uc3QgQXBwID0gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcykoQXBwQ2xhc3MpO1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb250YWluZXJzL0FwcC9hcHAudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2FyZCB9IGZyb20gXCJTZXJ2aWNlc1wiO1xuaW1wb3J0IHsgY2FyZE1vZHVsZUNvbmZpZywgY2FyZE1vZHVsZUNsYXNzZXMsIGlzVmFsaWRhdGFibGUgfSBmcm9tIFwiQ2FyZE1vZHVsZXNcIjtcbmltcG9ydCB7IG5hdmlnYWJsZSB9IGZyb20gXCJIT0NcIjtcbmltcG9ydCB7IE5hdmlnYXRpb25Db250YWluZXIsIExvYWRpbmcgfSBmcm9tIFwiQ29tcG9uZW50c1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElDYXJkTW9kdWxlTGlzdFByb3BzIHtcbiAgICBjYXJkOiBDYXJkO1xufVxuZXhwb3J0IGNsYXNzIENhcmRNb2R1bGVMaXN0IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxJQ2FyZE1vZHVsZUxpc3RQcm9wcywge30+IHtcbiAgICBwdWJsaWMgcmVuZGVyKCk6IGFueSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRNb2R1bGVzQ29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2FyZCA/IHRoaXMuZGVjaWRlTW9kdWxlcyh0aGlzLnByb3BzLmNhcmQpIDogPExvYWRpbmcgLz59XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlY2lkZU1vZHVsZXMoY2FyZDogQ2FyZCk6IEpTWC5FbGVtZW50W10ge1xuICAgICAgICBjb25zdCBtb2R1bGVzOiBBcnJheTxSZWFjdC5Db21wb25lbnQ8YW55LCBhbnk+PiA9IFtdO1xuICAgICAgICBjb25zdCBtb2R1bGVMaXN0OiBKU1guRWxlbWVudFtdID0gW107XG4gICAgICAgIGNvbnN0IGNhcmRNb2R1bGVPcmRlciA9IGNhcmRNb2R1bGVDb25maWdbY2FyZC50eXBlXTtcbiAgICAgICAgaWYgKGNhcmQudHlwZSAmJiBjYXJkTW9kdWxlT3JkZXIgJiYgY2FyZE1vZHVsZU9yZGVyLnNlY3Rpb25zICYmXG4gICAgICAgICAgICBjYXJkTW9kdWxlT3JkZXIuc2VjdGlvbnNbMF0gJiZcbiAgICAgICAgICAgIGNhcmRNb2R1bGVPcmRlci5zZWN0aW9uc1swXS5tb2R1bGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGNhcmRNb2R1bGVPcmRlci5zZWN0aW9uc1swXS5tb2R1bGVzXG4gICAgICAgICAgICAgICAgLm1hcCgoY2FyZE1vZHVsZTogeyB0eXBlOiBzdHJpbmcgfSwgaWR4OiBudW1iZXIpOiBhbnkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FyZE1vZHVsZS50eXBlICYmIGNhcmRNb2R1bGUudHlwZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gY2FyZE1vZHVsZUNsYXNzZXNbY2FyZE1vZHVsZS50eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkYXRhYmxlKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkluc3RhbnRpYXRpbmdcIiwgY2FyZE1vZHVsZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlSW5zdGFuY2UgPSBjYW5kaWRhdGUudmFsaWRhdGUoY2FyZCwgY2FyZE1vZHVsZS50eXBlLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Njcm9sbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxQYWRkaW5nOiAzMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkluc3RhbnRpYXRpbmcgYmVjYXVzZSB2YWxpZGF0ZWRcIiwgY2FyZE1vZHVsZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hdkNsYXNzID0gY2FuZGlkYXRlLm1vZHVsZU5hbWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2NhbmRpZGF0ZS5tb2R1bGVOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCl9LWNvbnRhaW5lciBjYXJkTW9kdWxlLWNvbnRhaW5lciBzY3JvbGxhYmxlYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb250YWluZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUxpc3QucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17bmF2Q2xhc3N9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17YCR7Y2FyZC5jYXJkX2lkfV9tb2R1bGVfJHtpZHh9YH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHttb2R1bGVJbnN0YW5jZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gZXhpc3RlIGVsIG3Ds2R1bG8gbyBubyBoYSB2YWxpZGFkb1wiLCBjYXJkTW9kdWxlLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gZXhpc3RlIGVsIG3Ds2R1bG9cIiwgY2FyZE1vZHVsZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSBlcnJvclxuICAgICAgICByZXR1cm4gbW9kdWxlTGlzdDtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBOYXZpZ2FibGVDYXJkTW9kdWxlTGlzdCA9IG5hdmlnYWJsZShDYXJkTW9kdWxlTGlzdCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb250YWluZXJzL2NhcmRNb2R1bGVMaXN0L2NhcmRNb2R1bGVMaXN0LmNvbnRhaW5lci50c3giLCJpbXBvcnQgeyBDYXJkVHlwZUVudW0gfSBmcm9tICdTZXJ2aWNlcyc7XG5cbmltcG9ydCAqIGFzIGFydENvbmZpZyBmcm9tICcuLi9jb25maWcvYXJ0Lmpzb24nO1xuaW1wb3J0ICogYXMgYnVzaW5lc3NDb25maWcgZnJvbSAnLi4vY29uZmlnL2J1c2luZXNzLmpzb24nO1xuaW1wb3J0ICogYXMgY2hhcHRlckNvbmZpZyBmcm9tICcuLi9jb25maWcvY2hhcHRlci5qc29uJztcbmltcG9ydCAqIGFzIGZhc2hpb25Db25maWcgZnJvbSAnLi4vY29uZmlnL2Zhc2hpb24uanNvbic7XG5pbXBvcnQgKiBhcyBmYXVuYV9mbG9yYUNvbmZpZyBmcm9tICcuLi9jb25maWcvZmF1bmFfZmxvcmEuanNvbic7XG5pbXBvcnQgKiBhcyBmb29kX2RyaW5rQ29uZmlnIGZyb20gJy4uL2NvbmZpZy9mb29kX2RyaW5rLmpzb24nO1xuaW1wb3J0ICogYXMgaGVhbHRoX2JlYXV0eUNvbmZpZyBmcm9tICcuLi9jb25maWcvaGVhbHRoX2JlYXV0eS5qc29uJztcbmltcG9ydCAqIGFzIGhpc3RvcmljQ29uZmlnIGZyb20gJy4uL2NvbmZpZy9oaXN0b3JpYy5qc29uJztcbmltcG9ydCAqIGFzIGhvbWVDb25maWcgZnJvbSAnLi4vY29uZmlnL2hvbWUuanNvbic7XG5pbXBvcnQgKiBhcyBsZWlzdXJlX3Nwb3J0Q29uZmlnIGZyb20gJy4uL2NvbmZpZy9sZWlzdXJlX3Nwb3J0Lmpzb24nO1xuaW1wb3J0ICogYXMgbG9jYXRpb25Db25maWcgZnJvbSAnLi4vY29uZmlnL2xvY2F0aW9uLmpzb24nO1xuaW1wb3J0ICogYXMgbG9va0NvbmZpZyBmcm9tICcuLi9jb25maWcvbG9vay5qc29uJztcbmltcG9ydCAqIGFzIG1vdmllQ29uZmlnIGZyb20gJy4uL2NvbmZpZy9tb3ZpZS5qc29uJztcbmltcG9ydCAqIGFzIG9zdENvbmZpZyBmcm9tICcuLi9jb25maWcvb3N0Lmpzb24nO1xuaW1wb3J0ICogYXMgcGVyc29uQ29uZmlnIGZyb20gJy4uL2NvbmZpZy9wZXJzb24uanNvbic7XG5pbXBvcnQgKiBhcyBjaGFyYWN0ZXJDb25maWcgZnJvbSAnLi4vY29uZmlnL2NoYXJhY3Rlci5qc29uJztcbmltcG9ydCAqIGFzIHJlZmVyZW5jZUNvbmZpZyBmcm9tICcuLi9jb25maWcvcmVmZXJlbmNlLmpzb24nO1xuaW1wb3J0ICogYXMgc2VyaWVDb25maWcgZnJvbSAnLi4vY29uZmlnL3NlcmllLmpzb24nO1xuaW1wb3J0ICogYXMgc29uZ0NvbmZpZyBmcm9tICcuLi9jb25maWcvc29uZy5qc29uJztcbmltcG9ydCAqIGFzIHRlY2hub2xvZ3lDb25maWcgZnJvbSAnLi4vY29uZmlnL3RlY2hub2xvZ3kuanNvbic7XG5pbXBvcnQgKiBhcyB0cml2aWFDb25maWcgZnJvbSAnLi4vY29uZmlnL3RyaXZpYS5qc29uJztcbmltcG9ydCAqIGFzIHZlaGljbGVDb25maWcgZnJvbSAnLi4vY29uZmlnL3ZlaGljbGUuanNvbic7XG5pbXBvcnQgKiBhcyB3ZWFwb25Db25maWcgZnJvbSAnLi4vY29uZmlnL3dlYXBvbi5qc29uJztcblxuY29uc3QgY2FyZERldGFpbENvbmZpZyA9IHtcbiAgICBhcnRDb25maWcsXG4gICAgYnVzaW5lc3NDb25maWcsXG4gICAgY2hhcHRlckNvbmZpZyxcbiAgICBmYXNoaW9uQ29uZmlnLFxuICAgIGZhdW5hX2Zsb3JhQ29uZmlnLFxuICAgIGZvb2RfZHJpbmtDb25maWcsXG4gICAgaGVhbHRoX2JlYXV0eUNvbmZpZyxcbiAgICBoaXN0b3JpY0NvbmZpZyxcbiAgICBob21lQ29uZmlnLFxuICAgIGxlaXN1cmVfc3BvcnRDb25maWcsXG4gICAgbG9jYXRpb25Db25maWcsXG4gICAgbG9va0NvbmZpZyxcbiAgICBtb3ZpZUNvbmZpZyxcbiAgICBvc3RDb25maWcsXG4gICAgcGVyc29uQ29uZmlnLFxuICAgIGNoYXJhY3RlckNvbmZpZyxcbiAgICByZWZlcmVuY2VDb25maWcsXG4gICAgc2VyaWVDb25maWcsXG4gICAgc29uZ0NvbmZpZyxcbiAgICB0ZWNobm9sb2d5Q29uZmlnLFxuICAgIHRyaXZpYUNvbmZpZyxcbiAgICB2ZWhpY2xlQ29uZmlnLFxuICAgIHdlYXBvbkNvbmZpZyxcbn07XG5cbmV4cG9ydCBjb25zdCBjYXJkTW9kdWxlQ29uZmlnOiB7W2tleSBpbiBDYXJkVHlwZUVudW1dPzogYW55IH0gPSB7XG4gICAgYXJ0OiBjYXJkRGV0YWlsQ29uZmlnLmFydENvbmZpZyxcbiAgICBidXNpbmVzczogY2FyZERldGFpbENvbmZpZy5idXNpbmVzc0NvbmZpZyxcbiAgICBjaGFwdGVyOiBjYXJkRGV0YWlsQ29uZmlnLmNoYXB0ZXJDb25maWcsXG4gICAgZmFzaGlvbjogY2FyZERldGFpbENvbmZpZy5mYXNoaW9uQ29uZmlnLFxuICAgIGZhdW5hX2Zsb3JhOiBjYXJkRGV0YWlsQ29uZmlnLmZhdW5hX2Zsb3JhQ29uZmlnLFxuICAgIGZvb2RfZHJpbms6IGNhcmREZXRhaWxDb25maWcuZm9vZF9kcmlua0NvbmZpZyxcbiAgICBoZWFsdGhfYmVhdXR5OiBjYXJkRGV0YWlsQ29uZmlnLmhlYWx0aF9iZWF1dHlDb25maWcsXG4gICAgaGlzdG9yaWM6IGNhcmREZXRhaWxDb25maWcuaGlzdG9yaWNDb25maWcsXG4gICAgaG9tZTogY2FyZERldGFpbENvbmZpZy5ob21lQ29uZmlnLFxuICAgIGxlaXN1cmVfc3BvcnQ6IGNhcmREZXRhaWxDb25maWcubGVpc3VyZV9zcG9ydENvbmZpZyxcbiAgICBsb2NhdGlvbjogY2FyZERldGFpbENvbmZpZy5sb2NhdGlvbkNvbmZpZyxcbiAgICBsb29rOiBjYXJkRGV0YWlsQ29uZmlnLmxvb2tDb25maWcsXG4gICAgbW92aWU6IGNhcmREZXRhaWxDb25maWcubW92aWVDb25maWcsXG4gICAgb3N0OiBjYXJkRGV0YWlsQ29uZmlnLm9zdENvbmZpZyxcbiAgICBwZXJzb246IGNhcmREZXRhaWxDb25maWcucGVyc29uQ29uZmlnLFxuICAgIGNoYXJhY3RlcjogY2FyZERldGFpbENvbmZpZy5jaGFyYWN0ZXJDb25maWcsXG4gICAgcmVmZXJlbmNlOiBjYXJkRGV0YWlsQ29uZmlnLnJlZmVyZW5jZUNvbmZpZyxcbiAgICBzZXJpZTogY2FyZERldGFpbENvbmZpZy5zZXJpZUNvbmZpZyxcbiAgICBzb25nOiBjYXJkRGV0YWlsQ29uZmlnLnNvbmdDb25maWcsXG4gICAgdGVjaG5vbG9neTogY2FyZERldGFpbENvbmZpZy50ZWNobm9sb2d5Q29uZmlnLFxuICAgIHRyaXZpYTogY2FyZERldGFpbENvbmZpZy50cml2aWFDb25maWcsXG4gICAgdmVoaWNsZTogY2FyZERldGFpbENvbmZpZy52ZWhpY2xlQ29uZmlnLFxuICAgIHdlYXBvbjogY2FyZERldGFpbENvbmZpZy53ZWFwb25Db25maWcsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NhcmRNb2R1bGVzL2NhcmREZXRhaWwuY29uZmlnLnRzeCIsIm1vZHVsZS5leHBvcnRzID0ge1wic2VjdGlvbnNcIjpbe1widGl0bGVcIjpcIm1haW5cIixcIm1haW5cIjp0cnVlLFwibW9kdWxlc1wiOlt7XCJ0eXBlXCI6XCJIZWFkZXJcIn0se1widHlwZVwiOlwiRGVzY3JpcHRpb25cIn0se1widHlwZVwiOlwiU2hvcFwifSx7XCJ0eXBlXCI6XCJUcmF2ZWxTaG9wXCJ9LHtcInR5cGVcIjpcIlNwZWNpZmljYXRpb25zXCJ9LHtcInR5cGVcIjpcIk1hcE1vZHVsZVwifSx7XCJ0eXBlXCI6XCJHYWxsZXJ5XCJ9LHtcInR5cGVcIjpcIkN1cmlvc2l0aWVzXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblwifSx7XCJ0eXBlXCI6XCJBcHBlYXJzSW5TaW5nbGVcIn0se1widHlwZVwiOlwiQmFja1RvSG9tZVwifV19XX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvYXJ0Lmpzb25cbi8vIG1vZHVsZSBpZCA9IDUyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInNlY3Rpb25zXCI6W3tcInRpdGxlXCI6XCJtYWluXCIsXCJtYWluXCI6dHJ1ZSxcIm1vZHVsZXNcIjpbe1widHlwZVwiOlwiSGVhZGVyXCJ9LHtcInR5cGVcIjpcIkRlc2NyaXB0aW9uXCJ9LHtcInR5cGVcIjpcIlNob3BcIn0se1widHlwZVwiOlwiVHJhdmVsU2hvcFwifSx7XCJ0eXBlXCI6XCJTcGVjaWZpY2F0aW9uc1wifSx7XCJ0eXBlXCI6XCJHYWxsZXJ5XCJ9LHtcInR5cGVcIjpcIkN1cmlvc2l0aWVzXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblNpbmdsZVwifSx7XCJ0eXBlXCI6XCJBcHBlYXJzSW5cIn0se1widHlwZVwiOlwiQmFja1RvSG9tZVwifV19XX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvYnVzaW5lc3MuanNvblxuLy8gbW9kdWxlIGlkID0gNTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1wic2VjdGlvbnNcIjpbe1widGl0bGVcIjpcIm1haW5cIixcIm1haW5cIjp0cnVlLFwibW9kdWxlc1wiOlt7XCJ0eXBlXCI6XCJNb3ZpZUhlYWRlclwifSx7XCJ0eXBlXCI6XCJNb3ZpZUhlYWRlclNtYWxsXCJ9LHtcInR5cGVcIjpcIk92ZXJ2aWV3XCJ9LHtcInR5cGVcIjpcIkJhc2ljSW5mb1wifSx7XCJ0eXBlXCI6XCJUcmFpbGVyXCJ9LHtcInR5cGVcIjpcIkNhc3RcIn0se1widHlwZVwiOlwiQmVsb25nVG9TaW5nbGVcIn0se1widHlwZVwiOlwiU2hvcFwifSx7XCJ0eXBlXCI6XCJUcmF2ZWxTaG9wXCJ9LHtcInR5cGVcIjpcIkN1cmlvc2l0aWVzXCJ9LHtcInR5cGVcIjpcIlBsYWNlc1Nob3duXCJ9LHtcInR5cGVcIjpcIlZlaGljbGVzXCJ9LHtcInR5cGVcIjpcIk1vdmllU291bmR0cmFja1wifSx7XCJ0eXBlXCI6XCJIaWdobGlnaHRzXCJ9LHtcInR5cGVcIjpcIkRpdmVJbk1vZHVsZVwifSx7XCJ0eXBlXCI6XCJSZWNvbW1lbmRlZFwifSx7XCJ0eXBlXCI6XCJCYWNrVG9Ib21lXCJ9XX1dfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9jaGFwdGVyLmpzb25cbi8vIG1vZHVsZSBpZCA9IDUzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInNlY3Rpb25zXCI6W3tcInRpdGxlXCI6XCJtYWluXCIsXCJtYWluXCI6dHJ1ZSxcIm1vZHVsZXNcIjpbe1widHlwZVwiOlwiQnV0dG9uSGVhZGVyXCJ9LHtcInR5cGVcIjpcIkRlc2NyaXB0aW9uXCJ9LHtcInR5cGVcIjpcIlNob3BcIn0se1widHlwZVwiOlwiVHJhdmVsU2hvcFwifSx7XCJ0eXBlXCI6XCJTcGVjaWZpY2F0aW9uc1wifSx7XCJ0eXBlXCI6XCJHYWxsZXJ5XCJ9LHtcInR5cGVcIjpcIkZhc2hpb25cIn0se1widHlwZVwiOlwiQ3VyaW9zaXRpZXNcIn0se1widHlwZVwiOlwiQXBwZWFyc0luU2luZ2xlXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblwifSx7XCJ0eXBlXCI6XCJCYWNrVG9Ib21lXCJ9XX1dfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9mYXNoaW9uLmpzb25cbi8vIG1vZHVsZSBpZCA9IDUzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInNlY3Rpb25zXCI6W3tcInRpdGxlXCI6XCJtYWluXCIsXCJtYWluXCI6dHJ1ZSxcIm1vZHVsZXNcIjpbe1widHlwZVwiOlwiSGVhZGVyXCJ9LHtcInR5cGVcIjpcIkRlc2NyaXB0aW9uXCJ9LHtcInR5cGVcIjpcIlNob3BcIn0se1widHlwZVwiOlwiVHJhdmVsU2hvcFwifSx7XCJ0eXBlXCI6XCJTcGVjaWZpY2F0aW9uc1wifSx7XCJ0eXBlXCI6XCJHYWxsZXJ5XCJ9LHtcInR5cGVcIjpcIkN1cmlvc2l0aWVzXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblNpbmdsZVwifSx7XCJ0eXBlXCI6XCJBcHBlYXJzSW5cIn0se1widHlwZVwiOlwiQmFja1RvSG9tZVwifV19XX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvZmF1bmFfZmxvcmEuanNvblxuLy8gbW9kdWxlIGlkID0gNTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1wic2VjdGlvbnNcIjpbe1widGl0bGVcIjpcIm1haW5cIixcIm1haW5cIjp0cnVlLFwibW9kdWxlc1wiOlt7XCJ0eXBlXCI6XCJIZWFkZXJcIn0se1widHlwZVwiOlwiRGVzY3JpcHRpb25cIn0se1widHlwZVwiOlwiU2hvcFwifSx7XCJ0eXBlXCI6XCJUcmF2ZWxTaG9wXCJ9LHtcInR5cGVcIjpcIlNwZWNpZmljYXRpb25zXCJ9LHtcInR5cGVcIjpcIkdhbGxlcnlcIn0se1widHlwZVwiOlwiVmlkZW9cIn0se1widHlwZVwiOlwiQ3VyaW9zaXRpZXNcIn0se1widHlwZVwiOlwiQXBwZWFyc0luU2luZ2xlXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblwifSx7XCJ0eXBlXCI6XCJCYWNrVG9Ib21lXCJ9XX1dfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9mb29kX2RyaW5rLmpzb25cbi8vIG1vZHVsZSBpZCA9IDUzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInNlY3Rpb25zXCI6W3tcInRpdGxlXCI6XCJtYWluXCIsXCJtYWluXCI6dHJ1ZSxcIm1vZHVsZXNcIjpbe1widHlwZVwiOlwiSGVhZGVyXCJ9LHtcInR5cGVcIjpcIkRlc2NyaXB0aW9uXCJ9LHtcInR5cGVcIjpcIlNob3BcIn0se1widHlwZVwiOlwiVHJhdmVsU2hvcFwifSx7XCJ0eXBlXCI6XCJTcGVjaWZpY2F0aW9uc1wifSx7XCJ0eXBlXCI6XCJHYWxsZXJ5XCJ9LHtcInR5cGVcIjpcIkN1cmlvc2l0aWVzXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblNpbmdsZVwifSx7XCJ0eXBlXCI6XCJBcHBlYXJzSW5cIn0se1widHlwZVwiOlwiQmFja1RvSG9tZVwifV19XX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvaGVhbHRoX2JlYXV0eS5qc29uXG4vLyBtb2R1bGUgaWQgPSA1MzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJzZWN0aW9uc1wiOlt7XCJ0aXRsZVwiOlwibWFpblwiLFwibWFpblwiOnRydWUsXCJtb2R1bGVzXCI6W3tcInR5cGVcIjpcIkhlYWRlclwifSx7XCJ0eXBlXCI6XCJEZXNjcmlwdGlvblwifSx7XCJ0eXBlXCI6XCJTaG9wXCJ9LHtcInR5cGVcIjpcIlRyYXZlbFNob3BcIn0se1widHlwZVwiOlwiTWFwTW9kdWxlXCJ9LHtcInR5cGVcIjpcIkdhbGxlcnlcIn0se1widHlwZVwiOlwiQ3VyaW9zaXRpZXNcIn0se1widHlwZVwiOlwiQXBwZWFyc0luU2luZ2xlXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblwifSx7XCJ0eXBlXCI6XCJCYWNrVG9Ib21lXCJ9XX1dfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9oaXN0b3JpYy5qc29uXG4vLyBtb2R1bGUgaWQgPSA1MzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJzZWN0aW9uc1wiOlt7XCJ0aXRsZVwiOlwibWFpblwiLFwibWFpblwiOnRydWUsXCJtb2R1bGVzXCI6W3tcInR5cGVcIjpcIkJ1dHRvbkhlYWRlclwifSx7XCJ0eXBlXCI6XCJEZXNjcmlwdGlvblwifSx7XCJ0eXBlXCI6XCJTaG9wXCJ9LHtcInR5cGVcIjpcIlRyYXZlbFNob3BcIn0se1widHlwZVwiOlwiU3BlY2lmaWNhdGlvbnNcIn0se1widHlwZVwiOlwiR2FsbGVyeVwifSx7XCJ0eXBlXCI6XCJIb21lXCJ9LHtcInR5cGVcIjpcIkNvbXBsZXRlVGhlRGVjb1wifSx7XCJ0eXBlXCI6XCJDdXJpb3NpdGllc1wifSx7XCJ0eXBlXCI6XCJBcHBlYXJzSW5cIn0se1widHlwZVwiOlwiQXBwZWFyc0luU2luZ2xlXCJ9LHtcInR5cGVcIjpcIkJhY2tUb0hvbWVcIn1dfV19XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY29uZmlnL2hvbWUuanNvblxuLy8gbW9kdWxlIGlkID0gNTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1wic2VjdGlvbnNcIjpbe1widGl0bGVcIjpcIm1haW5cIixcIm1haW5cIjp0cnVlLFwibW9kdWxlc1wiOlt7XCJ0eXBlXCI6XCJIZWFkZXJcIn0se1widHlwZVwiOlwiRGVzY3JpcHRpb25cIn0se1widHlwZVwiOlwiU2hvcFwifSx7XCJ0eXBlXCI6XCJUcmF2ZWxTaG9wXCJ9LHtcInR5cGVcIjpcIlNwZWNpZmljYXRpb25zXCJ9LHtcInR5cGVcIjpcIkdhbGxlcnlcIn0se1widHlwZVwiOlwiQ3VyaW9zaXRpZXNcIn0se1widHlwZVwiOlwiQXBwZWFyc0luU2luZ2xlXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblwifSx7XCJ0eXBlXCI6XCJCYWNrVG9Ib21lXCJ9XX1dfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9sZWlzdXJlX3Nwb3J0Lmpzb25cbi8vIG1vZHVsZSBpZCA9IDUzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInNlY3Rpb25zXCI6W3tcInRpdGxlXCI6XCJtYWluXCIsXCJtYWluXCI6dHJ1ZSxcIm1vZHVsZXNcIjpbe1widHlwZVwiOlwiSGVhZGVyXCJ9LHtcInR5cGVcIjpcIkRlc2NyaXB0aW9uXCJ9LHtcInR5cGVcIjpcIlNob3BcIn0se1widHlwZVwiOlwiVHJhdmVsU2hvcFwifSx7XCJ0eXBlXCI6XCJCYXNpY0luZm9cIn0se1widHlwZVwiOlwiR2FsbGVyeVwifSx7XCJ0eXBlXCI6XCJNYXBNb2R1bGVcIn0se1widHlwZVwiOlwiQ3VyaW9zaXRpZXNcIn0se1widHlwZVwiOlwiQXBwZWFyc0luTG9jYXRpb25cIn0se1widHlwZVwiOlwiQmFja1RvSG9tZVwifV19XX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvbG9jYXRpb24uanNvblxuLy8gbW9kdWxlIGlkID0gNTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1wic2VjdGlvbnNcIjpbe1widGl0bGVcIjpcIm1haW5cIixcIm1haW5cIjp0cnVlLFwibW9kdWxlc1wiOlt7XCJ0eXBlXCI6XCJCdXR0b25IZWFkZXJcIn0se1widHlwZVwiOlwiRGVzY3JpcHRpb25cIn0se1widHlwZVwiOlwiU3BlY2lmaWNhdGlvbnNcIn0se1widHlwZVwiOlwiR2FsbGVyeVwifSx7XCJ0eXBlXCI6XCJMb29rXCJ9LHtcInR5cGVcIjpcIkNhcnJ5XCJ9LHtcInR5cGVcIjpcIk1vcmVMb29rc1wifSx7XCJ0eXBlXCI6XCJDdXJpb3NpdGllc1wifSx7XCJ0eXBlXCI6XCJCYWNrVG9Ib21lXCJ9XX1dfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9sb29rLmpzb25cbi8vIG1vZHVsZSBpZCA9IDUzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInNlY3Rpb25zXCI6W3tcInRpdGxlXCI6XCJtYWluXCIsXCJtYWluXCI6dHJ1ZSxcIm1vZHVsZXNcIjpbe1widHlwZVwiOlwiTW92aWVIZWFkZXJcIn0se1widHlwZVwiOlwiTW92aWVIZWFkZXJTbWFsbFwifSx7XCJ0eXBlXCI6XCJPdmVydmlld1wifSx7XCJ0eXBlXCI6XCJCYXNpY0luZm9cIn0se1widHlwZVwiOlwiVHJhaWxlclwifSx7XCJ0eXBlXCI6XCJDYXN0XCJ9LHtcInR5cGVcIjpcIlNob3BcIn0se1widHlwZVwiOlwiVHJhdmVsU2hvcFwifSx7XCJ0eXBlXCI6XCJDdXJpb3NpdGllc1wifSx7XCJ0eXBlXCI6XCJQbGFjZXNTaG93blwifSx7XCJ0eXBlXCI6XCJWZWhpY2xlc1wifSx7XCJ0eXBlXCI6XCJNb3ZpZVNvdW5kdHJhY2tcIn0se1widHlwZVwiOlwiSGlnaGxpZ2h0c1wifSx7XCJ0eXBlXCI6XCJEaXZlSW5Nb2R1bGVcIn0se1widHlwZVwiOlwiUmVjb21tZW5kZWRcIn0se1widHlwZVwiOlwiQmFja1RvSG9tZVwifV19XX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvbW92aWUuanNvblxuLy8gbW9kdWxlIGlkID0gNTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1wic2VjdGlvbnNcIjpbe1widGl0bGVcIjpcIm1haW5cIixcIm1haW5cIjp0cnVlLFwibW9kdWxlc1wiOlt7XCJ0eXBlXCI6XCJIZWFkZXJcIn0se1widHlwZVwiOlwiU291bmR0cmFja1wifSx7XCJ0eXBlXCI6XCJEZXNjcmlwdGlvblwifSx7XCJ0eXBlXCI6XCJTaG9wXCJ9LHtcInR5cGVcIjpcIlRyYXZlbFNob3BcIn0se1widHlwZVwiOlwiU291bmRzSW5cIn0se1widHlwZVwiOlwiQmFja1RvSG9tZVwifV19XX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvb3N0Lmpzb25cbi8vIG1vZHVsZSBpZCA9IDU0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInNlY3Rpb25zXCI6W3tcInRpdGxlXCI6XCJtYWluXCIsXCJtYWluXCI6dHJ1ZSxcIm1vZHVsZXNcIjpbe1widHlwZVwiOlwiSGVhZGVyXCJ9LHtcInR5cGVcIjpcIkJpb2dyYXBoeVwifSx7XCJ0eXBlXCI6XCJCYXNpY0luZm9cIn0se1widHlwZVwiOlwiR2FsbGVyeVwifSx7XCJ0eXBlXCI6XCJBd2FyZHNNb2R1bGVMaXN0XCJ9LHtcInR5cGVcIjpcIlNob3BcIn0se1widHlwZVwiOlwiVHJhdmVsU2hvcFwifSx7XCJ0eXBlXCI6XCJDdXJpb3NpdGllc1wifSx7XCJ0eXBlXCI6XCJGaWxtb2dyYXBoeVwifSx7XCJ0eXBlXCI6XCJCYWNrVG9Ib21lXCJ9XX1dfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9wZXJzb24uanNvblxuLy8gbW9kdWxlIGlkID0gNTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1wic2VjdGlvbnNcIjpbe1widGl0bGVcIjpcIm1haW5cIixcIm1haW5cIjp0cnVlLFwibW9kdWxlc1wiOlt7XCJ0eXBlXCI6XCJIZWFkZXJcIn0se1widHlwZVwiOlwiQmlvZ3JhcGh5XCJ9LHtcInR5cGVcIjpcIlNob3BcIn0se1widHlwZVwiOlwiVHJhdmVsU2hvcFwifSx7XCJ0eXBlXCI6XCJCYXNpY0luZm9cIn0se1widHlwZVwiOlwiR2FsbGVyeVwifSx7XCJ0eXBlXCI6XCJWaWRlb1wifSx7XCJ0eXBlXCI6XCJDdXJpb3NpdGllc1wifSx7XCJ0eXBlXCI6XCJIaWdobGlndHNcIn0se1widHlwZVwiOlwiSW50ZXJwcmV0ZWRCeVNpbmdsZVwifSx7XCJ0eXBlXCI6XCJJbnRlcnByZXRlZEJ5XCJ9LHtcInR5cGVcIjpcIkJhY2tUb0hvbWVcIn1dfV19XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY29uZmlnL2NoYXJhY3Rlci5qc29uXG4vLyBtb2R1bGUgaWQgPSA1NDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJzZWN0aW9uc1wiOlt7XCJ0aXRsZVwiOlwibWFpblwiLFwibWFpblwiOnRydWUsXCJtb2R1bGVzXCI6W3tcInR5cGVcIjpcIlJlZmVyZW5jZVwifSx7XCJ0eXBlXCI6XCJHYWxsZXJ5XCJ9LHtcInR5cGVcIjpcIlZpZGVvXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblNpbmdsZVwifSx7XCJ0eXBlXCI6XCJBcHBlYXJzSW5cIn0se1widHlwZVwiOlwiQmFja1RvSG9tZVwifV19XX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvcmVmZXJlbmNlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDU0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInNlY3Rpb25zXCI6W3tcInRpdGxlXCI6XCJtYWluXCIsXCJtYWluXCI6dHJ1ZSxcIm1vZHVsZXNcIjpbe1widHlwZVwiOlwiTW92aWVIZWFkZXJcIn0se1widHlwZVwiOlwiTW92aWVIZWFkZXJTbWFsbFwifSx7XCJ0eXBlXCI6XCJPdmVydmlld1wifSx7XCJ0eXBlXCI6XCJTZWFzb25zXCJ9LHtcInR5cGVcIjpcIlRyYWlsZXJcIn0se1widHlwZVwiOlwiQmFzaWNJbmZvXCJ9LHtcInR5cGVcIjpcIkdhbGxlcnlcIn0se1widHlwZVwiOlwiQXdhcmRzTW9kdWxlTGlzdFwifSx7XCJ0eXBlXCI6XCJDYXN0XCJ9LHtcInR5cGVcIjpcIlNob3BcIn0se1widHlwZVwiOlwiVHJhdmVsU2hvcFwifSx7XCJ0eXBlXCI6XCJSZWNvbW1lbmRlZFwifSx7XCJ0eXBlXCI6XCJCYWNrVG9Ib21lXCJ9XX1dfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy9zZXJpZS5qc29uXG4vLyBtb2R1bGUgaWQgPSA1NDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJzZWN0aW9uc1wiOlt7XCJ0aXRsZVwiOlwibWFpblwiLFwibWFpblwiOnRydWUsXCJtb2R1bGVzXCI6W3tcInR5cGVcIjpcIkhlYWRlclwifSx7XCJ0eXBlXCI6XCJNdXNpY1Nob3BcIn0se1widHlwZVwiOlwiRGVzY3JpcHRpb25cIn0se1widHlwZVwiOlwiU2hvcFwifSx7XCJ0eXBlXCI6XCJUcmF2ZWxTaG9wXCJ9LHtcInR5cGVcIjpcIkN1cmlvc2l0aWVzXCJ9LHtcInR5cGVcIjpcIlNvbmdCZWxvbmdUb1NpbmdsZVwifSx7XCJ0eXBlXCI6XCJTb25nQmVsb25nVG9cIn0se1widHlwZVwiOlwiQmFja1RvSG9tZVwifV19XX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvc29uZy5qc29uXG4vLyBtb2R1bGUgaWQgPSA1NDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJzZWN0aW9uc1wiOlt7XCJ0aXRsZVwiOlwibWFpblwiLFwibWFpblwiOnRydWUsXCJtb2R1bGVzXCI6W3tcInR5cGVcIjpcIkhlYWRlclwifSx7XCJ0eXBlXCI6XCJEZXNjcmlwdGlvblwifSx7XCJ0eXBlXCI6XCJTaG9wXCJ9LHtcInR5cGVcIjpcIlRyYXZlbFNob3BcIn0se1widHlwZVwiOlwiU3BlY2lmaWNhdGlvbnNcIn0se1widHlwZVwiOlwiR2FsbGVyeVwifSx7XCJ0eXBlXCI6XCJWaWRlb1wifSx7XCJ0eXBlXCI6XCJBcHBlYXJzSW5TaW5nbGVcIn0se1widHlwZVwiOlwiQXBwZWFyc0luXCJ9LHtcInR5cGVcIjpcIkJhY2tUb0hvbWVcIn1dfV19XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY29uZmlnL3RlY2hub2xvZ3kuanNvblxuLy8gbW9kdWxlIGlkID0gNTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1wic2VjdGlvbnNcIjpbe1widGl0bGVcIjpcIm1haW5cIixcIm1haW5cIjp0cnVlLFwibW9kdWxlc1wiOlt7XCJ0eXBlXCI6XCJGdWxsQ3VyaW9zaXR5XCJ9LHtcInR5cGVcIjpcIkdhbGxlcnlcIn0se1widHlwZVwiOlwiVmlkZW9cIn0se1widHlwZVwiOlwiQXBwZWFyc0luU2luZ2xlXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblwifSx7XCJ0eXBlXCI6XCJCYWNrVG9Ib21lXCJ9XX1dfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy90cml2aWEuanNvblxuLy8gbW9kdWxlIGlkID0gNTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1wic2VjdGlvbnNcIjpbe1widGl0bGVcIjpcIm1haW5cIixcIm1haW5cIjp0cnVlLFwibW9kdWxlc1wiOlt7XCJ0eXBlXCI6XCJIZWFkZXJcIn0se1widHlwZVwiOlwiRGVzY3JpcHRpb25cIn0se1widHlwZVwiOlwiU2hvcFwifSx7XCJ0eXBlXCI6XCJUcmF2ZWxTaG9wXCJ9LHtcInR5cGVcIjpcIlNwZWNpZmljYXRpb25zXCJ9LHtcInR5cGVcIjpcIkdhbGxlcnlcIn0se1widHlwZVwiOlwiVmlkZW9cIn0se1widHlwZVwiOlwiQ3VyaW9zaXRpZXNcIn0se1widHlwZVwiOlwiQXBwZWFyc0luU2luZ2xlXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblwifSx7XCJ0eXBlXCI6XCJCYWNrVG9Ib21lXCJ9XX1dfVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NvbmZpZy92ZWhpY2xlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDU0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcInNlY3Rpb25zXCI6W3tcInRpdGxlXCI6XCJtYWluXCIsXCJtYWluXCI6dHJ1ZSxcIm1vZHVsZXNcIjpbe1widHlwZVwiOlwiSGVhZGVyXCJ9LHtcInR5cGVcIjpcIkRlc2NyaXB0aW9uXCJ9LHtcInR5cGVcIjpcIlNob3BcIn0se1widHlwZVwiOlwiVHJhdmVsU2hvcFwifSx7XCJ0eXBlXCI6XCJTcGVjaWZpY2F0aW9uc1wifSx7XCJ0eXBlXCI6XCJHYWxsZXJ5XCJ9LHtcInR5cGVcIjpcIkN1cmlvc2l0aWVzXCJ9LHtcInR5cGVcIjpcIkFwcGVhcnNJblNpbmdsZVwifSx7XCJ0eXBlXCI6XCJBcHBlYXJzSW5cIn0se1widHlwZVwiOlwiQmFja1RvSG9tZVwifV19XX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jb25maWcvd2VhcG9uLmpzb25cbi8vIG1vZHVsZSBpZCA9IDU1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHsgQ2FyZCB9IGZyb20gXCJTZXJ2aWNlc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElWYWxpZGF0YWJsZSB7XG4gICAgdmFsaWRhdGU6IChjYXJkOiBDYXJkLCBtb2R1bGVUeXBlOiBzdHJpbmcsIHBhcmVudDogYW55LCBwcm9wczogYW55KSA9PiBKU1guRWxlbWVudCB8IG51bGw7IC8vIFJlYWN0LkNvbXBvbmVudDxhbnksIGFueT47XG4gICAgbW9kdWxlTmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZGF0YWJsZShvYmplY3Q6IGFueSk6IG9iamVjdCBpcyBJVmFsaWRhdGFibGUge1xuICAgIHJldHVybiBvYmplY3QgJiYgJ3ZhbGlkYXRlJyBpbiBvYmplY3Q7XG59XG4vKlxuZXhwb3J0IGNsYXNzIENhcmRNb2R1bGU8Qz4ge1xuICAgIHB1YmxpYyBzdGF0aWMgdmFsaWRhdGU6IChtb2R1bGVDbGFzczogSVZhbGlkYXRhYmxlLCBjYXJkOiBDYXJkKVxuICAgICAgICA9PiBSZWFjdC5Db21wb25lbnQ8YW55LCBhbnk+IHwgdW5kZWZpbmVkO1xufVxuKi9cbi8qXG5pbnRlcmZhY2UgSUNhcmRNb2R1bGVTdGF0aWM8QyBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IElDYXJkTW9kdWxlPEM+PiB7XG4gICAgdmFsaWRhdGU6IChjYXJkOiBDYXJkKSA9PiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElDYXJkTW9kdWxlPEMgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+IHtcbiAgICBjb25zdHJ1Y3RvcjogYW55O1xufSovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY2FyZE1vZHVsZXMvY2FyZE1vZHVsZS5iYXNlLmNvbXBvbmVudC50c3giLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tIFwicmVhY3QtcmVkdXhcIjtcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gXCJyZWR1eFwiO1xuXG5pbXBvcnQgeyBDYXJkLCBIZWxwZXIsIExvY2FsaXplLCBDYXRhbG9nIH0gZnJvbSBcIlNlcnZpY2VzXCI7XG5pbXBvcnQgeyBNaW5pQ2FyZCwgQ2FyZEFuZENhdGVnb3J5LCBOYXZpZ2F0aW9uQ29udGFpbmVyIH0gZnJvbSBcIkNvbXBvbmVudHNcIjtcbmltcG9ydCB7IElDYXJkTW9kdWxlUHJvcHMgfSBmcm9tIFwiQ2FyZE1vZHVsZXNcIjtcbmltcG9ydCB7IG5hdmlnYWJsZSwgc3RhdGljcyB9IGZyb20gXCJIT0NcIjtcblxuaW50ZXJmYWNlIElIZWFkZXJQcm9wcyB7XG4gICAgdGl0bGU6IHN0cmluZyB8IG51bGw7XG4gICAgc3VidGl0bGU6IHN0cmluZyB8IEpTWC5FbGVtZW50IHwgRWxlbWVudCB8IG51bGw7XG4gICAgbmF2aWdhYmxlU3VidGl0bGU6IGJvb2xlYW47XG4gICAgdGltZTogc3RyaW5nIHwgbnVsbDsgLy8gXCIyIGggMTMgbVwiO1xuICAgIHRpdGxlUGFyZW50aGVzaXM6IHN0cmluZyB8IG51bGw7IC8vID0gXCIyMDE3XCI7XG4gICAgY2F0ZWdvcmllczogc3RyaW5nIHwgbnVsbDsgLy8gXCJCaW8sIEFkdmVudHVyZSwgQ29tZWR5XCI7XG59XG5cbkBzdGF0aWNzKHtcbiAgICBtb2R1bGVOYW1lOiBcImhlYWRlclwiLFxuICAgIHZhbGlkYXRlOiAoY2FyZDogQ2FyZCwgbW9kdWxlVHlwZTogc3RyaW5nLCBwYXJlbnQ6IGFueSwgcHJvcHM6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCB0aXRsZTogc3RyaW5nIHwgbnVsbCA9IGNhcmQudGl0bGU7XG4gICAgICAgIGxldCBzdWJ0aXRsZTogc3RyaW5nIHwgSlNYLkVsZW1lbnQgfCBFbGVtZW50IHwgbnVsbCA9IGNhcmQuc3VidGl0bGUgJiYgY2FyZC5zdWJ0aXRsZSAhPT0gXCJcIiA/XG4gICAgICAgICAgICBjYXJkLnN1YnRpdGxlIDogbnVsbDtcbiAgICAgICAgbGV0IHRpbWU6IHN0cmluZyB8IG51bGwgPSBudWxsOyAvLyBcIjIgaCAxMyBtXCI7XG4gICAgICAgIGxldCB0aXRsZVBhcmVudGhlc2lzOiBzdHJpbmcgfCBudWxsID0gbnVsbDsgLy8gPSBcIjIwMTdcIjtcbiAgICAgICAgbGV0IGNhdGVnb3JpZXM6IHN0cmluZyB8IG51bGwgPSBudWxsOyAvLyBcIkJpbywgQWR2ZW50dXJlLCBDb21lZHlcIjtcbiAgICAgICAgbGV0IG5hdmlnYWJsZVN1YnRpdGxlID0gZmFsc2U7XG5cbiAgICAgICAgc3dpdGNoIChjYXJkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtb3ZpZVwiOlxuICAgICAgICAgICAgY2FzZSBcInNlcmllXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2hhcHRlclwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IGNhdGFsb2dJbmZvID0gSGVscGVyLmdldENvbnRhaW5lcihjYXJkLCBcImNhdGFsb2dcIikgYXMgQ2F0YWxvZztcbiAgICAgICAgICAgICAgICBpZiAoY2F0YWxvZ0luZm8gJiYgY2F0YWxvZ0luZm8uZGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICBjYXRhbG9nSW5mby5kYXRhWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lZGlhRGF0YSA9IGNhdGFsb2dJbmZvLmRhdGFbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWRpYURhdGEucnVudGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRUaW1lSW5TZWNzID0gbWVkaWFEYXRhLnJ1bnRpbWUhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKGN1cnJlbnRUaW1lSW5TZWNzIC8gMzYwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGltZUluU2VjcyAlPSAzNjAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoY3VycmVudFRpbWVJblNlY3MgLyA2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lID0gYCR7bWludXRlc30gbWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG91cnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZSA9IGAke2hvdXJzfSBoICR7dGltZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWRpYURhdGEueWVhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGVQYXJlbnRoZXNpcyA9IGAke2NhdGFsb2dJbmZvLmRhdGFbMF0ueWVhcn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWRpYURhdGEuZ2VucmVzICYmIG1lZGlhRGF0YS5nZW5yZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcyA9IG1lZGlhRGF0YS5nZW5yZXMuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWRpYURhdGEuZGlyZWN0b3IgJiYgbWVkaWFEYXRhLmRpcmVjdG9yICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IG1lZGlhRGF0YS5kaXJlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYWJsZVN1YnRpdGxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IEluc3RhbnRpYXRlZCA9IG5hdmlnYWJsZShIZWFkZXIpO1xuXG4gICAgICAgIHJldHVybiAoPEluc3RhbnRpYXRlZFxuICAgICAgICAgICAgcGFyZW50PXtwYXJlbnR9XG4gICAgICAgICAgICBpc1Njcm9sbGFibGU9e3RydWV9XG4gICAgICAgICAgICBjYXJkPXtjYXJkfSBtb2R1bGVUeXBlPXttb2R1bGVUeXBlfVxuICAgICAgICAgICAgdGl0bGU9e3RpdGxlfSBzdWJ0aXRsZT17c3VidGl0bGV9XG4gICAgICAgICAgICBuYXZpZ2FibGVTdWJ0aXRsZT17bmF2aWdhYmxlU3VidGl0bGV9XG4gICAgICAgICAgICB0aW1lPXt0aW1lfSB0aXRsZVBhcmVudGhlc2lzPXt0aXRsZVBhcmVudGhlc2lzfVxuICAgICAgICAgICAgY2F0ZWdvcmllcz17Y2F0ZWdvcmllc31cbiAgICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgLz4pO1xuICAgIH0sXG59KVxuZXhwb3J0IGNsYXNzIEhlYWRlciBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8SUNhcmRNb2R1bGVQcm9wcyAmIElIZWFkZXJQcm9wcywge30+IHtcbiAgICBwdWJsaWMgZ2V0U3VidGl0bGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm5hdmlnYWJsZVN1YnRpdGxlICYmIHRoaXMucHJvcHMuc3VidGl0bGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG9wZW4gY2FyZFxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInN1YnRpdGxlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxOYXZpZ2F0aW9uQ29udGFpbmVyIHBhcmVudD17dGhpc30gY29sdW1ucz17MX0+XG4gICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5zdWJ0aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgPC9OYXZpZ2F0aW9uQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnN1YnRpdGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gKDxkaXYgY2xhc3NOYW1lPVwic3VidGl0bGVcIj57dGhpcy5wcm9wcy5zdWJ0aXRsZX08L2Rpdj4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVibGljIHJlbmRlcigpOiBKU1guRWxlbWVudCB7XG4gICAgICAgIGNvbnN0IHN1YnRpdGxlID0gdGhpcy5nZXRTdWJ0aXRsZSgpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXIgY2FyZE1vZHVsZVwiPlxuICAgICAgICAgICAgICAgIDxDYXJkQW5kQ2F0ZWdvcnkgY2FyZD17dGhpcy5wcm9wcy5jYXJkfSAvPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmlnaHRQYXJ0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5mb1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0aXRsZUNvbnRhaW5lclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRpdGxlXCI+e3RoaXMucHJvcHMudGl0bGV9PC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy50aXRsZVBhcmVudGhlc2lzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGl0bGVQYXJlbnRoZXNpc1wiPiAoe3RoaXMucHJvcHMudGl0bGVQYXJlbnRoZXNpc30pPC9kaXY+IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtzdWJ0aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmNhdGVnb3JpZXMgPyA8ZGl2IGNsYXNzTmFtZT1cImNhdGVnb3JpZXNcIj57dGhpcy5wcm9wcy5jYXRlZ29yaWVzfTwvZGl2PiA6IG51bGx9XG4gICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy50aW1lID8gKDxkaXYgY2xhc3NOYW1lPVwidGltZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImNsb2NrXCI+PC9pPjxzcGFuPnt0aGlzLnByb3BzLnRpbWV9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+KSA6IG51bGx9XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlckJ1dHRvbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TmF2aWdhdGlvbkNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ9e3RoaXN9IGNvbHVtbnM9ezF9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVmYXVsdD17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgbGlrZUJ1dHRvbiBnZW5lcmljQnRuYH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGlja0FjdGlvbj17dGhpcy5jbGlja0xpa2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2VudGVyZWRDb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJpY29uIGxpa2VcIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57TG9jYWxpemUoXCJDQVJPVVNFTF9DQVJEX1NBVkVcIil9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L05hdmlnYXRpb25Db250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2RpdiA+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NhcmRNb2R1bGVzL2hlYWRlci9oZWFkZXIuY29tcG9uZW50LnRzeCIsImltcG9ydCB7XG4gICAgQ2FyZCxcbiAgICBDYXJkQ29udGFpbmVyVHlwZUVudW0sXG4gICAgQ2FyZENvbnRhaW5lcixcbiAgICBSZWxhdGlvbk1vZHVsZSxcbiAgICBEdXBsZSxcbiAgICBTaW5nbGVcbn0gZnJvbSAnU2VydmljZXMnO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW50ZXJuYWwtbW9kdWxlXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tbmFtZXNwYWNlXG5jbGFzcyBIZWxwZXJDbGFzcyB7XG4gICAgcHVibGljIGdldENvbnRhaW5lciA9IChjYXJkOiBDYXJkLCB0eXBlOiBDYXJkQ29udGFpbmVyVHlwZUVudW0pOiBDYXJkQ29udGFpbmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgICAgcmV0dXJuIGNhcmQuaW5mb1xuICAgICAgICAgICAgPyBjYXJkXG4gICAgICAgICAgICAgICAgLmluZm9cbiAgICAgICAgICAgICAgICAuZmlsdGVyKChlbDogQ2FyZENvbnRhaW5lcikgPT4gZWwudHlwZSA9PT0gdHlwZSlbMF1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRSZWxhdGlvbiA9IChyZWxhdGlvbnM6IEFycmF5PFJlbGF0aW9uTW9kdWxlPiwgdmFsdWU6IHN0cmluZywgZmllbGQ6IHN0cmluZyA9ICd0eXBlJyk6IFJlbGF0aW9uTW9kdWxlIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgICAgcmV0dXJuIHJlbGF0aW9uc1xuICAgICAgICAgICAgPyByZWxhdGlvbnMuZmlsdGVyKChlbDogUmVsYXRpb25Nb2R1bGUgfCBhbnkpID0+IGVsW2ZpZWxkXSBhcyBhbnkgPT09IHZhbHVlKVswXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGN1dFRleHQgPSAodGV4dDogc3RyaW5nLCBjb3VudDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gY291bnQpIHtcbiAgICAgICAgICAgIGlmIChjb3VudCArIDMgPj0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKDAsIGNvdW50KSArICcuLi4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBIZWxwZXIgPSBuZXcgSGVscGVyQ2xhc3MoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NlcnZpY2VzL2hlbHBlci50c3giLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBtZW1vaXplZSBmcm9tICdtZW1vaXplZSc7XG5cbmltcG9ydCAqIGFzIEVTIGZyb20gJy4uL2Fzc2V0cy9FUy9sb2NhbGl6ZWRfdGV4dHMuanNvbic7XG5pbXBvcnQgKiBhcyBFTiBmcm9tICcuLi9hc3NldHMvRU4vbG9jYWxpemVkX3RleHRzLmpzb24nO1xuaW1wb3J0ICogYXMgREUgZnJvbSAnLi4vYXNzZXRzL0RFL2xvY2FsaXplZF90ZXh0cy5qc29uJztcblxudHlwZSBBdmFpbGFibGVMYW5ndWFnZXMgPSBcIkVTXCIgfCBcIkVOXCIgfCBcIkRFXCI7XG5cbmNsYXNzIExvY2FsaXplU2VydmljZSB7XG4gICAgcHJpdmF0ZSBsYW5ndWFnZTogQXZhaWxhYmxlTGFuZ3VhZ2VzID0gXCJFTlwiO1xuICAgIHByaXZhdGUgdGV4dHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7XG4gICAgICAgIEVOLFxuICAgICAgICBFUyxcbiAgICAgICAgREUsXG4gICAgfTtcbiAgICBwdWJsaWMgc2V0TGFuZ3VhZ2UobGFuZzogQXZhaWxhYmxlTGFuZ3VhZ2VzKSB7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5nO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhbmd1YWdlO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0TGl0ZXJhbChpZDogc3RyaW5nLCAuLi5zdWJzdGl0dXRpb25zOiBzdHJpbmdbXSk6IGFueSB7XG4gICAgICAgIC8vIGNhbiByZXR1cm4gc3RyaW5nLCBvciBtaXhlZCBhcnJheSB3aXRoIHN0cmluZ3MgYW5kIEpTWFxuICAgICAgICBpZiAodHlwZW9mIGlkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlVGV4dCA9IHRoaXMuZ2V0TGl0ZXJhbFdpdGhMYW5ndWFnZShpZCwgdGhpcy5sYW5ndWFnZSkgfHwgXCJcIjtcbiAgICAgICAgICAgIC8vIGxpbmUgYnJlYWtzXG4gICAgICAgICAgICBjb25zdCB0ZXh0QmxvY2tBcnJheTogYW55W10gPSBiYXNlVGV4dC5zcGxpdChcIlxcXFxuXCIpO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1jb25zdFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHdyaXRlID0gMSwgbGVuZ3RoID0gdGV4dEJsb2NrQXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGV4dEJsb2NrQXJyYXkuc3BsaWNlKHdyaXRlLCAwLCA8YnIga2V5PXtpfSAvPik7XG4gICAgICAgICAgICAgICAgd3JpdGUgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdEFycmF5OiBhbnlbXSA9IFtdO1xuICAgICAgICAgICAgdGV4dEJsb2NrQXJyYXkubWFwKCh0ZXh0QmxvY2s6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4dEJsb2NrID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRBcnJheTogYW55W10gPSB0ZXh0QmxvY2suc3BsaXQoLyVbXFxkXStcXCRzLyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4TG9vcCA9IE1hdGgubWluKHRleHRBcnJheS5sZW5ndGggLSAxLCBzdWJzdGl0dXRpb25zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCB3cml0ZSA9IDE7IGkgPCBtYXhMb29wOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb25zW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMuZ2V0TGl0ZXJhbChzdWJzdGl0dXRpb25zW2ldKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFycmF5LnNwbGljZSh3cml0ZSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2BzdWJzdGl0dXRpb24gc3Vic3RpdHV0aW9uLSR7aSArIDF9ICR7aWR9LSR7c3Vic3RpdHV0aW9uc1tpXX1gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWluZGV4PXtgJHtpfWB9Pnt0ZXh0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4sXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGUgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRBcnJheS5wdXNoKHRleHRBcnJheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0QXJyYXkucHVzaCh0ZXh0QmxvY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0QXJyYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaWMgZ2V0TGl0ZXJhbFdpdGhMYW5ndWFnZShpZDogc3RyaW5nLCBsYW5ndWFnZTogQXZhaWxhYmxlTGFuZ3VhZ2VzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy50ZXh0c1tsYW5ndWFnZV1baWRdO1xuICAgICAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTWlzc2luZyBsaXRlcmFsIGluICR7bGFuZ3VhZ2V9LCAke2lkfWApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBsaXRlcmFsIGluICR7bGFuZ3VhZ2V9LCAke2lkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLnRleHRzLkVOW2lkXTtcbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk1pc3NpbmcgbGl0ZXJhbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHB1YmxpYyB0ZXh0VG9NYXJrdXBXaXRoTGluZUJyZWFrcyh0ZXh0OiBzdHJpbmcsIHNlcGFyYXRvcjogc3RyaW5nID0gXCJcXFxcblwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQuc3BsaXQoc2VwYXJhdG9yKS5tYXAoKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxwIGtleT17a2V5fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtpdGVtfVxuICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgTG9jYWxpemVkID0gbmV3IExvY2FsaXplU2VydmljZSgpO1xuZXhwb3J0IGNvbnN0IExvY2FsaXplID0gbWVtb2l6ZWUoTG9jYWxpemVkLmdldExpdGVyYWwuYmluZChMb2NhbGl6ZWQpKTtcblxuKHdpbmRvdyBhcyBhbnkpLkxvY2FsaXplZCA9IExvY2FsaXplZDtcbih3aW5kb3cgYXMgYW55KS5Mb2NhbGl6ZSA9IExvY2FsaXplZC5nZXRMaXRlcmFsLmJpbmQoTG9jYWxpemVkKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NlcnZpY2VzL2xvY2FsaXplZF90ZXh0cy50c3giLCJleHBvcnQgKiBmcm9tICcuL3VpLmFjdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9uYXYuYWN0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3N5bmMuYWN0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3NvY2tldC5hY3Rpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vdXNlci5hY3Rpb25zJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FjdGlvbnMvaW5kZXgudHMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcIlZFUlNJT05fT1VUREFURURfVElUTEVcIjpcIlwiLFwiVkVSU0lPTl9PVVREQVRFRF9URVhUXCI6XCJcIixcIlZFUlNJT05fREVQUkVDQVRFRF9USVRMRVwiOlwiXCIsXCJWRVJTSU9OX0RFUFJFQ0FURURfVEVYVFwiOlwiXCIsXCJHT1RfSVRcIjpcIlwiLFwiTk9XX1RJVExFXCI6XCJcIixcIk5PV19TVUJUSVRMRVwiOlwiXCIsXCJVUENPTUlOR19USVRMRVwiOlwiXCIsXCJHUklEX05PX0RBVEFfVEVYVFwiOlwiXCIsXCJUUllfREVNT1wiOlwiXCIsXCJNRU5VX1NFVFRJTkdTXCI6XCJcIixcIk1FTlVfREVNT1wiOlwiREVNT1wiLFwiTUVOVV9QUk9GSUxFXCI6XCJQRVJGSUxcIixcIk1FTlVfQ0FSRFNcIjpcIk1JUyBDQVJEU1wiLFwiTUVOVV9TWU5DXCI6XCJESVZFIElOXCIsXCJTRUVfSU5GT1wiOlwiXCIsXCJUVkdSSURfQlJPQURDQVNUX1RJVExFMVwiOlwiQWhvcmEgZW4gVFZcIixcIlRWR1JJRF9CUk9BRENBU1RfVElUTEUyXCI6XCJUZXN0IGRlIHRyYWR1Y2Npw7NuXCIsXCJUVkdSSURfVVBDT01JTkdfVElUTEVcIjpcIlwiLFwiVFZHUklEX0JST0FEQ0FTVF9OT19DT05URU5UXCI6XCJcIixcIlRWR1JJRF9CUk9BRENBU1RfTk9fQ09OVEVOVF9UUllfREVNT1wiOlwiXCIsXCJUVkdSSURfVVBDT01JTkdfTk9fQ09OVEVOVFwiOlwiXCIsXCJUVkdSSURfVVBDT01JTkdfTk9fQ09OVEVOVF9UUllfREVNT1wiOlwiXCIsXCJHRU5FUklDX0VSUk9SX1RJVExFXCI6XCJcIixcIkdFTkVSSUNfRVJST1JfVEVYVFwiOlwiXCIsXCJFWElUX1RJVExFXCI6XCJcIixcIkVYSVRfVEVYVFwiOlwiXCIsXCJFWElUX0JVVFRPTl9PS1wiOlwiXCIsXCJORVRXT1JLX0VSUk9SX1RJVExFXCI6XCJcIixcIk5FVFdPUktfRVJST1JfVEVYVFwiOlwiXCIsXCJUVkdSSURfRU1QVFlfQlJPQURDQVNUX1RJVExFMVwiOlwiXCIsXCJUVkdSSURfRU1QVFlfQlJPQURDQVNUX1RJVExFMlwiOlwiXCIsXCJUVkdSSURfRU1QVFlfVVBDT01JTkdfVFhUMVwiOlwiXCIsXCJUVkdSSURfRU1QVFlfVVBDT01JTkdfVFhUMlwiOlwiXCIsXCJUVkdSSURfRU1QVFlfV0FUQ0hfT1VSX0RFTU9cIjpcIlwiLFwiU0VMRUNUT1JfQUxMX0NBVEVHT1JJRVNcIjpcIlwiLFwiU0VMRUNUT1JfQ0FTVF9DSEFSQUNURVJcIjpcIlwiLFwiU0VMRUNUT1JfRkFTSElPTl9CRUFVVFlcIjpcIlwiLFwiU0VMRUNUT1JfTVVTSUNcIjpcIlwiLFwiU0VMRUNUT1JfUExBQ0VTX1RSQVZFTFwiOlwiXCIsXCJTRUxFQ1RPUl9DQVJTX01PUkVcIjpcIlwiLFwiU0VMRUNUT1JfRlVOX0ZBQ1RTXCI6XCJcIixcIlNFTEVDVE9SX09USEVSX0NBVEVHT1JJRVNcIjpcIlwiLFwiQklPR1JBUEhZXCI6XCJCaW9ncmFmw61hXCIsXCJDT01FRFlcIjpcIkNvbWVkaWFcIixcIkNSSU1FXCI6XCJDcmltZW5cIixcIkFDVElPTlwiOlwiQWNjacOzblwiLFwiVEhSSUxMRVJcIjpcIlN1c3BlbnNlXCIsXCJBRFZFTlRVUkVcIjpcIkF2ZW50dXJhc1wiLFwiU0NJX0ZJXCI6XCJDaWVuY2lhIGZpY2Npw7NuXCIsXCJGQU5UQVNZXCI6XCJGYW50YXPDrWFcIixcIkRSQU1BXCI6XCJEcmFtYVwiLFwiUk9NQU5DRVwiOlwiUm9tw6FudGljYVwiLFwiVEVSUk9SXCI6XCJUZXJyb3JcIixcIkhJU1RPUllcIjpcIkhpc3TDs3JpY2FcIixcIldFU1RFUk5cIjpcIldlc3Rlcm5cIixcIldBUlwiOlwiQsOpbGljYXNcIixcIk1JU1RFUllcIjpcIk1pc3RlcmlvXCIsXCJGQU1JTFlcIjpcIkZhbWlsYXJcIixcIlNQT1JUXCI6XCJEZXBvcnRlXCIsXCJNVVNJQ1wiOlwiTcO6c2ljYVwiLFwiTVVTSUNBTFwiOlwiTXVzaWNhbFwiLFwiQU5JTUFUSU9OXCI6XCJBbmltYWNpw7NuXCIsXCJET0NVTUVOVEFSWVwiOlwiRG9jdW1lbnRhbFwiLFwiRklMTV9OT0lSXCI6XCJDaW5lIG5lZ3JvXCIsXCJORVdTXCI6XCJOb3RpY2lhc1wiLFwiS0lEU1wiOlwiSW5mYW50aWxcIixcIlRBTEtfU0hPV1wiOlwiRW50cmV2aXN0YXNcIixcIkNVUlJFTlRfU0NFTkVcIjpcIlwiLFwiUElaWkFfT1JfUE9QX0NPUk5cIjpcIlwiLFwiV0VfUkVDT01NRU5EXCI6XCJcIixcIk1BS0VfUE9QX0NPUk5cIjpcIlwiLFwiTElHSFRTX0NBTUVSQVwiOlwiXCIsXCJXRV9BUkVfTE9BRElOR1wiOlwiXCIsXCJFVkVSWVRISU5HX0VORFwiOlwiXCIsXCJNT1ZJRV9PRkZcIjpcIlwiLFwiTU9WSUVfRU5ERURcIjpcIlwiLFwiT0tBWVwiOlwiXCIsXCJDQVJPVVNFTF9DQVJEX1NBVkVcIjpcIlwiLFwiQ0FST1VTRUxfQ0FSRF9TQVZFRFwiOlwiXCIsXCJDQVJPVVNFTF9ORVdfQ0FSRF9BRERFRFwiOlwiXCIsXCJDQVJPVVNFTF9ORVdfQ0FSRFNfQURERURcIjpcIlwiLFwiVFZHUklEX0NPTU1FUkNJQUxfVFhUXCI6XCJcIixcIlRWR1JJRF9UT0RBWVwiOlwiXCIsXCJUVkdSSURfVE9NT1JST1dcIjpcIlwiLFwiRVhJVF9CVVRUT05fQ0FOQ0VMXCI6XCJcIixcIkVSUk9SX1NDQU5fQ0hBTk5FTFNfVElUTEVcIjpcIlwiLFwiRVJST1JfU0NBTl9DSEFOTkVMU19URVhUXCI6XCJcIixcIkVSUk9SX1NDQU5fQ0hBTk5FTFNfQlROX1NDQU5cIjpcIlwiLFwiU0NBTl9GSVJTVF9USU1FX1RJVExFXCI6XCJcIixcIlNDQU5fRklSU1RfVElNRV9URVhUXCI6XCJcIixcIlNDQU5fRklSU1RfVElNRV9CVE5cIjpcIlwiLFwiU0NBTl9IRUxQX1JFU0NBTl9USVRMRVwiOlwiXCIsXCJTQ0FOX0hFTFBfUkVTQ0FOX1RFWFRcIjpcIlwiLFwiU0NBTl9IRUxQX1JFU0NBTl9CVE5cIjpcIlwiLFwiU0NBTl9IRUxQX1RJVExFXzFcIjpcIlwiLFwiU0NBTl9IRUxQX1RJVExFXzJcIjpcIlwiLFwiU0NBTl9IRUxQX1NVR0dFU1RJT05cIjpcIlwiLFwiU0NBTl9IRUxQX1BMRUFTRV9DT05UQUNUXCI6XCJcIixcIlNDQU5fSEVMUF9FTUFJTFwiOlwiXCIsXCJTQ0FOX0hFTFBfU1VCSkVDVFwiOlwiXCIsXCJTQ0FOX0hFTFBfVkVSU0lPTlwiOlwiXCIsXCJSRUdJT05fU0VUX1RJVExFXCI6XCJcIixcIlJFR0lPTl9TRVRfVEVYVFwiOlwiXCIsXCJSRUdJT05fU0VUX1NQQUlOXCI6XCJcIixcIlJFR0lPTl9TRVRfR0VSTUFOWVwiOlwiXCIsXCJSRUdJT05fU0VUX1VTQVwiOlwiXCIsXCJUVkdSSURfQ0hBTkdFX0NIQU5ORUxfVElUTEVcIjpcIlwiLFwiVFZHUklEX0NIQU5HRV9DSEFOTkVMX1RFWFRcIjpcIlwiLFwiVFZHUklEX0NIQU5HRV9DSEFOTkVMX0JUTlwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19NT1ZJRVwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19TRVJJRVwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19QRVJTT05cIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfQ0hBUkFDVEVSXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX1ZFSElDTEVcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfRkFTSElPTlwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19MT0NBVElPTlwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19ISVNUT1JJQ1wiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19UUklWSUFcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfUVVPVEVcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfT1NUXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX0hPTUVcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfVEVDSE5PTE9HWVwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19BUlRcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfU09OR1wiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19MT09LXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX1RSQUlMRVJcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfV0VBUE9OXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX0xFSVNVUkVfU1BPUlRcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfSEVBTFRIX0JFQVVUWVwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19GT09EX0RSSU5LXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX0ZBVU5BX0ZMT1JBXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX0JVU0lORVNTXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX1JFRkVSRU5DRVwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19WSURFT0NMSVBcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfQ0hBUFRFUlwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19BQ1RJT05fRU1PVElPTlwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19TRUVfTU9SRVwiOlwiXCIsXCJTT1VSQ0VcIjpcIlwiLFwiU1BFQ1NcIjpcIlwiLFwiQkFTSUNfREFUQVwiOlwiXCIsXCJBV0FSRFNcIjpcIlwiLFwiV0lOTkVSX1NJTkdVTEFSXCI6XCJQcmVtaW9cIixcIldJTk5FUl9QTFVSQUxcIjpcIlByZW1pb3NcIixcIk5PTUlORUVfU0lOR1VMQVJcIjpcIk5vbWluYWNpw7NuXCIsXCJOT01JTkVFX1BMVVJBTFwiOlwiTm9taW5hY2lvbmVzXCIsXCJQT0NLRVRfVElUTEVfMVwiOlwiXCIsXCJQT0NLRVRfVElUTEVfMlwiOlwiXCIsXCJQT0NLRVRfTk9fQ0FSRFNfVElUTEVcIjpcIlwiLFwiUE9DS0VUX05PX0NBUkRTX1RYVFwiOlwiXCIsXCJHQUxMRVJZXCI6XCJHYWxlcsOtYVwiLFwiTE9DQVRJT05cIjpcIkxvY2FsaXphY2nDs25cIixcIkNVUklPU0lUWV9USVRMRVwiOlwiXCIsXCJPVkVSVklFV1wiOlwiXCJ9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvRVMvbG9jYWxpemVkX3RleHRzLmpzb25cbi8vIG1vZHVsZSBpZCA9IDYxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcIlZFUlNJT05fT1VUREFURURfVElUTEVcIjpcIldhcm5pbmdcIixcIlZFUlNJT05fT1VUREFURURfVEVYVFwiOlwiVGhlIHZlcnNpb24geW91J3ZlIGluc3RhbGxlZCBpcyBvdXRkYXRlZC5cXFxcbllvdSBuZWVkIHRvIHVwZ3JhZGUgbm93IHRvIHRoZSBsYXRlc3QgdmVyc2lvbiBpbiBvcmRlciB0byBjb250aW51ZSBlbmpveWluZyBEaXZlLlwiLFwiVkVSU0lPTl9ERVBSRUNBVEVEX1RJVExFXCI6XCJXYXJuaW5nXCIsXCJWRVJTSU9OX0RFUFJFQ0FURURfVEVYVFwiOlwiVGhlIHZlcnNpb24geW91J3ZlIGluc3RhbGxlZCBpcyBvdXRkYXRlZC5cXFxcbkEgbmV3IHZlcnNpb24gb2YgRGl2ZSBpcyBhdmFpbGFibGUgZm9yIHlvdS5cXFxcbllvdSBjYW4gdXBkYXRlIG9yIGNvbnRpbnVlIHdpdGggYW4gb2xkIHZlcnNpb24gb2YgRGl2ZS5cIixcIkdPVF9JVFwiOlwiR09UIElUXCIsXCJOT1dfVElUTEVcIjpcIk5PVyBPTiBUVlwiLFwiTk9XX1NVQlRJVExFXCI6XCJXaGF0IHdpbGwgeW91IGRpc2NvdmVyP1wiLFwiVVBDT01JTkdfVElUTEVcIjpcIlVQQ09NSU5HXCIsXCJHUklEX05PX0RBVEFfVEVYVFwiOlwiQXQgdGhlIG1vbWVudCwgdGhlcmUgaXMgbm90aGluZyBhdmFpbGFibGUgdG8gc3luYyB3aXRoIERpdmUuIEhhdmUgeW91IHRyaWVkIHRoZSBkZW1vP1wiLFwiVFJZX0RFTU9cIjpcIlRSWSBERU1PXCIsXCJNRU5VX1NFVFRJTkdTXCI6XCJTRVRUSU5HU1wiLFwiTUVOVV9ERU1PXCI6XCJERU1PXCIsXCJNRU5VX1BST0ZJTEVcIjpcIlBST0ZJTEVcIixcIk1FTlVfQ0FSRFNcIjpcIk1ZIENBUkRTXCIsXCJNRU5VX1NZTkNcIjpcIkRJVkUgSU5cIixcIlNFRV9JTkZPXCI6XCJTRUUgSU5GT1wiLFwiVFZHUklEX0JST0FEQ0FTVF9USVRMRTFcIjpcIk5vdyBvbiBUVlwiLFwiVFZHUklEX0JST0FEQ0FTVF9USVRMRTJcIjpcIldoYXQgd2lsbCB5b3UgZGlzY292ZXI/XCIsXCJUVkdSSURfVVBDT01JTkdfVElUTEVcIjpcIlVwY29taW5n4oCmXCIsXCJUVkdSSURfQlJPQURDQVNUX05PX0NPTlRFTlRcIjpcIkF0IHRoZSBtb21lbnQsIHRoZXJlIGlzIG5vdGhpbmcgYXZhaWxhYmxlIHRvIHN5bmMgd2l0aCBEaXZlLiBIYXZlIHlvdSB0cmllZCB0aGUgZGVtbz9cIixcIlRWR1JJRF9CUk9BRENBU1RfTk9fQ09OVEVOVF9UUllfREVNT1wiOlwiVHJ5IGRlbW9cIixcIlRWR1JJRF9VUENPTUlOR19OT19DT05URU5UXCI6XCJObyBjb250ZW50IGF2YWlsYWJsZSBvbiBvdXIgZ3VpZGUuIFRyeSBhZ2FpbiBsYXRlciBvciB0cnkgb3VyIGRlbW8uXCIsXCJUVkdSSURfVVBDT01JTkdfTk9fQ09OVEVOVF9UUllfREVNT1wiOlwiVHJ5IGRlbW9cIixcIkdFTkVSSUNfRVJST1JfVElUTEVcIjpcIsKhSE9VU1RPTiEgV0XigJlWRSBBIFBST0JMRU3igKZcIixcIkdFTkVSSUNfRVJST1JfVEVYVFwiOlwiV2VyZSBoYXZpbmcgc29tZSBpc3N1ZXMgd2l0aCB0aGUgYXBwLiBXZeKAmXJlIHdvcmtpbmcgb24gaXQgdG8gZml4IGl0LCBwbGVhc2UgdHJ5IGFnYWluIG9yIGNvbWUgYmFjayBhZ2FpbiBpbiBhIGZldyBtaW51dGVzLlwiLFwiRVhJVF9USVRMRVwiOlwiUExFQVNFLCBET07igJlUIEdPLlwiLFwiRVhJVF9URVhUXCI6XCJZb3VcXFxcJ3JlIGFib3V0IHRvIGxlYXZlIERpdmUuXFxcXG5BcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZXhpdD9cIixcIkVYSVRfQlVUVE9OX09LXCI6XCJZRVMsIEVYSVRcIixcIk5FVFdPUktfRVJST1JfVElUTEVcIjpcIklOVEVSTkVUIENPTk5FQ1RJT04gUkVRVUlSRURcIixcIk5FVFdPUktfRVJST1JfVEVYVFwiOlwiTm8gY29ubmVjdGlvbiBkZXRlY3RlZC4gXFxcXG5HbyB0byBzZXR0aW5ncyBhbmQgdmVyaWZ5IGlmIHlvdXIgSW50ZXJuZXQgaXMgd29ya2luZy5cIixcIlRWR1JJRF9FTVBUWV9CUk9BRENBU1RfVElUTEUxXCI6XCJUaGlzIGlzIGF3a3dhcmRcIixcIlRWR1JJRF9FTVBUWV9CUk9BRENBU1RfVElUTEUyXCI6XCJXaGF0IGNhbiBJIGRvP1wiLFwiVFZHUklEX0VNUFRZX1VQQ09NSU5HX1RYVDFcIjpcIlRoZXJlJ3Mgbm8gY29udGVudCByaWdodCBub3cuXFxcXG5DaGVjayBsYXRlciBvciBlbmpveSAlMSRzLlwiLFwiVFZHUklEX0VNUFRZX1VQQ09NSU5HX1RYVDJcIjpcIkRpdmUgb24geW91ciBwaG9uZVwiLFwiVFZHUklEX0VNUFRZX1dBVENIX09VUl9ERU1PXCI6XCJXYXRjaFxcXFxub3VyXFxcXG5kZW1vXCIsXCJTRUxFQ1RPUl9BTExfQ0FURUdPUklFU1wiOlwiQWxsIGNhdGVnb3JpZXNcIixcIlNFTEVDVE9SX0NBU1RfQ0hBUkFDVEVSXCI6XCJDYXN0ICYgQ2hhcmFjdGVyXCIsXCJTRUxFQ1RPUl9GQVNISU9OX0JFQVVUWVwiOlwiRmFzaGlvbiAmIEJlYXV0eVwiLFwiU0VMRUNUT1JfTVVTSUNcIjpcIk11c2ljXCIsXCJTRUxFQ1RPUl9QTEFDRVNfVFJBVkVMXCI6XCJQbGFjZXMgJiBUcmF2ZWxcIixcIlNFTEVDVE9SX0NBUlNfTU9SRVwiOlwiQ2FycyAmIE1vcmVcIixcIlNFTEVDVE9SX0ZVTl9GQUNUU1wiOlwiRnVuIGZhY3RzXCIsXCJTRUxFQ1RPUl9PVEhFUl9DQVRFR09SSUVTXCI6XCJDYXRlZ29yaWVzXCIsXCJCSU9HUkFQSFlcIjpcIkJpb2dyYXBoeVwiLFwiQ09NRURZXCI6XCJDb21lZHlcIixcIkNSSU1FXCI6XCJDcmltZVwiLFwiQUNUSU9OXCI6XCJBY3Rpb25cIixcIlRIUklMTEVSXCI6XCJUaHJpbGxlclwiLFwiQURWRU5UVVJFXCI6XCJBZHZlbnR1cmVcIixcIlNDSV9GSVwiOlwiU2NpLUZpXCIsXCJGQU5UQVNZXCI6XCJGYW50YXN5XCIsXCJEUkFNQVwiOlwiRHJhbWFcIixcIlJPTUFOQ0VcIjpcIlJvbWFuY2VcIixcIlRFUlJPUlwiOlwiSG9ycm9yXCIsXCJISVNUT1JZXCI6XCJIaXN0b3J5XCIsXCJXRVNURVJOXCI6XCJXZXN0ZXJuXCIsXCJXQVJcIjpcIldhclwiLFwiTUlTVEVSWVwiOlwiTXlzdGVyeVwiLFwiRkFNSUxZXCI6XCJGYW1pbHlcIixcIlNQT1JUXCI6XCJTcG9ydFwiLFwiTVVTSUNcIjpcIk11c2ljXCIsXCJNVVNJQ0FMXCI6XCJNdXNpY2FsXCIsXCJBTklNQVRJT05cIjpcIkFuaW1hdGlvblwiLFwiRE9DVU1FTlRBUllcIjpcIkRvY3VtZW50YXJ5XCIsXCJGSUxNX05PSVJcIjpcIkZpbG0tTm9pclwiLFwiTkVXU1wiOlwiTmV3c1wiLFwiS0lEU1wiOlwiS2lkc1wiLFwiVEFMS19TSE9XXCI6XCJUYWxrLVNob3dcIixcIkNVUlJFTlRfU0NFTkVcIjpcIkN1cnJlbnQgU2NlbmVcIixcIlBJWlpBX09SX1BPUF9DT1JOXCI6XCJQSVpaQSBPUiBQT1AgQ09STj9cIixcIldFX1JFQ09NTUVORFwiOlwiVGhlIHNob3cgeW914oCZcmUgd2F0Y2hpbmcgaXMgb24gYWR2ZXJ0aXNpbmcsIHdlIHJlY29tbWVuZDpcIixcIk1BS0VfUE9QX0NPUk5cIjpcIjEuIE1ha2UgbW9yZSBQb3AgQ29ybi5cXG4yLiBBbmQgYnJvd3NlIHRoZSBjb250ZW50IHdoaWxlIHdl4oCZcmUgb24gYSBicmVha1wiLFwiTElHSFRTX0NBTUVSQVwiOlwiTElHSFRTLCBDQU1FUkEgQU5EIEFDVElPTlwiLFwiV0VfQVJFX0xPQURJTkdcIjpcIldlJ3JlIGxvYWRpbmcgdGhlIGNvbnRlbnQgeW91J3JlIHdhdGNoaW5nIG9uIFRWLlwiLFwiRVZFUllUSElOR19FTkRcIjpcIkVWRVJZVEhJTkcgSEFTIEFOIEVORFwiLFwiTU9WSUVfT0ZGXCI6XCJUaGUgYnJvYWRjYXN0IGhhcyBiZWVuIGludGVycnVwdGVkLlwiLFwiTU9WSUVfRU5ERURcIjpcIlRoZSBtb3ZpZSBoYXMgZW5kZWRcIixcIk9LQVlcIjpcIk9LQVlcIixcIkNBUk9VU0VMX0NBUkRfU0FWRVwiOlwiU2F2ZSBmb3IgbGF0ZXJcIixcIkNBUk9VU0VMX0NBUkRfU0FWRURcIjpcIlNhdmVkXCIsXCJDQVJPVVNFTF9ORVdfQ0FSRF9BRERFRFwiOlwiMSBuZXcgY2FyZCBoYXMgYmVlbiBhZGRlZCFcIixcIkNBUk9VU0VMX05FV19DQVJEU19BRERFRFwiOlwiJTEkZCBuZXcgY2FyZHMgaGF2ZSBiZWVuIGFkZGVkIVwiLFwiVFZHUklEX0NPTU1FUkNJQUxfVFhUXCI6XCJFbmpveSBEaXZlIG9uIHlvdXIgcGhvbmVcIixcIlRWR1JJRF9UT0RBWVwiOlwiVG9kYXlcIixcIlRWR1JJRF9UT01PUlJPV1wiOlwiVG9tb3Jyb3dcIixcIkVYSVRfQlVUVE9OX0NBTkNFTFwiOlwiTk8sIEkgRE9OJ1QgV0FOVCBUT1wiLFwiRVJST1JfU0NBTl9DSEFOTkVMU19USVRMRVwiOlwiUkUtU0NBTiBUViBDSEFOTkVMU1wiLFwiRVJST1JfU0NBTl9DSEFOTkVMU19URVhUXCI6XCJUaGlzIGNoYW5uZWwgaXMgbm90IHNldCB5ZXQsIHBsZWFzZSByZS1zY2FuIHRvIGFkZCB0aGUgbmV3IGNoYW5uZWxzLlxcXFxuV2UgbmVlZCB0aGlzIHRvIHNldCB0aGUgVFYgc2lnbmFsLlwiLFwiRVJST1JfU0NBTl9DSEFOTkVMU19CVE5fU0NBTlwiOlwiT0ssIFNUQVJUIFNDQU5cIixcIlNDQU5fRklSU1RfVElNRV9USVRMRVwiOlwiTEVU4oCZUyBTRVQgVEhFIFRWIFNJR05BTFwiLFwiU0NBTl9GSVJTVF9USU1FX1RFWFRcIjpcIldlIG5lZWQgdG8gc2NhbiB0aGUgY2hhbm5lbHMgdG8gc2V0IHRoZSBUViBzaWduYWwuXFxcXG5Zb3XigJlsbCBiZSBhYmxlIHRvIHJlLXNjYW4gdGhlIGNoYW5uZWxzIGluIHlvdXIgbWVudSBpZiB5b3Ugd2FudCB0byBhZGQgbW9yZS5cIixcIlNDQU5fRklSU1RfVElNRV9CVE5cIjpcIk9LLCBTVEFSVCBTQ0FOXCIsXCJTQ0FOX0hFTFBfUkVTQ0FOX1RJVExFXCI6XCJSRS1TQ0FOIFRWIENIQU5ORUxTXCIsXCJTQ0FOX0hFTFBfUkVTQ0FOX1RFWFRcIjpcIlJlLXNjYW4gdG8gYWRkIG5ldyBjaGFubmVscy5cXFxcbldlIG5lZWQgdGhpcyB0byBzZXQgdGhlIFRWIHNpZ25hbC5cIixcIlNDQU5fSEVMUF9SRVNDQU5fQlROXCI6XCJPSywgU1RBUlQgU0NBTlwiLFwiU0NBTl9IRUxQX1RJVExFXzFcIjpcIlNFVFRJTkdTXCIsXCJTQ0FOX0hFTFBfVElUTEVfMlwiOlwiU2V0IHlvdXIgRGl2ZSBleHBlcmllbmNlXCIsXCJTQ0FOX0hFTFBfU1VHR0VTVElPTlwiOlwiU29tZXRoaW5nIHdyb25nPyBBbnkgc3VnZ2VzdGlvbnM/XCIsXCJTQ0FOX0hFTFBfUExFQVNFX0NPTlRBQ1RcIjpcIkZvciBjdXN0b21lciBzdXBwb3J0IHBsZWFzZSBjb250YWN0OlwiLFwiU0NBTl9IRUxQX0VNQUlMXCI6XCJzdXBwb3J0QGRpdmUudHZcIixcIlNDQU5fSEVMUF9TVUJKRUNUXCI6XCJXcml0ZSBUViBpbiB0aGUgc3ViamVjdCBsaW5lIGFuZCB3ZSB3aWxsIGNvbnRhY3QgeW91IGFzIHNvb24gYXMgcG9zc2libGUuXCIsXCJTQ0FOX0hFTFBfVkVSU0lPTlwiOlwiRElWRSB2JTEkc1wiLFwiUkVHSU9OX1NFVF9USVRMRVwiOlwiRklSU1QgVEhJTkdTLCBGSVJTVOKAplwiLFwiUkVHSU9OX1NFVF9URVhUXCI6XCJXZSBuZWVkIHRvIGtub3cgd2hlcmUgeW91IGFyZSB0byBzaG93IHlvdSB0aGUgVFYgY29udGVudHMgYXZhaWxhYmxlIHRvIHN5bmMgd2l0aC5cIixcIlJFR0lPTl9TRVRfU1BBSU5cIjpcIlNQQUlOXCIsXCJSRUdJT05fU0VUX0dFUk1BTllcIjpcIkdFUk1BTllcIixcIlJFR0lPTl9TRVRfVVNBXCI6XCJVU0FcIixcIlRWR1JJRF9DSEFOR0VfQ0hBTk5FTF9USVRMRVwiOlwiQ0hBTk5FTCBDSEFOR0VcIixcIlRWR1JJRF9DSEFOR0VfQ0hBTk5FTF9URVhUXCI6XCJQbGVhc2UgY29uZmlybSB0aGF0IHlvdVxcXFwndmUgY2hhbmdlZCB0aGUgY2hhbm5lbCBzbyB0aGF0IHdlIGNhbiBsb2FkIHRoZSBjb250ZW50IG9mICUxJHMuXCIsXCJUVkdSSURfQ0hBTkdFX0NIQU5ORUxfQlROXCI6XCJDT05GSVJNXCIsXCJDQVJPVVNFTF9BTElBU19NT1ZJRVwiOlwiTW92aWVcIixcIkNBUk9VU0VMX0FMSUFTX1NFUklFXCI6XCJTZXJpZVwiLFwiQ0FST1VTRUxfQUxJQVNfUEVSU09OXCI6XCJQZXJzb25cIixcIkNBUk9VU0VMX0FMSUFTX0NIQVJBQ1RFUlwiOlwiQ2hhcmFjdGVyXCIsXCJDQVJPVVNFTF9BTElBU19WRUhJQ0xFXCI6XCJWZWhpY2xlXCIsXCJDQVJPVVNFTF9BTElBU19GQVNISU9OXCI6XCJGYXNoaW9uXCIsXCJDQVJPVVNFTF9BTElBU19MT0NBVElPTlwiOlwiTG9jYXRpb25cIixcIkNBUk9VU0VMX0FMSUFTX0hJU1RPUklDXCI6XCJIaXN0b3JpY1wiLFwiQ0FST1VTRUxfQUxJQVNfVFJJVklBXCI6XCJUcml2aWFcIixcIkNBUk9VU0VMX0FMSUFTX1FVT1RFXCI6XCJRdW90ZVwiLFwiQ0FST1VTRUxfQUxJQVNfT1NUXCI6XCJPU1RcIixcIkNBUk9VU0VMX0FMSUFTX0hPTUVcIjpcIkhvbWVcIixcIkNBUk9VU0VMX0FMSUFTX1RFQ0hOT0xPR1lcIjpcIlRlY2hub2xvZ3lcIixcIkNBUk9VU0VMX0FMSUFTX0FSVFwiOlwiQXJ0XCIsXCJDQVJPVVNFTF9BTElBU19TT05HXCI6XCJTb25nXCIsXCJDQVJPVVNFTF9BTElBU19MT09LXCI6XCJMb29rXCIsXCJDQVJPVVNFTF9BTElBU19UUkFJTEVSXCI6XCJUcmFpbGVyXCIsXCJDQVJPVVNFTF9BTElBU19XRUFQT05cIjpcIldlYXBvblwiLFwiQ0FST1VTRUxfQUxJQVNfTEVJU1VSRV9TUE9SVFwiOlwiTGVpc3VyZSBTcG9ydFwiLFwiQ0FST1VTRUxfQUxJQVNfSEVBTFRIX0JFQVVUWVwiOlwiSGVhbHRoICYgQmVhdXR5XCIsXCJDQVJPVVNFTF9BTElBU19GT09EX0RSSU5LXCI6XCJGb29kICYgRHJpbmtcIixcIkNBUk9VU0VMX0FMSUFTX0ZBVU5BX0ZMT1JBXCI6XCJGYXVuYSAmIEZsb3JhXCIsXCJDQVJPVVNFTF9BTElBU19CVVNJTkVTU1wiOlwiQnVzaW5lc3NcIixcIkNBUk9VU0VMX0FMSUFTX1JFRkVSRU5DRVwiOlwiUmVmZXJlbmNlXCIsXCJDQVJPVVNFTF9BTElBU19WSURFT0NMSVBcIjpcIlZpZGVvY2xpcFwiLFwiQ0FST1VTRUxfQUxJQVNfQ0hBUFRFUlwiOlwiQ2hhcHRlclwiLFwiQ0FST1VTRUxfQUxJQVNfQUNUSU9OX0VNT1RJT05cIjpcIkFjdGlvbiAmIEVtb3Rpb25cIixcIkNBUk9VU0VMX0FMSUFTX1NFRV9NT1JFXCI6XCJFeHBsb3JlIE1vcmVcIixcIlNPVVJDRVwiOlwiU291cmNlXCIsXCJTUEVDU1wiOlwiU3BlY3NcIixcIkJBU0lDX0RBVEFcIjpcIkJhc2ljIERhdGFcIixcIkFXQVJEU1wiOlwiQXdhcmRzXCIsXCJXSU5ORVJfU0lOR1VMQVJcIjpcIlwiLFwiV0lOTkVSX1BMVVJBTFwiOlwiXCIsXCJOT01JTkVFX1NJTkdVTEFSXCI6XCJcIixcIk5PTUlORUVfUExVUkFMXCI6XCJcIixcIlBPQ0tFVF9USVRMRV8xXCI6XCJNWSBDQVJEU1wiLFwiUE9DS0VUX1RJVExFXzJcIjpcIlRoZSBjb250ZW50IHlvdVxcXFwndmUgbGlrZWRcIixcIlBPQ0tFVF9OT19DQVJEU19USVRMRVwiOlwiTk8gU0FWRUQgQ0FSRFMgWUVUXCIsXCJQT0NLRVRfTk9fQ0FSRFNfVFhUXCI6XCJTYXZlIGV2ZXJ5IGNhcmQgeW91IGxpa2UgYnkgcHJlc3Npbmcgb24gdGhlIGhlYXJ0IGljb24gb3IgYWN0aXZhdGUgeW91ciBhY2NvdW50IHRvIHNlZSB0aGUgY2FyZHMgc2F2ZWQgZnJvbSB5b3VyIERpdmUgbW9iaWxlIHZlcnNpb24uXCIsXCJHQUxMRVJZXCI6XCJHYWxsZXJ5XCIsXCJMT0NBVElPTlwiOlwiTG9jYXRpb25cIixcIkNVUklPU0lUWV9USVRMRVwiOlwiRGlkIHlvdSBrbm93Li4uP1wiLFwiT1ZFUlZJRVdcIjpcIlN5bm9wc2lzXCJ9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvRU4vbG9jYWxpemVkX3RleHRzLmpzb25cbi8vIG1vZHVsZSBpZCA9IDYxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcIlZFUlNJT05fT1VUREFURURfVElUTEVcIjpcIlwiLFwiVkVSU0lPTl9PVVREQVRFRF9URVhUXCI6XCJcIixcIlZFUlNJT05fREVQUkVDQVRFRF9USVRMRVwiOlwiXCIsXCJWRVJTSU9OX0RFUFJFQ0FURURfVEVYVFwiOlwiXCIsXCJHT1RfSVRcIjpcIlwiLFwiTk9XX1RJVExFXCI6XCJcIixcIk5PV19TVUJUSVRMRVwiOlwiXCIsXCJVUENPTUlOR19USVRMRVwiOlwiXCIsXCJHUklEX05PX0RBVEFfVEVYVFwiOlwiXCIsXCJUUllfREVNT1wiOlwiXCIsXCJNRU5VX1NFVFRJTkdTXCI6XCJcIixcIk1FTlVfREVNT1wiOlwiXCIsXCJNRU5VX1BST0ZJTEVcIjpcIlwiLFwiTUVOVV9DQVJEU1wiOlwiXCIsXCJNRU5VX1NZTkNcIjpcIlwiLFwiU0VFX0lORk9cIjpcIlwiLFwiVFZHUklEX0JST0FEQ0FTVF9USVRMRTFcIjpcIlwiLFwiVFZHUklEX0JST0FEQ0FTVF9USVRMRTJcIjpcIlwiLFwiVFZHUklEX1VQQ09NSU5HX1RJVExFXCI6XCJcIixcIlRWR1JJRF9CUk9BRENBU1RfTk9fQ09OVEVOVFwiOlwiXCIsXCJUVkdSSURfQlJPQURDQVNUX05PX0NPTlRFTlRfVFJZX0RFTU9cIjpcIlwiLFwiVFZHUklEX1VQQ09NSU5HX05PX0NPTlRFTlRcIjpcIlwiLFwiVFZHUklEX1VQQ09NSU5HX05PX0NPTlRFTlRfVFJZX0RFTU9cIjpcIlwiLFwiR0VORVJJQ19FUlJPUl9USVRMRVwiOlwiXCIsXCJHRU5FUklDX0VSUk9SX1RFWFRcIjpcIlwiLFwiRVhJVF9USVRMRVwiOlwiXCIsXCJFWElUX1RFWFRcIjpcIlwiLFwiRVhJVF9CVVRUT05fT0tcIjpcIlwiLFwiTkVUV09SS19FUlJPUl9USVRMRVwiOlwiXCIsXCJORVRXT1JLX0VSUk9SX1RFWFRcIjpcIlwiLFwiVFZHUklEX0VNUFRZX0JST0FEQ0FTVF9USVRMRTFcIjpcIlwiLFwiVFZHUklEX0VNUFRZX0JST0FEQ0FTVF9USVRMRTJcIjpcIlwiLFwiVFZHUklEX0VNUFRZX1VQQ09NSU5HX1RYVDFcIjpcIlwiLFwiVFZHUklEX0VNUFRZX1VQQ09NSU5HX1RYVDJcIjpcIlwiLFwiVFZHUklEX0VNUFRZX1dBVENIX09VUl9ERU1PXCI6XCJcIixcIlNFTEVDVE9SX0FMTF9DQVRFR09SSUVTXCI6XCJcIixcIlNFTEVDVE9SX0NBU1RfQ0hBUkFDVEVSXCI6XCJcIixcIlNFTEVDVE9SX0ZBU0hJT05fQkVBVVRZXCI6XCJcIixcIlNFTEVDVE9SX01VU0lDXCI6XCJcIixcIlNFTEVDVE9SX1BMQUNFU19UUkFWRUxcIjpcIlwiLFwiU0VMRUNUT1JfQ0FSU19NT1JFXCI6XCJcIixcIlNFTEVDVE9SX0ZVTl9GQUNUU1wiOlwiXCIsXCJTRUxFQ1RPUl9PVEhFUl9DQVRFR09SSUVTXCI6XCJcIixcIkJJT0dSQVBIWVwiOlwiQmlvZ3JhcGhpZVwiLFwiQ09NRURZXCI6XCJDb21lZHlcIixcIkNSSU1FXCI6XCJLcmltaVwiLFwiQUNUSU9OXCI6XCJBY3Rpb25cIixcIlRIUklMTEVSXCI6XCJUaHJpbGxlclwiLFwiQURWRU5UVVJFXCI6XCJBYmVudGV1ZXJcIixcIlNDSV9GSVwiOlwiU2NpLUZpXCIsXCJGQU5UQVNZXCI6XCJGYW50YXN5XCIsXCJEUkFNQVwiOlwiRHJhbWFcIixcIlJPTUFOQ0VcIjpcIlJvbWFuY2VcIixcIlRFUlJPUlwiOlwiSG9ycm9yXCIsXCJISVNUT1JZXCI6XCJHZXNjaGljaHRlXCIsXCJXRVNURVJOXCI6XCJXZXN0ZXJuXCIsXCJXQVJcIjpcIktyaWVnXCIsXCJNSVNURVJZXCI6XCJNeXN0ZXJ5XCIsXCJGQU1JTFlcIjpcIkZhbWlsaWVcIixcIlNQT1JUXCI6XCJTcG9ydFwiLFwiTVVTSUNcIjpcIk11c2lrXCIsXCJNVVNJQ0FMXCI6XCJNdXNpY2FsXCIsXCJBTklNQVRJT05cIjpcIkFuaW1hdGlvblwiLFwiRE9DVU1FTlRBUllcIjpcIkRva3VtZW50YXJcIixcIkZJTE1fTk9JUlwiOlwiRmlsbSBub2lyXCIsXCJORVdTXCI6XCJOZXdzXCIsXCJLSURTXCI6XCJLaW5kZXJcIixcIlRBTEtfU0hPV1wiOlwiVGFsa3Nob3dcIixcIkNVUlJFTlRfU0NFTkVcIjpcIlwiLFwiUElaWkFfT1JfUE9QX0NPUk5cIjpcIlwiLFwiV0VfUkVDT01NRU5EXCI6XCJcIixcIk1BS0VfUE9QX0NPUk5cIjpcIlwiLFwiTElHSFRTX0NBTUVSQVwiOlwiXCIsXCJXRV9BUkVfTE9BRElOR1wiOlwiXCIsXCJFVkVSWVRISU5HX0VORFwiOlwiXCIsXCJNT1ZJRV9PRkZcIjpcIlwiLFwiTU9WSUVfRU5ERURcIjpcIlwiLFwiT0tBWVwiOlwiXCIsXCJDQVJPVVNFTF9DQVJEX1NBVkVcIjpcIlwiLFwiQ0FST1VTRUxfQ0FSRF9TQVZFRFwiOlwiXCIsXCJDQVJPVVNFTF9ORVdfQ0FSRF9BRERFRFwiOlwiXCIsXCJDQVJPVVNFTF9ORVdfQ0FSRFNfQURERURcIjpcIlwiLFwiVFZHUklEX0NPTU1FUkNJQUxfVFhUXCI6XCJcIixcIlRWR1JJRF9UT0RBWVwiOlwiXCIsXCJUVkdSSURfVE9NT1JST1dcIjpcIlwiLFwiRVhJVF9CVVRUT05fQ0FOQ0VMXCI6XCJcIixcIkVSUk9SX1NDQU5fQ0hBTk5FTFNfVElUTEVcIjpcIlwiLFwiRVJST1JfU0NBTl9DSEFOTkVMU19URVhUXCI6XCJcIixcIkVSUk9SX1NDQU5fQ0hBTk5FTFNfQlROX1NDQU5cIjpcIlwiLFwiU0NBTl9GSVJTVF9USU1FX1RJVExFXCI6XCJcIixcIlNDQU5fRklSU1RfVElNRV9URVhUXCI6XCJcIixcIlNDQU5fRklSU1RfVElNRV9CVE5cIjpcIlwiLFwiU0NBTl9IRUxQX1JFU0NBTl9USVRMRVwiOlwiXCIsXCJTQ0FOX0hFTFBfUkVTQ0FOX1RFWFRcIjpcIlwiLFwiU0NBTl9IRUxQX1JFU0NBTl9CVE5cIjpcIlwiLFwiU0NBTl9IRUxQX1RJVExFXzFcIjpcIlwiLFwiU0NBTl9IRUxQX1RJVExFXzJcIjpcIlwiLFwiU0NBTl9IRUxQX1NVR0dFU1RJT05cIjpcIlwiLFwiU0NBTl9IRUxQX1BMRUFTRV9DT05UQUNUXCI6XCJcIixcIlNDQU5fSEVMUF9FTUFJTFwiOlwiXCIsXCJTQ0FOX0hFTFBfU1VCSkVDVFwiOlwiXCIsXCJTQ0FOX0hFTFBfVkVSU0lPTlwiOlwiXCIsXCJSRUdJT05fU0VUX1RJVExFXCI6XCJcIixcIlJFR0lPTl9TRVRfVEVYVFwiOlwiXCIsXCJSRUdJT05fU0VUX1NQQUlOXCI6XCJcIixcIlJFR0lPTl9TRVRfR0VSTUFOWVwiOlwiXCIsXCJSRUdJT05fU0VUX1VTQVwiOlwiXCIsXCJUVkdSSURfQ0hBTkdFX0NIQU5ORUxfVElUTEVcIjpcIlwiLFwiVFZHUklEX0NIQU5HRV9DSEFOTkVMX1RFWFRcIjpcIlwiLFwiVFZHUklEX0NIQU5HRV9DSEFOTkVMX0JUTlwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19NT1ZJRVwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19TRVJJRVwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19QRVJTT05cIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfQ0hBUkFDVEVSXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX1ZFSElDTEVcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfRkFTSElPTlwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19MT0NBVElPTlwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19ISVNUT1JJQ1wiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19UUklWSUFcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfUVVPVEVcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfT1NUXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX0hPTUVcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfVEVDSE5PTE9HWVwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19BUlRcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfU09OR1wiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19MT09LXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX1RSQUlMRVJcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfV0VBUE9OXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX0xFSVNVUkVfU1BPUlRcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfSEVBTFRIX0JFQVVUWVwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19GT09EX0RSSU5LXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX0ZBVU5BX0ZMT1JBXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX0JVU0lORVNTXCI6XCJcIixcIkNBUk9VU0VMX0FMSUFTX1JFRkVSRU5DRVwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19WSURFT0NMSVBcIjpcIlwiLFwiQ0FST1VTRUxfQUxJQVNfQ0hBUFRFUlwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19BQ1RJT05fRU1PVElPTlwiOlwiXCIsXCJDQVJPVVNFTF9BTElBU19TRUVfTU9SRVwiOlwiXCIsXCJTT1VSQ0VcIjpcIlwiLFwiU1BFQ1NcIjpcIlwiLFwiQkFTSUNfREFUQVwiOlwiXCIsXCJBV0FSRFNcIjpcIlwiLFwiV0lOTkVSX1NJTkdVTEFSXCI6XCJcIixcIldJTk5FUl9QTFVSQUxcIjpcIlwiLFwiTk9NSU5FRV9TSU5HVUxBUlwiOlwiXCIsXCJOT01JTkVFX1BMVVJBTFwiOlwiXCIsXCJQT0NLRVRfVElUTEVfMVwiOlwiXCIsXCJQT0NLRVRfVElUTEVfMlwiOlwiXCIsXCJQT0NLRVRfTk9fQ0FSRFNfVElUTEVcIjpcIlwiLFwiUE9DS0VUX05PX0NBUkRTX1RYVFwiOlwiXCIsXCJHQUxMRVJZXCI6XCJcIixcIkxPQ0FUSU9OXCI6XCJcIixcIkNVUklPU0lUWV9USVRMRVwiOlwiXCIsXCJPVkVSVklFV1wiOlwiXCJ9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvREUvbG9jYWxpemVkX3RleHRzLmpzb25cbi8vIG1vZHVsZSBpZCA9IDYxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IG5hdmlnYWJsZSwgSU5hdmlnYWJsZVByb3BzIH0gZnJvbSBcIkhPQ1wiO1xuXG5pbnRlcmZhY2UgSU5DQ093blByb3BzIHtcbiAgICBwcm9wYWdhdGVQYXJlbnQ/OiBib29sZWFuO1xufVxuXG50eXBlIE5DQ1Byb3BzID1cbiAgICBJTmF2aWdhYmxlUHJvcHMgJlxuICAgIFJlYWN0LkhUTUxQcm9wczxIVE1MRGl2RWxlbWVudD4gJlxuICAgIElOQ0NPd25Qcm9wc1xuICAgIDtcblxuY2xhc3MgTmF2aWdhdGlvbkNvbnRhaW5lckNsYXNzXG4gICAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8TkNDUHJvcHMsIHt9PiB7XG4gICAgcHVibGljIHN0YXRpYyBkZWZhdWx0UHJvcHM6IElOQ0NPd25Qcm9wcztcbiAgICBwdWJsaWMgcmVuZGVyKCkge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpuby11bnVzZWQtdmFyaWFibGVcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgICAgIGNvbnN0IHsgYWNjZXB0LCBhY2NlcHRDaGFyc2V0LCBhY3Rpb24sIGFsbG93RnVsbFNjcmVlbiwgYWxsb3dUcmFuc3BhcmVuY3ksIGFsdCwgYXN5bmMsIGF1dG9Db21wbGV0ZSwgYXV0b0ZvY3VzLCBhdXRvUGxheSwgY2FwdHVyZSwgY2VsbFBhZGRpbmcsIGNlbGxTcGFjaW5nLCBjaGFyU2V0LCBjaGFsbGVuZ2UsIGNoZWNrZWQsIGNpdGUsIGNsYXNzSUQsIGNvbHMsIGNvbFNwYW4sIGNvbnRlbnQsIGNvbnRyb2xzLCBjb29yZHMsIGNyb3NzT3JpZ2luLCBkYXRhLCBkYXRlVGltZSwgZGVmZXIsIGRpc2FibGVkLCBkb3dubG9hZCwgZW5jVHlwZSwgZm9ybSwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIGZvcm1NZXRob2QsIGZvcm1Ob1ZhbGlkYXRlLCBmb3JtVGFyZ2V0LCBmcmFtZUJvcmRlciwgaGVhZGVycywgaGVpZ2h0LCBoaWdoLCBocmVmLCBocmVmTGFuZywgaHRtbEZvciwgaHR0cEVxdWl2LCBpbnRlZ3JpdHksIGtleVBhcmFtcywga2V5VHlwZSwga2luZCwgbGFiZWwsIGxpc3QsIGxvb3AsIGxvdywgbWFuaWZlc3QsIG1hcmdpbkhlaWdodCwgbWFyZ2luV2lkdGgsIG1heCwgbWF4TGVuZ3RoLCBtZWRpYSwgbWVkaWFHcm91cCwgbWV0aG9kLCBtaW4sIG1pbkxlbmd0aCwgbXVsdGlwbGUsIG11dGVkLCBuYW1lLCBub25jZSwgbm9WYWxpZGF0ZSwgb3Blbiwgb3B0aW11bSwgcGF0dGVybiwgcGxhY2Vob2xkZXIsIHBsYXlzSW5saW5lLCBwb3N0ZXIsIHByZWxvYWQsIHJlYWRPbmx5LCByZWwsIHJlcXVpcmVkLCByZXZlcnNlZCwgcm93cywgcm93U3Bhbiwgc2FuZGJveCwgc2NvcGUsIHNjb3BlZCwgc2Nyb2xsaW5nLCBzZWFtbGVzcywgc2VsZWN0ZWQsIHNoYXBlLCBzaXplLCBzaXplcywgc3Bhbiwgc3JjLCBzcmNEb2MsIHNyY0xhbmcsIHNyY1NldCwgc3RhcnQsIHN0ZXAsIHN1bW1hcnksIHRhcmdldCwgdHlwZSwgdXNlTWFwLCB2YWx1ZSwgd2lkdGgsIHdtb2RlLCB3cmFwLCBkZWZhdWx0Q2hlY2tlZCwgZGVmYXVsdFZhbHVlLCBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcsIGFjY2Vzc0tleSwgY29udGVudEVkaXRhYmxlLCBjb250ZXh0TWVudSwgZGlyLCBkcmFnZ2FibGUsIGhpZGRlbiwgaWQsIGxhbmcsIHNwZWxsQ2hlY2ssIHN0eWxlLCB0YWJJbmRleCwgdGl0bGUsIGlucHV0TW9kZSwgaXMsIHJhZGlvR3JvdXAsIHJvbGUsIGFib3V0LCBkYXRhdHlwZSwgaW5saXN0LCBwcmVmaXgsIHByb3BlcnR5LCByZXNvdXJjZSwgdm9jYWIsIGF1dG9DYXBpdGFsaXplLCBhdXRvQ29ycmVjdCwgYXV0b1NhdmUsIGNvbG9yLCBpdGVtUHJvcCwgaXRlbVNjb3BlLCBpdGVtVHlwZSwgaXRlbUlELCBpdGVtUmVmLCByZXN1bHRzLCBzZWN1cml0eSwgdW5zZWxlY3RhYmxlLCBjaGlsZHJlbiwgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIG9uQ29weSwgb25Db3B5Q2FwdHVyZSwgb25DdXQsIG9uQ3V0Q2FwdHVyZSwgb25QYXN0ZSwgb25QYXN0ZUNhcHR1cmUsIG9uQ29tcG9zaXRpb25FbmQsIG9uQ29tcG9zaXRpb25FbmRDYXB0dXJlLCBvbkNvbXBvc2l0aW9uU3RhcnQsIG9uQ29tcG9zaXRpb25TdGFydENhcHR1cmUsIG9uQ29tcG9zaXRpb25VcGRhdGUsIG9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlLCBvbkZvY3VzLCBvbkZvY3VzQ2FwdHVyZSwgb25CbHVyLCBvbkJsdXJDYXB0dXJlLCBvbkNoYW5nZSwgb25DaGFuZ2VDYXB0dXJlLCBvbklucHV0LCBvbklucHV0Q2FwdHVyZSwgb25SZXNldCwgb25SZXNldENhcHR1cmUsIG9uU3VibWl0LCBvblN1Ym1pdENhcHR1cmUsIG9uSW52YWxpZCwgb25JbnZhbGlkQ2FwdHVyZSwgb25Mb2FkLCBvbkxvYWRDYXB0dXJlLCBvbkVycm9yLCBvbkVycm9yQ2FwdHVyZSwgb25LZXlEb3duLCBvbktleURvd25DYXB0dXJlLCBvbktleVByZXNzLCBvbktleVByZXNzQ2FwdHVyZSwgb25LZXlVcCwgb25LZXlVcENhcHR1cmUsIG9uQWJvcnQsIG9uQWJvcnRDYXB0dXJlLCBvbkNhblBsYXksIG9uQ2FuUGxheUNhcHR1cmUsIG9uQ2FuUGxheVRocm91Z2gsIG9uQ2FuUGxheVRocm91Z2hDYXB0dXJlLCBvbkR1cmF0aW9uQ2hhbmdlLCBvbkR1cmF0aW9uQ2hhbmdlQ2FwdHVyZSwgb25FbXB0aWVkLCBvbkVtcHRpZWRDYXB0dXJlLCBvbkVuY3J5cHRlZCwgb25FbmNyeXB0ZWRDYXB0dXJlLCBvbkVuZGVkLCBvbkVuZGVkQ2FwdHVyZSwgb25Mb2FkZWREYXRhLCBvbkxvYWRlZERhdGFDYXB0dXJlLCBvbkxvYWRlZE1ldGFkYXRhLCBvbkxvYWRlZE1ldGFkYXRhQ2FwdHVyZSwgb25Mb2FkU3RhcnQsIG9uTG9hZFN0YXJ0Q2FwdHVyZSwgb25QYXVzZSwgb25QYXVzZUNhcHR1cmUsIG9uUGxheSwgb25QbGF5Q2FwdHVyZSwgb25QbGF5aW5nLCBvblBsYXlpbmdDYXB0dXJlLCBvblByb2dyZXNzLCBvblByb2dyZXNzQ2FwdHVyZSwgb25SYXRlQ2hhbmdlLCBvblJhdGVDaGFuZ2VDYXB0dXJlLCBvblNlZWtlZCwgb25TZWVrZWRDYXB0dXJlLCBvblNlZWtpbmcsIG9uU2Vla2luZ0NhcHR1cmUsIG9uU3RhbGxlZCwgb25TdGFsbGVkQ2FwdHVyZSwgb25TdXNwZW5kLCBvblN1c3BlbmRDYXB0dXJlLCBvblRpbWVVcGRhdGUsIG9uVGltZVVwZGF0ZUNhcHR1cmUsIG9uVm9sdW1lQ2hhbmdlLCBvblZvbHVtZUNoYW5nZUNhcHR1cmUsIG9uV2FpdGluZywgb25XYWl0aW5nQ2FwdHVyZSwgb25DbGljaywgb25DbGlja0NhcHR1cmUsIG9uQ29udGV4dE1lbnUsIG9uQ29udGV4dE1lbnVDYXB0dXJlLCBvbkRvdWJsZUNsaWNrLCBvbkRvdWJsZUNsaWNrQ2FwdHVyZSwgb25EcmFnLCBvbkRyYWdDYXB0dXJlLCBvbkRyYWdFbmQsIG9uRHJhZ0VuZENhcHR1cmUsIG9uRHJhZ0VudGVyLCBvbkRyYWdFbnRlckNhcHR1cmUsIG9uRHJhZ0V4aXQsIG9uRHJhZ0V4aXRDYXB0dXJlLCBvbkRyYWdMZWF2ZSwgb25EcmFnTGVhdmVDYXB0dXJlLCBvbkRyYWdPdmVyLCBvbkRyYWdPdmVyQ2FwdHVyZSwgb25EcmFnU3RhcnQsIG9uRHJhZ1N0YXJ0Q2FwdHVyZSwgb25Ecm9wLCBvbkRyb3BDYXB0dXJlLCBvbk1vdXNlRG93biwgb25Nb3VzZURvd25DYXB0dXJlLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgb25Nb3VzZU1vdmUsIG9uTW91c2VNb3ZlQ2FwdHVyZSwgb25Nb3VzZU91dCwgb25Nb3VzZU91dENhcHR1cmUsIG9uTW91c2VPdmVyLCBvbk1vdXNlT3ZlckNhcHR1cmUsIG9uTW91c2VVcCwgb25Nb3VzZVVwQ2FwdHVyZSwgb25TZWxlY3QsIG9uU2VsZWN0Q2FwdHVyZSwgb25Ub3VjaENhbmNlbCwgb25Ub3VjaENhbmNlbENhcHR1cmUsIG9uVG91Y2hFbmQsIG9uVG91Y2hFbmRDYXB0dXJlLCBvblRvdWNoTW92ZSwgb25Ub3VjaE1vdmVDYXB0dXJlLCBvblRvdWNoU3RhcnQsIG9uVG91Y2hTdGFydENhcHR1cmUsIG9uU2Nyb2xsLCBvblNjcm9sbENhcHR1cmUsIG9uV2hlZWwsIG9uV2hlZWxDYXB0dXJlLCBvbkFuaW1hdGlvblN0YXJ0LCBvbkFuaW1hdGlvblN0YXJ0Q2FwdHVyZSwgb25BbmltYXRpb25FbmQsIG9uQW5pbWF0aW9uRW5kQ2FwdHVyZSwgb25BbmltYXRpb25JdGVyYXRpb24sIG9uQW5pbWF0aW9uSXRlcmF0aW9uQ2FwdHVyZSwgb25UcmFuc2l0aW9uRW5kLCBvblRyYW5zaXRpb25FbmRDYXB0dXJlLCBrZXksIC4uLmNoaWxkcmVuUHJvcHMgfSA9IHRoaXMucHJvcHMgYXMgYW55O1xuICAgICAgICBsZXQgeyBjbGFzc05hbWUgfSA9IHRoaXMucHJvcHMgYXMgYW55O1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHJpcGxlLWVxdWFsc1xuICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUgPyBgbmF2aWdhYmxlQ29udGFpbmVyICR7Y2xhc3NOYW1lfWAgOiBcIm5hdmlnYWJsZUNvbnRhaW5lclwiO1xuICAgICAgICBjbGFzc05hbWUgPSBgZmlsbFBhcmVudCAke2NsYXNzTmFtZX1gO1xuICAgICAgICBjb25zdCBkaXZQcm9wcyA9IHsgYWNjZXB0LCBhY2NlcHRDaGFyc2V0LCBhY3Rpb24sIGFsbG93RnVsbFNjcmVlbiwgYWxsb3dUcmFuc3BhcmVuY3ksIGFsdCwgYXN5bmMsIGF1dG9Db21wbGV0ZSwgYXV0b0ZvY3VzLCBhdXRvUGxheSwgY2FwdHVyZSwgY2VsbFBhZGRpbmcsIGNlbGxTcGFjaW5nLCBjaGFyU2V0LCBjaGFsbGVuZ2UsIGNoZWNrZWQsIGNpdGUsIGNsYXNzSUQsIGNvbHMsIGNvbFNwYW4sIGNvbnRlbnQsIGNvbnRyb2xzLCBjb29yZHMsIGNyb3NzT3JpZ2luLCBkYXRhLCBkYXRlVGltZSwgZGVmZXIsIGRpc2FibGVkLCBkb3dubG9hZCwgZW5jVHlwZSwgZm9ybSwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIGZvcm1NZXRob2QsIGZvcm1Ob1ZhbGlkYXRlLCBmb3JtVGFyZ2V0LCBmcmFtZUJvcmRlciwgaGVhZGVycywgaGVpZ2h0LCBoaWdoLCBocmVmLCBocmVmTGFuZywgaHRtbEZvciwgaHR0cEVxdWl2LCBpbnRlZ3JpdHksIGtleVBhcmFtcywga2V5VHlwZSwga2luZCwgbGFiZWwsIGxpc3QsIGxvb3AsIGxvdywgbWFuaWZlc3QsIG1hcmdpbkhlaWdodCwgbWFyZ2luV2lkdGgsIG1heCwgbWF4TGVuZ3RoLCBtZWRpYSwgbWVkaWFHcm91cCwgbWV0aG9kLCBtaW4sIG1pbkxlbmd0aCwgbXVsdGlwbGUsIG11dGVkLCBuYW1lLCBub25jZSwgbm9WYWxpZGF0ZSwgb3Blbiwgb3B0aW11bSwgcGF0dGVybiwgcGxhY2Vob2xkZXIsIHBsYXlzSW5saW5lLCBwb3N0ZXIsIHByZWxvYWQsIHJlYWRPbmx5LCByZWwsIHJlcXVpcmVkLCByZXZlcnNlZCwgcm93cywgcm93U3Bhbiwgc2FuZGJveCwgc2NvcGUsIHNjb3BlZCwgc2Nyb2xsaW5nLCBzZWFtbGVzcywgc2VsZWN0ZWQsIHNoYXBlLCBzaXplLCBzaXplcywgc3Bhbiwgc3JjLCBzcmNEb2MsIHNyY0xhbmcsIHNyY1NldCwgc3RhcnQsIHN0ZXAsIHN1bW1hcnksIHRhcmdldCwgdHlwZSwgdXNlTWFwLCB2YWx1ZSwgd2lkdGgsIHdtb2RlLCB3cmFwLCBkZWZhdWx0Q2hlY2tlZCwgZGVmYXVsdFZhbHVlLCBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcsIGFjY2Vzc0tleSwgY2xhc3NOYW1lLCBjb250ZW50RWRpdGFibGUsIGNvbnRleHRNZW51LCBkaXIsIGRyYWdnYWJsZSwgaGlkZGVuLCBpZCwgbGFuZywgc3BlbGxDaGVjaywgc3R5bGUsIHRhYkluZGV4LCB0aXRsZSwgaW5wdXRNb2RlLCBpcywgcmFkaW9Hcm91cCwgcm9sZSwgYWJvdXQsIGRhdGF0eXBlLCBpbmxpc3QsIHByZWZpeCwgcHJvcGVydHksIHJlc291cmNlLCB2b2NhYiwgYXV0b0NhcGl0YWxpemUsIGF1dG9Db3JyZWN0LCBhdXRvU2F2ZSwgY29sb3IsIGl0ZW1Qcm9wLCBpdGVtU2NvcGUsIGl0ZW1UeXBlLCBpdGVtSUQsIGl0ZW1SZWYsIHJlc3VsdHMsIHNlY3VyaXR5LCB1bnNlbGVjdGFibGUsIGNoaWxkcmVuLCBkYW5nZXJvdXNseVNldElubmVySFRNTCwgb25Db3B5LCBvbkNvcHlDYXB0dXJlLCBvbkN1dCwgb25DdXRDYXB0dXJlLCBvblBhc3RlLCBvblBhc3RlQ2FwdHVyZSwgb25Db21wb3NpdGlvbkVuZCwgb25Db21wb3NpdGlvbkVuZENhcHR1cmUsIG9uQ29tcG9zaXRpb25TdGFydCwgb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSwgb25Db21wb3NpdGlvblVwZGF0ZSwgb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUsIG9uRm9jdXMsIG9uRm9jdXNDYXB0dXJlLCBvbkJsdXIsIG9uQmx1ckNhcHR1cmUsIG9uQ2hhbmdlLCBvbkNoYW5nZUNhcHR1cmUsIG9uSW5wdXQsIG9uSW5wdXRDYXB0dXJlLCBvblJlc2V0LCBvblJlc2V0Q2FwdHVyZSwgb25TdWJtaXQsIG9uU3VibWl0Q2FwdHVyZSwgb25JbnZhbGlkLCBvbkludmFsaWRDYXB0dXJlLCBvbkxvYWQsIG9uTG9hZENhcHR1cmUsIG9uRXJyb3IsIG9uRXJyb3JDYXB0dXJlLCBvbktleURvd24sIG9uS2V5RG93bkNhcHR1cmUsIG9uS2V5UHJlc3MsIG9uS2V5UHJlc3NDYXB0dXJlLCBvbktleVVwLCBvbktleVVwQ2FwdHVyZSwgb25BYm9ydCwgb25BYm9ydENhcHR1cmUsIG9uQ2FuUGxheSwgb25DYW5QbGF5Q2FwdHVyZSwgb25DYW5QbGF5VGhyb3VnaCwgb25DYW5QbGF5VGhyb3VnaENhcHR1cmUsIG9uRHVyYXRpb25DaGFuZ2UsIG9uRHVyYXRpb25DaGFuZ2VDYXB0dXJlLCBvbkVtcHRpZWQsIG9uRW1wdGllZENhcHR1cmUsIG9uRW5jcnlwdGVkLCBvbkVuY3J5cHRlZENhcHR1cmUsIG9uRW5kZWQsIG9uRW5kZWRDYXB0dXJlLCBvbkxvYWRlZERhdGEsIG9uTG9hZGVkRGF0YUNhcHR1cmUsIG9uTG9hZGVkTWV0YWRhdGEsIG9uTG9hZGVkTWV0YWRhdGFDYXB0dXJlLCBvbkxvYWRTdGFydCwgb25Mb2FkU3RhcnRDYXB0dXJlLCBvblBhdXNlLCBvblBhdXNlQ2FwdHVyZSwgb25QbGF5LCBvblBsYXlDYXB0dXJlLCBvblBsYXlpbmcsIG9uUGxheWluZ0NhcHR1cmUsIG9uUHJvZ3Jlc3MsIG9uUHJvZ3Jlc3NDYXB0dXJlLCBvblJhdGVDaGFuZ2UsIG9uUmF0ZUNoYW5nZUNhcHR1cmUsIG9uU2Vla2VkLCBvblNlZWtlZENhcHR1cmUsIG9uU2Vla2luZywgb25TZWVraW5nQ2FwdHVyZSwgb25TdGFsbGVkLCBvblN0YWxsZWRDYXB0dXJlLCBvblN1c3BlbmQsIG9uU3VzcGVuZENhcHR1cmUsIG9uVGltZVVwZGF0ZSwgb25UaW1lVXBkYXRlQ2FwdHVyZSwgb25Wb2x1bWVDaGFuZ2UsIG9uVm9sdW1lQ2hhbmdlQ2FwdHVyZSwgb25XYWl0aW5nLCBvbldhaXRpbmdDYXB0dXJlLCBvbkNsaWNrLCBvbkNsaWNrQ2FwdHVyZSwgb25Db250ZXh0TWVudSwgb25Db250ZXh0TWVudUNhcHR1cmUsIG9uRG91YmxlQ2xpY2ssIG9uRG91YmxlQ2xpY2tDYXB0dXJlLCBvbkRyYWcsIG9uRHJhZ0NhcHR1cmUsIG9uRHJhZ0VuZCwgb25EcmFnRW5kQ2FwdHVyZSwgb25EcmFnRW50ZXIsIG9uRHJhZ0VudGVyQ2FwdHVyZSwgb25EcmFnRXhpdCwgb25EcmFnRXhpdENhcHR1cmUsIG9uRHJhZ0xlYXZlLCBvbkRyYWdMZWF2ZUNhcHR1cmUsIG9uRHJhZ092ZXIsIG9uRHJhZ092ZXJDYXB0dXJlLCBvbkRyYWdTdGFydCwgb25EcmFnU3RhcnRDYXB0dXJlLCBvbkRyb3AsIG9uRHJvcENhcHR1cmUsIG9uTW91c2VEb3duLCBvbk1vdXNlRG93bkNhcHR1cmUsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlLCBvbk1vdXNlTW92ZSwgb25Nb3VzZU1vdmVDYXB0dXJlLCBvbk1vdXNlT3V0LCBvbk1vdXNlT3V0Q2FwdHVyZSwgb25Nb3VzZU92ZXIsIG9uTW91c2VPdmVyQ2FwdHVyZSwgb25Nb3VzZVVwLCBvbk1vdXNlVXBDYXB0dXJlLCBvblNlbGVjdCwgb25TZWxlY3RDYXB0dXJlLCBvblRvdWNoQ2FuY2VsLCBvblRvdWNoQ2FuY2VsQ2FwdHVyZSwgb25Ub3VjaEVuZCwgb25Ub3VjaEVuZENhcHR1cmUsIG9uVG91Y2hNb3ZlLCBvblRvdWNoTW92ZUNhcHR1cmUsIG9uVG91Y2hTdGFydCwgb25Ub3VjaFN0YXJ0Q2FwdHVyZSwgb25TY3JvbGwsIG9uU2Nyb2xsQ2FwdHVyZSwgb25XaGVlbCwgb25XaGVlbENhcHR1cmUsIG9uQW5pbWF0aW9uU3RhcnQsIG9uQW5pbWF0aW9uU3RhcnRDYXB0dXJlLCBvbkFuaW1hdGlvbkVuZCwgb25BbmltYXRpb25FbmRDYXB0dXJlLCBvbkFuaW1hdGlvbkl0ZXJhdGlvbiwgb25BbmltYXRpb25JdGVyYXRpb25DYXB0dXJlLCBvblRyYW5zaXRpb25FbmQsIG9uVHJhbnNpdGlvbkVuZENhcHR1cmUsIGtleSB9O1xuICAgICAgICAvLyB0c2xpbnQ6ZW5hYmxlOm5vLXVudXNlZC12YXJpYWJsZVxuICAgICAgICAvLyB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aFxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiB7Li4uZGl2UHJvcHN9PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlbiA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY3Vyc2l2ZUNsb25lQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbikgOiBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuICAgIHByaXZhdGUgcmVjdXJzaXZlQ2xvbmVDaGlsZHJlbihjaGlsZHJlbjogYW55KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnByb3BhZ2F0ZVBhcmVudCA/IFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoaWxkOiBhbnksIGlkeDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y3VybHlcbiAgICAgICAgICAgIGlmICghY2hpbGQpIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIGxldCBjaGlsZFByb3BzOiBhbnkgPSB7IC4uLmNoaWxkLnByb3BzfTtcbiAgICAgICAgICAgIGxldCBmb3VuZE5hdiA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnRyaXBsZS1lcXVhbHNcbiAgICAgICAgICAgIGlmIChjaGlsZC5wcm9wcyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLnR5cGUgJiYgY2hpbGRQcm9wcy5wYXJlbnQpIHsgLy8gSXMgTmF2aWdhYmxlIVxuICAgICAgICAgICAgICAgIGNoaWxkUHJvcHMgPSB7IC4uLmNoaWxkUHJvcHMsIHBhcmVudDogdGhpcyB9O1xuICAgICAgICAgICAgICAgIGZvdW5kTmF2ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZE5hdikge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BzLmNoaWxkcmVuID0gdGhpcy5yZWN1cnNpdmVDbG9uZUNoaWxkcmVuKGNoaWxkLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7Li4uY2hpbGRQcm9wc30pO1xuICAgICAgICB9KSA6IGNoaWxkcmVuO1xuICAgIH1cbn1cblxuTmF2aWdhdGlvbkNvbnRhaW5lckNsYXNzLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBwcm9wYWdhdGVQYXJlbnQ6IGZhbHNlLFxufTtcblxuZXhwb3J0IGNvbnN0IE5hdmlnYXRpb25Db250YWluZXIgPSBuYXZpZ2FibGUoTmF2aWdhdGlvbkNvbnRhaW5lckNsYXNzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvbmF2aWdhdGlvbkNvbnRhaW5lci9uYXZpZ2F0aW9uQ29udGFpbmVyLmNvbXBvbmVudC50c3giLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tIFwicmVkdXhcIjtcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tIFwicmVhY3QtcmVkdXhcIjtcblxuaW1wb3J0IHsgTG9hZGluZywgTmF2aWdhdGlvbkNvbnRhaW5lciB9IGZyb20gJ0NvbXBvbmVudHMnO1xuaW1wb3J0IHsgSVVJQWN0aW9ucywgVUlBY3Rpb25zIH0gZnJvbSAnQWN0aW9ucyc7XG5pbXBvcnQgeyBuYXZpZ2FibGUsIElOYXZpZ2FibGVQcm9wcyB9IGZyb20gXCJIT0NcIjtcbmltcG9ydCB7IGNhcmRNb2R1bGVDb25maWcsIGNhcmRNb2R1bGVDbGFzc2VzLCBJVmFsaWRhdGFibGUsIGlzVmFsaWRhdGFibGUgfSBmcm9tICdDYXJkTW9kdWxlcyc7XG5pbXBvcnQgeyBOYXZpZ2FibGVDYXJkTW9kdWxlTGlzdCB9IGZyb20gXCJDb250YWluZXJzXCI7XG5pbXBvcnQgeyBDYXJkIH0gZnJvbSBcIlNlcnZpY2VzXCI7XG5cbmRlY2xhcmUgdHlwZSBEaXZlQVBJID0gYW55O1xuZXhwb3J0IHR5cGUgQ2FyZERldGFpbFN0YXR1cyA9IFwiTE9BRElOR1wiIHwgXCJET05FXCI7XG5leHBvcnQgdHlwZSBSZWxhdGlvblR5cGVzID0gXCJhbGxcIiB8IFwib2ZmbW92aWVcIiB8IFwibm9uZVwiO1xuZXhwb3J0IGludGVyZmFjZSBJQ2FyZERldGFpbE93blByb3BzIHtcbiAgICBjYXJkOiBDYXJkO1xuICAgIHJlbGF0aW9ucz86IFJlbGF0aW9uVHlwZXM7XG59XG5leHBvcnQgdHlwZSBDYXJkRGV0YWlsUHJvcHMgPSBJQ2FyZERldGFpbE93blByb3BzICYgeyB1aUFjdGlvbnM6IElVSUFjdGlvbnMgfTtcbmV4cG9ydCBpbnRlcmZhY2UgSUNhcmREZXRhaWxTdGF0ZSB7IHN0YXR1czogQ2FyZERldGFpbFN0YXR1czsgfVxuZXhwb3J0IGNvbnN0IGNhcmREZXRhaWxJbml0aWFsU3RhdGU6IElDYXJkRGV0YWlsU3RhdGUgPSB7XG4gICAgc3RhdHVzOiBcIkxPQURJTkdcIixcbn07XG5cbmV4cG9ydCBjbGFzcyBDYXJkRGV0YWlsQ2xhc3NcbiAgICBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8Q2FyZERldGFpbFByb3BzLCBJQ2FyZERldGFpbFN0YXRlPiB7XG4gICAgcHJpdmF0ZSBjYXJkTW9kdWxlczogSlNYLkVsZW1lbnRbXSA9IFtdO1xuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBDYXJkRGV0YWlsUHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0gY2FyZERldGFpbEluaXRpYWxTdGF0ZTtcbiAgICB9XG4gICAgcHVibGljIHJlbmRlcigpOiBhbnkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkRGV0YWlsIGZpbGxQYXJlbnRcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJvdHRvbUNvbnRhaW5lclRvcEJ1dHRvbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkRGV0YWlsQnRuXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TmF2aWdhdGlvbkNvbnRhaW5lciBrZXk9XCJjYXJvdXNlbENsb3NlXCIgY2xhc3NOYW1lPVwiYmN0QnV0dG9uIGNsb3NlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ9e3RoaXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2tBY3Rpb249eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvKnRoaXMuY2xvc2VBbGxDYXJkcy5iaW5kKHRoaXMpKi99XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17MX1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvTmF2aWdhdGlvbkNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2FyZCA/XG4gICAgICAgICAgICAgICAgICAgIDxOYXZpZ2FibGVDYXJkTW9kdWxlTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEZWZhdWx0PXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50PXt0aGlzfSBjb2x1bW5zPXsxfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZD17dGhpcy5wcm9wcy5jYXJkfSBcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlRmlyc3Q9e3RydWV9Lz5cbiAgICAgICAgICAgICAgICAgICAgOiA8TG9hZGluZyAvPn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBjbG9zZUFsbENhcmRzKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNMT1NFIEFMTCBDQVJEU1wiKTtcbiAgICAgICAgLy8gVE9ETzogbG9naWMgdG8gY2xvc2UgYWxsIGNhcmRzXG4gICAgICAgIHRoaXMucHJvcHMudWlBY3Rpb25zLm9wZW5TeW5jKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY2FyZCAmJiB0aGlzLnN0YXRlLnN0YXR1cyAhPT0gXCJET05FXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyAuLi50aGlzLnN0YXRlLCBzdGF0dXM6IFwiRE9ORVwiIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRUb0FycmF5SWZFeGlzdHModGFyZ2V0QXJyYXk6IEFycmF5PFJlYWN0LkNvbXBvbmVudDxhbnksIGFueT4+LCBjYW5kaWRhdGU6IGFueSkge1xuICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICB0YXJnZXRBcnJheS5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IChkaXNwYXRjaDogYW55KTogYW55ID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB1aUFjdGlvbnM6IGJpbmRBY3Rpb25DcmVhdG9ycyhVSUFjdGlvbnMsIGRpc3BhdGNoKSxcbiAgICB9O1xufTtcblxuY29uc3QgbWVyZ2VQcm9wcyA9IChzdGF0ZVByb3BzOiBhbnksIGRpc3BhdGNoUHJvcHM6IGFueSwgb3duUHJvcHM6IGFueSkgPT4ge1xuICAgIHJldHVybiB7IC4uLnN0YXRlUHJvcHMsIC4uLm93blByb3BzLCAuLi5kaXNwYXRjaFByb3BzIH07XG59O1xuXG5leHBvcnQgY29uc3QgQ2FyZERldGFpbCA9IG5hdmlnYWJsZShjb25uZWN0KFxuICAgIHVuZGVmaW5lZCxcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgbWVyZ2VQcm9wcyxcbikoQ2FyZERldGFpbENsYXNzKSkgYXMgUmVhY3QuQ29tcG9uZW50Q2xhc3M8SU5hdmlnYWJsZVByb3BzICYgSUNhcmREZXRhaWxPd25Qcm9wcz47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2NhcmREZXRhaWwvY2FyZERldGFpbC5jb21wb25lbnQudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2FyZCwgTG9jYWxpemUgfSBmcm9tIFwiU2VydmljZXNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJQ2FyZEFuZENhdGVnb3J5UHJvcHMge1xuICAgIGNhcmQ6IENhcmQgfCBudWxsO1xufVxuZXhwb3J0IGNsYXNzIENhcmRBbmRDYXRlZ29yeSBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8SUNhcmRBbmRDYXRlZ29yeVByb3BzLCB7fT4ge1xuICAgIHB1YmxpYyBzdGF0aWMgZGVmYXVsdFByb3BzOiBJQ2FyZEFuZENhdGVnb3J5UHJvcHMgPSB7XG4gICAgICAgIGNhcmQ6IG51bGwsXG4gICAgfTtcblxuICAgIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGNhcmQgPSB0aGlzLnByb3BzLmNhcmQ7XG4gICAgICAgIGlmIChjYXJkKSB7XG4gICAgICAgICAgICBsZXQgc2hvd0ltYWdlOiBib29sZWFuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FyZC5pbWFnZSAmJiBjYXJkLmltYWdlLnRodW1iKSB7XG4gICAgICAgICAgICAgICAgc2hvd0ltYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaG93SWNvbjogYm9vbGVhbiA9ICFzaG93SW1hZ2U7XG4gICAgICAgICAgICBsZXQgc2hvd1RpdGxlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc2hvd1N1YnRpdGxlID0gZmFsc2U7XG4gICAgICAgICAgICBzd2l0Y2ggKGNhcmQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ29zdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc29uZyc6XG4gICAgICAgICAgICAgICAgICAgIHNob3dJbWFnZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzaG93SWNvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNob3dUaXRsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNob3dTdWJ0aXRsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3F1b3RlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdyZWZlcmVuY2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RyaXZpYSc6XG4gICAgICAgICAgICAgICAgICAgIHNob3dJbWFnZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzaG93SWNvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzaG93VGl0bGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gTG9jYWxpemUoYENBUk9VU0VMX0FMSUFTXyR7Y2FyZC50eXBlLnRvVXBwZXJDYXNlKCl9YCkgfHwgY2FyZC50eXBlO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRBbmRDYXRlZ29yeVwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YGltYWdlICR7Y2FyZC50eXBlfWB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17c2hvd0ltYWdlID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke2NhcmQhLmltYWdlIS50aHVtYn0pYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7Y2FyZCEuaW1hZ2UhLmFuY2hvcl94fSUgJHtjYXJkIS5pbWFnZSEuYW5jaG9yX3l9JWAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogdW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICB7c2hvd0ljb24gPyA8ZGl2IGNsYXNzTmFtZT1cImljb25cIj48L2Rpdj4gOiBudWxsfVxuICAgICAgICAgICAgICAgICAgICAgICAge3Nob3dUaXRsZSA/IDxkaXYgY2xhc3NOYW1lPVwidGl0bGVcIj57Y2FyZC50aXRsZX08L2Rpdj4gOiBudWxsfVxuICAgICAgICAgICAgICAgICAgICAgICAge3Nob3dTdWJ0aXRsZSAmJiAhc2hvd0ljb24gPyA8ZGl2IGNsYXNzTmFtZT1cInN1YnRpdGxlXCI+e2NhcmQuc3VidGl0bGV9PC9kaXY+IDogbnVsbH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2F0ZWdvcnlcIj57Y2F0ZWdvcnl9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY2FyZEFuZENhdGVnb3J5L2NhcmRBbmRDYXRlZ29yeS5jb21wb25lbnQudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuaW1wb3J0IHsgQ2FyZCwgQ2FyZENvbnRhaW5lclR5cGVFbnVtLCBIZWxwZXIsIFNvdXJjZURhdGEgYXMgU291cmNlRGF0YVZPLCBMb2NhbGl6ZSB9IGZyb20gXCJTZXJ2aWNlc1wiO1xuaW1wb3J0IHsgSUNhcmRNb2R1bGVQcm9wcyB9IGZyb20gXCJDYXJkTW9kdWxlc1wiO1xuaW1wb3J0IHsgRGlyZWN0aW9uQnV0dG9uLCBEaXJlY3Rpb25CdXR0b25MaXN0IH0gZnJvbSBcIkNvbXBvbmVudHNcIjtcbmltcG9ydCB7IG5hdmlnYWJsZSB9IGZyb20gXCJIT0NcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJVmVydGljYWxTY3JvbGxQcm9wcyB7XG4gICAgc291cmNlPzogU291cmNlRGF0YVZPIHwgdW5kZWZpbmVkO1xufVxuZXhwb3J0IGNsYXNzIFZlcnRpY2FsU2Nyb2xsQ2xhc3MgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PElWZXJ0aWNhbFNjcm9sbFByb3BzLCB7fT4ge1xuXG4gICAgcHJpdmF0ZSBzY3JvbGxCb3g6IEhUTUxFbGVtZW50O1xuXG4gICAgcHVibGljIHJlbmRlcigpOiBhbnkge1xuICAgICAgICBjb25zdCBmdWxsOiBib29sZWFuID0gdGhpcy5wcm9wcy5zb3VyY2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5wcm9wcy5zb3VyY2UubmFtZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLnByb3BzLnNvdXJjZS5uYW1lICE9PSAnJztcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICAgICAgZnVsbCxcbiAgICAgICAgICAgIHNjcm9sbEJveDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucHJvcHMuc291cmNlICYmIHRoaXMucHJvcHMuc291cmNlLm5hbWUgP1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5zb3VyY2UubmFtZSA6IHRoaXMucHJvcHMuc291cmNlICYmIHRoaXMucHJvcHMuc291cmNlLnVybCA/XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zb3VyY2UudXJsIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidmVydGljYWxTY3JvbGxcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNjcm9sbEJveFwiIHJlZj17KGVsKSA9PiB7IGlmIChlbCkgeyB0aGlzLnNjcm9sbEJveCA9IGVsOyB9IH19PlxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5jaGlsZHJlbn1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICB7c291cmNlID9cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzb3VyY2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJsYWJlbFwiPntMb2NhbGl6ZSgnU09VUkNFJyl9OiA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cInRleHRcIj57c291cmNlfTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA6IG51bGx9XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ0bnNcIj5cbiAgICAgICAgICAgICAgICAgICAgPERpcmVjdGlvbkJ1dHRvbkxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudD17dGhpc31cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlPVwiaG9yaXpvbnRhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBidG5zPXtbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBkaXJlY3Rpb246ICd1cCcsIGFjdGlvbjogdGhpcy51cEFjdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZGlyZWN0aW9uOiAnZG93bicsIGFjdGlvbjogdGhpcy5kb3duQWN0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGRvd25BY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQm94LnNjcm9sbFRvcCArPSB0aGlzLnNjcm9sbEJveC5vZmZzZXRIZWlnaHQ7XG4gICAgfVxuXG4gICAgcHVibGljIHVwQWN0aW9uID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNjcm9sbEJveC5zY3JvbGxUb3AgLT0gdGhpcy5zY3JvbGxCb3gub2Zmc2V0SGVpZ2h0O1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFZlcnRpY2FsU2Nyb2xsID0gbmF2aWdhYmxlKFZlcnRpY2FsU2Nyb2xsQ2xhc3MpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy92ZXJ0aWNhbFNjcm9sbC92ZXJ0aWNhbFNjcm9sbC5jb21wb25lbnQudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuaW1wb3J0IHsgQ2FyZCwgQ2FyZENvbnRhaW5lclR5cGVFbnVtLCBIZWxwZXIsIFNvdXJjZURhdGEgYXMgU291cmNlRGF0YVZPLCBMb2NhbGl6ZSB9IGZyb20gXCJTZXJ2aWNlc1wiO1xuaW1wb3J0IHsgSUNhcmRNb2R1bGVQcm9wcyB9IGZyb20gXCJDYXJkTW9kdWxlc1wiO1xuaW1wb3J0IHsgRGlyZWN0aW9uQnV0dG9uLCBOYXZpZ2F0aW9uQ29udGFpbmVyLCBEaXJlY3Rpb25CdXR0b25MaXN0IH0gZnJvbSBcIkNvbXBvbmVudHNcIjtcbmltcG9ydCB7IG5hdmlnYWJsZSB9IGZyb20gXCJIT0NcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJSG9yaXpvbnRhbFNjcm9sbFByb3BzIHtcbiAgICB1bmlxdWVJZDogc3RyaW5nO1xuICAgIGl0ZW1zU2hvd246IG51bWJlcjtcbn1cbmV4cG9ydCBjbGFzcyBIb3Jpem9udGFsU2Nyb2xsQ2xhc3MgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PElIb3Jpem9udGFsU2Nyb2xsUHJvcHMsIHt9PiB7XG5cbiAgICBwcml2YXRlIHNjcm9sbEJveDogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBvZmZzZXQ6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBidG5zOiBIVE1MRWxlbWVudDtcblxuICAgIHB1YmxpYyByZW5kZXIoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaG9yaXpvbnRhbFNjcm9sbFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2Nyb2xsQm94XCIgcmVmPXsoZWwpID0+IHsgaWYgKGVsKSB7IHRoaXMuc2Nyb2xsQm94ID0gZWw7IH0gfX0+XG4gICAgICAgICAgICAgICAgICAgIDxOYXZpZ2F0aW9uQ29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ9e3RoaXN9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGVQYXJlbnQ9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJzY3JvbGxCb3hDb250ZW50XCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc2hvd0VsZW1lbnRzKCl9XG4gICAgICAgICAgICAgICAgICAgIDwvTmF2aWdhdGlvbkNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnRuc1wiPlxuICAgICAgICAgICAgICAgICAgICA8RGlyZWN0aW9uQnV0dG9uTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50PXt0aGlzfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU9XCJ2ZXJ0aWNhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBidG5zPXtbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBkaXJlY3Rpb246ICdyaWdodCcsIGFjdGlvbjogdGhpcy5yaWdodEFjdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZGlyZWN0aW9uOiAnbGVmdCcsIGFjdGlvbjogdGhpcy5sZWZ0QWN0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2hvd0VsZW1lbnRzID0gKCkgPT4ge1xuICAgICAgICBsZXQgZWxlbWVudHM6IGFueSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jaGlsZHJlbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vZmZzZXQ7IGkgPCAodGhpcy5wcm9wcy5pdGVtc1Nob3duICsgdGhpcy5vZmZzZXQpICYmIChpIDwgdGhpcy5wcm9wcy5jaGlsZHJlbi5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMucHJvcHMuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG5cbiAgICBwdWJsaWMgbGVmdEFjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5vZmZzZXQgLT0gdGhpcy5wcm9wcy5pdGVtc1Nob3duO1xuICAgICAgICBpZiAodGhpcy5vZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyByaWdodEFjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gdGhpcy5wcm9wcy5pdGVtc1Nob3duO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jaGlsZHJlbiBpbnN0YW5jZW9mIEFycmF5ICYmICh0aGlzLm9mZnNldCArIHRoaXMucHJvcHMuaXRlbXNTaG93biA+PSB0aGlzLnByb3BzLmNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5wcm9wcy5jaGlsZHJlbi5sZW5ndGggLSB0aGlzLnByb3BzLml0ZW1zU2hvd24gO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBIb3Jpem9udGFsU2Nyb2xsID0gbmF2aWdhYmxlKEhvcml6b250YWxTY3JvbGxDbGFzcyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL2hvcml6b250YWxTY3JvbGwvaG9yaXpvbnRhbFNjcm9sbC5jb21wb25lbnQudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcblxuaW1wb3J0IHsgbmF2aWdhYmxlIH0gZnJvbSBcIkhPQ1wiO1xuaW1wb3J0IHsgRGlyZWN0aW9uQnV0dG9uIH0gZnJvbSBcIkNvbXBvbmVudHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJRGlyZWN0aW9uQnV0dG9uTGlzdE9iaiB7XG4gICAgZGlyZWN0aW9uOiAnbGVmdCcgfCAncmlnaHQnIHwgJ3VwJyB8ICdkb3duJztcbiAgICBhY3Rpb24/OiAoKSA9PiB2b2lkO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRGlyZWN0aW9uQnV0dG9uTGlzdFByb3BzIHtcbiAgICBidG5zOiBJRGlyZWN0aW9uQnV0dG9uTGlzdE9ialtdO1xuICAgIHRlbXBsYXRlPzogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJztcbn1cbmV4cG9ydCBjbGFzcyBEaXJlY3Rpb25CdXR0b25MaXN0Q2xhc3MgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PElEaXJlY3Rpb25CdXR0b25MaXN0UHJvcHMsIHt9PiB7XG5cbiAgICBwdWJsaWMgcmVuZGVyKCk6IGFueSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8dWwgY2xhc3NOYW1lPXsnZGlyZWN0aW9uQnV0dG9uTGlzdCAnICsgdGhpcy5wcm9wcy50ZW1wbGF0ZX0+XG4gICAgICAgICAgICAgICAge3RoaXMucHJvcHMuYnRucy5tYXAoKGJ0bjogSURpcmVjdGlvbkJ1dHRvbkxpc3RPYmosIGk6IG51bWJlcikgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwiYnRuXCIga2V5PXtpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxEaXJlY3Rpb25CdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb249e2J0bi5kaXJlY3Rpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2tBY3Rpb249e2J0bi5hY3Rpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50PXt0aGlzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM9e3RoaXMucHJvcHMudGVtcGxhdGUgIT09ICd2ZXJ0aWNhbCcgPyB0aGlzLnByb3BzLmJ0bnMubGVuZ3RoIDogMX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICApO1xuICAgIH1cblxufVxuXG5leHBvcnQgY29uc3QgRGlyZWN0aW9uQnV0dG9uTGlzdCA9IG5hdmlnYWJsZShEaXJlY3Rpb25CdXR0b25MaXN0Q2xhc3MpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9kaXJlY3Rpb25CdXR0b25MaXN0L2RpcmVjdGlvbkJ1dHRvbkxpc3QuY29tcG9uZW50LnRzeCIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmltcG9ydCB7IG5hdmlnYWJsZSB9IGZyb20gXCJIT0NcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJRGlyZWN0aW9uQnV0dG9uUHJvcHMge1xuICAgIGRpcmVjdGlvbjogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICd1cCcgfCAnZG93bic7XG59XG5leHBvcnQgY2xhc3MgRGlyZWN0aW9uQnV0dG9uQ2xhc3MgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PElEaXJlY3Rpb25CdXR0b25Qcm9wcywge30+IHtcblxuICAgIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWVzKCdkaXJlY3Rpb25CdXR0b24nLCB0aGlzLnByb3BzLmRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30+PC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuICAgIFxufVxuXG5leHBvcnQgY29uc3QgRGlyZWN0aW9uQnV0dG9uID0gbmF2aWdhYmxlKERpcmVjdGlvbkJ1dHRvbkNsYXNzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvZGlyZWN0aW9uQnV0dG9uTGlzdC9kaXJlY3Rpb25CdXR0b24vZGlyZWN0aW9uQnV0dG9uLmNvbXBvbmVudC50c3giLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5pbXBvcnQgeyBuYXZpZ2FibGUgfSBmcm9tICdIT0MnO1xuaW1wb3J0IHsgTG9jYWxpemUgfSBmcm9tICdTZXJ2aWNlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU1pbmlDYXJkQnV0dG9uU3RhdGUge1xuICAgIHR5cGU6ICdNT1JFJyB8ICdTQVZFJztcbiAgICBsaWtlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU1pbmlDYXJkQnV0dG9uTWV0aG9kcyB7XG4gICAgY2xpY2tBY3Rpb246IGFueTtcbn1cblxudHlwZSBNaW5pQ2FyZEJ1dHRvblByb3BzID0gSU1pbmlDYXJkQnV0dG9uU3RhdGUgJiBJTWluaUNhcmRCdXR0b25NZXRob2RzO1xuXG5leHBvcnQgY2xhc3MgTWluaUNhcmRCdXR0b25DbGFzcyBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8TWluaUNhcmRCdXR0b25Qcm9wcywge30+IHtcblxuICAgIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdNT1JFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJtaW5pQ2FyZEJ1dHRvbiBmaWxsUGFyZW50IG1vcmVcIiBvbkNsaWNrPXt0aGlzLnByb3BzLmNsaWNrQWN0aW9ufT4rPC9kaXY+O1xuICAgICAgICAgICAgY2FzZSAnU0FWRSc6XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3Nlc0FwcGxpZWQgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGlrZTogdGhpcy5wcm9wcy5saWtlZCA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGlrZWQ6IHRoaXMucHJvcHMubGlrZWQgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwibWluaUNhcmRCdXR0b24gZmlsbFBhcmVudFwiIG9uQ2xpY2s9e3RoaXMucHJvcHMuY2xpY2tBY3Rpb259PlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2NsYXNzZXNBcHBsaWVkfT48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmxpa2VkID8gTG9jYWxpemUoJ0NBUk9VU0VMX0NBUkRfU0FWRUQnKSA6IExvY2FsaXplKCdDQVJPVVNFTF9DQVJEX1NBVkUnKX1cbiAgICAgICAgICAgICAgICA8L2Rpdj47XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwibWluaUNhcmRCdXR0b24gZmlsbFBhcmVudFwiIG9uQ2xpY2s9e3RoaXMucHJvcHMuY2xpY2tBY3Rpb259PjwvZGl2PjtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbmV4cG9ydCBjb25zdCBNaW5pQ2FyZEJ1dHRvbiA9IG5hdmlnYWJsZShNaW5pQ2FyZEJ1dHRvbkNsYXNzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvbWluaUNhcmQvbWluaUNhcmRCdXR0b24vbWluaUNhcmRCdXR0b24uY29tcG9uZW50LnRzeCIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuXG5pbXBvcnQgeyBuYXZpZ2FibGUgfSBmcm9tICdIT0MnO1xuaW1wb3J0IHsgQ2FyZCwgRGl2ZUFQSUNsYXNzLCBSZWxhdGlvbk1vZHVsZSB9IGZyb20gJ0BkaXZlLXR2L2FwaS10eXBlc2NyaXB0LWxpYnJhcnknO1xuaW1wb3J0IHsgTWluaUNhcmQgfSBmcm9tICdDb21wb25lbnRzJztcbmltcG9ydCB7IElVSUFjdGlvbnMsIC8qVXNlckFjdGlvbnMqLyBJVXNlckFjdGlvbnMsIFVJQWN0aW9ucyB9IGZyb20gXCJBY3Rpb25zXCI7XG5cbmRlY2xhcmUgY29uc3QgRGl2ZUFQSTogRGl2ZUFQSUNsYXNzO1xuXG5leHBvcnQgaW50ZXJmYWNlIElNaW5pQ2FyZExpc3RTdGF0ZSB7XG4gICAgZWxlbWVudHM6IEFycmF5PENhcmQgfCBSZWxhdGlvbk1vZHVsZT47XG4gICAgbW92aWVJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHdhc1NlbGVjdGVkT25DaGFuZ2VTY2VuZTogYm9vbGVhbjtcbiAgICBpZHg/OiBudW1iZXI7XG4gICAgZ2V0TW92aWVUaW1lOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElNaW5pQ2FyZExpc3RNZXRob2RzIHtcbiAgICBjbGlja0FjdGlvbj86IGFueTtcbiAgICBzZXRTZWxlY3RlZE9uU2NlbmVDaGFuZ2U/OiBhbnk7XG4gICAgc2V0Tm9kZUJ5SWQ/OiAoaWR4OiBudW1iZXIpID0+IGFueTtcbn1cblxudHlwZSBNaW5pQ2FyZExpc3RQcm9wcyA9IElNaW5pQ2FyZExpc3RTdGF0ZSAmIElNaW5pQ2FyZExpc3RNZXRob2RzICZcbiAgICB7IHVpQWN0aW9uczogSVVJQWN0aW9ucywgdXNlckFjdGlvbnM6IElVc2VyQWN0aW9ucyB9O1xuXG5leHBvcnQgY2xhc3MgTWluaUNhcmRMaXN0Q2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8TWluaUNhcmRMaXN0UHJvcHMsIHt9PiB7XG4gICAgcHVibGljIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHM6IE1pbmlDYXJkTGlzdFByb3BzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5lbGVtZW50cyAhPT0gdHlwZW9mIG5leHRQcm9wcy5lbGVtZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFByb3BzLmVsZW1lbnRzICYmIG5leHRQcm9wcy5lbGVtZW50cy5sZW5ndGggIT09IHRoaXMucHJvcHMuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzOiBNaW5pQ2FyZExpc3RQcm9wcykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIltNaW5pQ2FyZF1bY29tcG9uZW50V2lsbFVwZGF0ZV0gXCIsIG5leHRQcm9wcyk7XG4gICAgICAgIC8vIEVzdG8gZXMgcGFyYSBxdWUgZW4gZWwgY2FtYmlvIGRlIGVzY2VuYSwgc2kgZWwgZm9jbyBlc3TDoSBlbiBhbGd1bmEgbWluaWNhcmQsIHNlIGNhcmd1ZSBsYSBudWV2YSBlc2NlbmFcbiAgICAgICAgLy8gc2VsZWNjaW9uYW5kbyBlbCBwcmltZXIgZWxlbWVudG8uXG4gICAgICAgIGlmICh0aGlzLnByb3BzLndhc1NlbGVjdGVkT25DaGFuZ2VTY2VuZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuc2V0Tm9kZUJ5SWQgJiYgdGhpcy5wcm9wcy5pZHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnNldE5vZGVCeUlkKHRoaXMucHJvcHMuaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnNldFNlbGVjdGVkT25TY2VuZUNoYW5nZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMucHJvcHMuZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc2V0U2VsZWN0ZWRPblNjZW5lQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwibWluaUNhcmRMaXN0XCIgPlxuICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmVsZW1lbnRzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgKHNjZW5lQ2FyZDogQ2FyZCwgaTogbnVtYmVyLCBzY2VuZUNhcmRzOiBDYXJkW10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBzY2VuZUNhcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBzY2VuZUNhcmQuY2FyZF9pZCArICcjJyArIHNjZW5lQ2FyZC52ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBzY2VuZUNhcmRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnM6IHNjZW5lQ2FyZC5yZWxhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvdWwgPlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLnF1ZXJ5U2VsZWN0b3IoXCIuY2hpbGRGb2N1c2VkXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnNldFNlbGVjdGVkT25TY2VuZUNoYW5nZSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZWxlbWVudChwYXJhbXM6IHtcbiAgICAgICAgZWw6IENhcmQsIGtleTogbnVtYmVyIHwgc3RyaW5nLFxuICAgICAgICBjb3VudDogbnVtYmVyLCByZWxhdGlvbnM6IFJlbGF0aW9uTW9kdWxlW10sIGluZGV4OiBudW1iZXIsIHBhcmVudDogYW55LFxuICAgIH0pOiBKU1guRWxlbWVudCB7XG4gICAgICAgIGNvbnN0IHsgZWwsIGtleSwgY291bnQsIHJlbGF0aW9ucywgaW5kZXgsIHBhcmVudCB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBjYXJkOiBDYXJkID0gcGFyYW1zLmVsO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE1pbmlDYXJkXG4gICAgICAgICAgICAgICAgZm9jdXNDaGFpbkNsYXNzPVwiY2hpbGRGb2N1c2VkXCJcbiAgICAgICAgICAgICAgICBhY3RpdmVHcm91cENsYXNzPVwiYWN0aXZlR3JvdXBcIlxuICAgICAgICAgICAgICAgIGdyb3VwTmFtZT17KGVsLmNhcmRfaWQgKyAnJytlbC52ZXJzaW9uKS50b1N0cmluZygpfVxuICAgICAgICAgICAgICAgIGVsZW1lbnQ9e2NhcmR9XG4gICAgICAgICAgICAgICAgcmVsYXRpb25zPXtyZWxhdGlvbnN9XG4gICAgICAgICAgICAgICAgcGFyZW50PXt0aGlzfVxuICAgICAgICAgICAgICAgIGZvcmNlRmlyc3Q9e3RydWV9XG4gICAgICAgICAgICAgICAgZm9yY2VPcmRlcj17aW5kZXh9XG4gICAgICAgICAgICAgICAgY2xpY2tBY3Rpb25Nb3JlPXt0aGlzLmNsaWNrQWN0aW9uTW9yZS5iaW5kKHRoaXMpKGNhcmQpfVxuICAgICAgICAgICAgICAgIGNsaWNrQWN0aW9uTGlrZT17dGhpcy5jbGlja0FjdGlvbkxpa2UuYmluZCh0aGlzKShjYXJkKX1cbiAgICAgICAgICAgICAgICAvLyB0cmFja1Zpc2liaWxpdHk9e3RoaXMudHJhY2tWaXNpYmlsaXR5LmJpbmQodGhpcykoY2FyZCl9XG4gICAgICAgICAgICAgICAgb25Gb2N1c0NhbGxiYWNrPXt0aGlzLm9uRm9jdXNDYWxsYmFjay5iaW5kKHRoaXMpKGNhcmQpfVxuICAgICAgICAgICAgICAgIGtleT17a2V5fVxuICAgICAgICAgICAgICAgIGlkPXtgJHtrZXl9YH1cbiAgICAgICAgICAgICAgICBpc1Njcm9sbGFibGU9e3RydWV9XG4gICAgICAgICAgICAgICAgLy8gc2Nyb2xsUGFkZGluZz17MTAwfVxuICAgICAgICAgICAgICAgIG5hdkNsYXNzPVwic2Nyb2xsYWJsZVwiXG4gICAgICAgICAgICAvPik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbGlja0FjdGlvbkxpa2Uob3JpZ2luYWxDYXJkOiBDYXJkKSB7XG4gICAgICAgIHJldHVybiAocGFyYW1DYXJkOiBDYXJkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYXJkID0gcGFyYW1DYXJkIHx8IG9yaWdpbmFsQ2FyZDtcbiAgICAgICAgICAgIGlmICghY2FyZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxJS0VcIiwgY2FyZC5jYXJkX2lkKTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMudXNlckFjdGlvbnMubGlrZUNhcmQoY2FyZClcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTGlrZWQgc3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRPRE86IENoZWNrIGlmIGRldmljZSBvciB1c2VyIGFjY291bnRcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBEaXZlQVBJLnBvc3RMaWtlcyh7IGNhcmRJZDogY2FyZC5jYXJkX2lkIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBCb3R0b20gbWVzc2FnZSBcIkxpa2VkXCIgPyBvciBqdXN0IGNoYW5nZSB0aGUgaWNvbj87XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogR28gdG8gbG9naW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJHTyBUTyBMT0dJTlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNhdmluZyBjYXJkXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xpY2tBY3Rpb25Nb3JlKG9yaWdpbmFsQ2FyZDogQ2FyZCkge1xuICAgICAgICByZXR1cm4gKHBhcmFtQ2FyZDogQ2FyZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FyZCA9IHBhcmFtQ2FyZCB8fCBvcmlnaW5hbENhcmQ7XG4gICAgICAgICAgICBpZiAoIWNhcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhcmQgY2xpY2tlZFwiLCBjYXJkKTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMudWlBY3Rpb25zLm9wZW5DYXJkKGNhcmQuY2FyZF9pZCwgXCJvZmZtb3ZpZVwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uRm9jdXNDYWxsYmFjayhvcmlnaW5hbENhcmQ6IENhcmQpIHtcbiAgICAgICAgcmV0dXJuIChwYXJhbUNhcmQ6IENhcmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhcmQgPSBwYXJhbUNhcmQgfHwgb3JpZ2luYWxDYXJkO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gKGRpc3BhdGNoOiBhbnkpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyB1c2VyQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKFVzZXJBY3Rpb25zLCBkaXNwYXRjaCksXG4gICAgICAgIHVpQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKFVJQWN0aW9ucywgZGlzcGF0Y2gpLFxuICAgIH07XG59O1xuXG5jb25zdCBtZXJnZVByb3BzID0gKHN0YXRlUHJvcHM6IGFueSwgZGlzcGF0Y2hQcm9wczogYW55LCBvd25Qcm9wczogYW55KSA9PiB7XG4gICAgcmV0dXJuIHsgLi4uc3RhdGVQcm9wcywgLi4ub3duUHJvcHMsIC4uLmRpc3BhdGNoUHJvcHMgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBNaW5pQ2FyZExpc3QgPSBjb25uZWN0KFxuICAgIHVuZGVmaW5lZCxcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgbWVyZ2VQcm9wcyxcbiAgICB7IHdpdGhSZWY6IHRydWUgfSxcbikobmF2aWdhYmxlKE1pbmlDYXJkTGlzdENsYXNzKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL21pbmlDYXJkTGlzdC9taW5pQ2FyZExpc3QuY29tcG9uZW50LnRzeCIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG5hdmlnYWJsZSwgSU5hdmlnYWJsZSB9IGZyb20gJ0hPQyc7XG5pbXBvcnQgeyBUZXh0LCBDYXJkLCBIZWxwZXIsIExvY2FsaXplLCBSZWxhdGlvbk1vZHVsZSwgRHVwbGUgfSBmcm9tICdTZXJ2aWNlcyc7XG5pbXBvcnQgeyBNaW5pQ2FyZEJ1dHRvbiwgQ2FyZEFuZENhdGVnb3J5IH0gZnJvbSAnQ29tcG9uZW50cyc7XG5pbXBvcnQgKiBhcyBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElNaW5pQ2FyZFN0YXRlIHtcbiAgICBlbGVtZW50OiBDYXJkO1xuICAgIHJlbGF0aW9uczogUmVsYXRpb25Nb2R1bGVbXTtcbiAgICBncm91cE5hbWU6IHN0cmluZztcbiAgICBzZWxlY3RlZE5hdj86IElOYXZpZ2FibGU7XG4gICAgc2VsZWN0ZWQ/OiBudW1iZXI7XG4gICAgaWR4PzogbnVtYmVyO1xuICAgIGZvcmNlRmlyc3Q/OiBib29sZWFuO1xuICAgIGZvcmNlT3JkZXI/OiBudW1iZXI7XG4gICAgbmF2aWdhdGlvbj86IE1hcDxudW1iZXIsIElOYXZpZ2FibGU+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElNaW5pQ2FyZE1ldGhvZHMge1xuICAgIGNsaWNrQWN0aW9uTW9yZTogYW55O1xuICAgIGNsaWNrQWN0aW9uTGlrZTogYW55O1xuICAgIHNldE5vZGVCeUlkPzogYW55O1xuICAgIC8vIHNldFNlbGVjdGVkT25TY2VuZUNoYW5nZT86IGFueTtcbn1cblxudHlwZSBNaW5pQ2FyZFByb3BzID0gSU1pbmlDYXJkU3RhdGUgJiBJTWluaUNhcmRNZXRob2RzICYgeyBpZDogc3RyaW5nIH07XG5cbmV4cG9ydCBjbGFzcyBNaW5pQ2FyZENsYXNzIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxNaW5pQ2FyZFByb3BzLCB7fT4ge1xuXG4gICAgcHJpdmF0ZSBlbGVtZW50OiBIVE1MTElFbGVtZW50O1xuICAgIHByaXZhdGUgb3BlbkNhcmQ6IENhcmQ7XG5cbiAgICBwdWJsaWMgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBpc1JlbGF0aW9uOiBib29sZWFuID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgICAgIG1pbmljYXJkOiB0cnVlLFxuICAgICAgICAgICAgcmVsYXRpb246IGlzUmVsYXRpb24sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8bGkgaWQ9e3RoaXMucHJvcHMuaWR9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc2VzfT5cbiAgICAgICAgICAgICAgICAgICAge2lzUmVsYXRpb24gPyA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aW9uQmFyXCIgLz4gOiAnJ31cbiAgICAgICAgICAgICAgICAgICAge3RoaXMubWluaUNhcmQoKX1cbiAgICAgICAgICAgICAgICAgICAge3RoaXMuZXhwYW5kZWRJbmZvKCl9XG4gICAgICAgICAgICAgICAgPC9kaXYgPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICB0aGlzLm9wZW5DYXJkID0gdGhpcy5wcm9wcy5lbGVtZW50O1xuICAgICAgICAvKmNvbnNvbGUubG9nKFwiU2V0dGluZyBvcGVuIGlkIHRvXCIsXG4gICAgICAgICAgICB0aGlzLnByb3BzLmVsZW1lbnQudHlwZSxcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZWxlbWVudC50aXRsZSxcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZWxlbWVudC5jYXJkX2lkLFxuICAgICAgICApOyovXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtaW5pQ2FyZCA9ICgpOiBKU1guRWxlbWVudCA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRMZWZ0XCIgb25Nb3VzZU92ZXI9eygpID0+IHRoaXMucHJvcHMuc2V0Tm9kZUJ5SWQodGhpcy5wcm9wcy5pZHgpfT5cbiAgICAgICAgICAgICAgICA8Q2FyZEFuZENhdGVnb3J5IGNhcmQ9e3RoaXMucHJvcHMuZWxlbWVudH0gLz5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBhbmRlZEluZm8gPSAoKTogSlNYLkVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0OiBKU1guRWxlbWVudCA9IHRoaXMuZXhwYW5kZWRJbmZvVGV4dCgpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImV4cGFuZGVkSW5mb0NvbnRhaW5lclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZXhwYW5kZWRJbmZvXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZXhwYW5kZWRJbmZvSW5zaWRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHRcIj57dGV4dH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnRuXCI+e3RoaXMuYnV0dG9uKCdNT1JFJyl9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ0blwiPnt0aGlzLmJ1dHRvbignU0FWRScpfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBhbmRlZEluZm9UZXh0ID0gKCk6IEpTWC5FbGVtZW50ID0+IHtcbiAgICAgICAgbGV0IGJveDogSlNYLkVsZW1lbnQ7XG4gICAgICAgIGxldCB0ZXh0OiBzdHJpbmcgPSAnJztcbiAgICAgICAgY29uc3QgdGV4dENvbnRhaW5lcjogVGV4dCA9IEhlbHBlci5nZXRDb250YWluZXIodGhpcy5wcm9wcy5lbGVtZW50LCAndGV4dCcpIGFzIFRleHQ7XG4gICAgICAgIGlmICh0ZXh0Q29udGFpbmVyICE9PSB1bmRlZmluZWQgJiYgdGV4dENvbnRhaW5lci5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0Q29udGFpbmVyLmRhdGFbMF0udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wcy5lbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3F1b3RlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlZmVyZW5jZSc6XG4gICAgICAgICAgICAgICAgYm94ID0gPGRpdiBjbGFzc05hbWU9XCJ0ZXh0IGFsb25lXCI+e3RleHR9PC9kaXY+O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2hhcmFjdGVyJzpcbiAgICAgICAgICAgICAgICBjb25zdCByZWxhdGlvbjogUmVsYXRpb25Nb2R1bGUgfCB1bmRlZmluZWQgPSBIZWxwZXIuZ2V0UmVsYXRpb24odGhpcy5wcm9wcy5yZWxhdGlvbnMsICdwbGF5ZWRfYnknKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkdXBsZSA9IHJlbGF0aW9uIGFzIER1cGxlO1xuICAgICAgICAgICAgICAgIGlmIChkdXBsZS5kYXRhIGluc3RhbmNlb2YgQXJyYXkgJiYgZHVwbGUuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlcnNvbiA9IGR1cGxlLmRhdGFbMF0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gdGhpcy5wcm9wcy5lbGVtZW50LnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVyc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbWJpb3MgbGEgcmVmIGRlIGNhcmQgcXVlIHNlIGRlYmUgYWJyaXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbkNhcmQgPSBwZXJzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb250YW1vcyBlbCBub21icmUgY29uIGVsIG5vbWJyZSBkZWwgcGVyc29uYWplICdhcycgbm9tYnJlIGRlbCBhY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlcnNvbi50aXRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBwZXJzb24udGl0bGUgKyAnIGFzICcgKyB0aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29nZW1vcyBsYSBkZXNjcmlwY2nDs24gZGVsIGFjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0UGVyc29uQ29udGFpbmVyOiBUZXh0ID0gSGVscGVyLmdldENvbnRhaW5lcihwZXJzb24sICd0ZXh0JykgYXMgVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0UGVyc29uQ29udGFpbmVyICE9PSB1bmRlZmluZWQgJiYgdGV4dFBlcnNvbkNvbnRhaW5lci5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dFBlcnNvbkNvbnRhaW5lci5kYXRhWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBjb2dlciByZWxhY2nDs24gYWN0b3IvcGVyc29uYWplIHBhcmEgcGludGFyIGVsIHTDrXR1bG8uXG4gICAgICAgICAgICAgICAgICAgIGJveCA9IDxkaXYgY2xhc3NOYW1lPVwidGV4dFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0aXRsZVwiPnt0aXRsZX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVzY1wiPnt0ZXh0fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NvbmcnOlxuICAgICAgICAgICAgICAgIGJveCA9IDxkaXYgY2xhc3NOYW1lPVwidGV4dFwiPjwvZGl2PjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBib3ggPSA8ZGl2IGNsYXNzTmFtZT1cInRleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0aXRsZVwiPnt0aGlzLnByb3BzLmVsZW1lbnQudGl0bGV9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVzY1wiPnt0ZXh0fTwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PjtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3g7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBidXR0b24gPSAodHlwZTogJ01PUkUnIHwgJ1NBVkUnKTogSlNYLkVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25XaGVuTW9yZSA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiU2V0dGluZyBvcGVuIGlkIHRvXCIsIHRoaXMub3BlbkNhcmQpO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5jbGlja0FjdGlvbk1vcmUodGhpcy5vcGVuQ2FyZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFjdGlvbldoZW5MaWtlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5jbGlja0FjdGlvbkxpa2UodGhpcy5vcGVuQ2FyZCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoPE1pbmlDYXJkQnV0dG9uXG4gICAgICAgICAgICBjbGlja0FjdGlvbj17dHlwZSA9PT0gJ1NBVkUnID8gYWN0aW9uV2hlbkxpa2UgOiBhY3Rpb25XaGVuTW9yZX1cbiAgICAgICAgICAgIHBhcmVudD17dGhpc31cbiAgICAgICAgICAgIGNvbHVtbnM9ezF9XG4gICAgICAgICAgICBncm91cE5hbWU9e3RoaXMucHJvcHMuZ3JvdXBOYW1lfVxuICAgICAgICAgICAgdHlwZT17dHlwZX1cbiAgICAgICAgLz4pO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IE1pbmlDYXJkID0gbmF2aWdhYmxlKE1pbmlDYXJkQ2xhc3MpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9taW5pQ2FyZC9taW5pQ2FyZC5jb21wb25lbnQudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgY2xhc3MgTG9hZGluZyBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8e30sIHt9PiB7XG4gICAgcHVibGljIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmlsbFBhcmVudFwiIHN0eWxlPXt7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIgfX0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGlubmVyXCI+PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9sb2FkaW5nL2xvYWRpbmcuY29tcG9uZW50LnRzeCIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgSUNhcmRNb2R1bGVQcm9wcyB9IGZyb20gXCJDYXJkTW9kdWxlc1wiO1xuaW1wb3J0IHsgbmF2aWdhYmxlLCBzdGF0aWNzIH0gZnJvbSBcIkhPQ1wiO1xuaW1wb3J0IHsgSGVscGVyLCBMb2NhbGl6ZSwgQ2FyZCB9IGZyb20gXCJTZXJ2aWNlc1wiO1xuaW1wb3J0IHsgVmVydGljYWxTY3JvbGwgfSBmcm9tIFwiQ29tcG9uZW50c1wiO1xuXG5pbnRlcmZhY2UgSVRleHRQcm9wcyB7XG4gICAgY29udGFpbmVyOiBhbnk7XG4gICAgdGV4dERhdGE6IGFueTtcbn1cbkBzdGF0aWNzKHtcbiAgICBtb2R1bGVOYW1lOiBcInRleHRcIixcbiAgICB2YWxpZGF0ZTogKGNhcmQ6IENhcmQsIG1vZHVsZVR5cGU6IHN0cmluZywgcGFyZW50OiBhbnksIHByb3BzOiBhbnkpID0+IHtcbiAgICAgICAgLy8gTm8gc2UgcHVlZGUgZ3VhcmRhciBlbCBjb250YWluZXIgYXF1w60sIHBvcnF1ZSBlcyB1biBtw6l0b2RvIGVzdMOhdGljby5cbiAgICAgICAgY29uc3QgY29udGFpbmVyOiBhbnkgfCB1bmRlZmluZWQgPSBIZWxwZXIuZ2V0Q29udGFpbmVyKGNhcmQsICd0ZXh0JykgYXMgYW55O1xuICAgICAgICBpZiAoY29udGFpbmVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGNvbnRhaW5lci5kYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGNvbnRhaW5lci5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IEluc3RhbnRpYXRlZCA9IG5hdmlnYWJsZShUZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAoPEluc3RhbnRpYXRlZFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcj17Y29udGFpbmVyfVxuICAgICAgICAgICAgICAgIHRleHREYXRhPXtjb250YWluZXIuZGF0YVswXX1cbiAgICAgICAgICAgICAgICBwYXJlbnQ9e3BhcmVudH1cbiAgICAgICAgICAgICAgICBpc1Njcm9sbGFibGU9e3RydWV9XG4gICAgICAgICAgICAgICAgY2FyZD17Y2FyZH1cbiAgICAgICAgICAgICAgICBtb2R1bGVUeXBlPXttb2R1bGVUeXBlfVxuICAgICAgICAgICAgICAgIHsuLi5wcm9wc30gLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbn0pXG5leHBvcnQgY2xhc3MgVGV4dCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8SUNhcmRNb2R1bGVQcm9wcyAmIElUZXh0UHJvcHMsIHt9PiB7XG4gICAgcHVibGljIHJlbmRlcigpOiBhbnkge1xuICAgICAgICBjb25zdCB0ZXh0VGl0bGUgPSB0aGlzLmdldFRpdGxlKCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRNb2R1bGVUZXh0IGNhcmRNb2R1bGVcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgICAgICAgICAgICAgICA8VmVydGljYWxTY3JvbGwgc291cmNlPXt0aGlzLnByb3BzLnRleHREYXRhID8gdGhpcy5wcm9wcy50ZXh0RGF0YS5zb3VyY2UgOiB1bmRlZmluZWR9IHBhcmVudD17dGhpc30+XG4gICAgICAgICAgICAgICAgICAgICAgICB7dGV4dFRpdGxlID8gPGRpdiBjbGFzc05hbWU9XCJjYXJkVGl0bGVcIj57dGV4dFRpdGxlfTwvZGl2PiA6IG51bGx9XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRUZXh0XCI+e3RoaXMucHJvcHMudGV4dERhdGEudGV4dH08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9WZXJ0aWNhbFNjcm9sbD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGl0bGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BzLmNvbnRhaW5lciEuY29udGVudF90eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdiaW9ncmFwaHknOlxuICAgICAgICAgICAgICAgIHJldHVybiBMb2NhbGl6ZSgnQklPR1JBUEhZJyk7XG4gICAgICAgICAgICBjYXNlICdvdmVydmlldyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvY2FsaXplKCdPVkVSVklFVycpO1xuICAgICAgICAgICAgY2FzZSAnY3VyaW9zaXR5JzpcbiAgICAgICAgICAgIGNhc2UgJ3JlZmVyZW5jZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvY2FsaXplKCdDVVJJT1NJVFlfVElUTEUnKTtcbiAgICAgICAgICAgIGNhc2UgJ3F1b3RlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlZmVyZW5jZSc6XG4gICAgICAgICAgICBjYXNlICdkZXNjcmlwdGlvbic6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NhcmRNb2R1bGVzL3RleHQvdGV4dC5jb21wb25lbnQudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQge1xuICAgIENhcmQsIENhcmRDb250YWluZXJUeXBlRW51bSwgSGVscGVyLFxuICAgIExpc3RpbmcgYXMgTGlzdGluZ1ZPLCBMaXN0aW5nRGF0YSBhcyBMaXN0aW5nRGF0YVZPLCBMb2NhbGl6ZSwgTGlzdGluZ0RhdGEsXG59IGZyb20gXCJTZXJ2aWNlc1wiO1xuaW1wb3J0IHsgSUNhcmRNb2R1bGVQcm9wcyB9IGZyb20gXCJDYXJkTW9kdWxlc1wiO1xuaW1wb3J0IHsgRGlyZWN0aW9uQnV0dG9uLCBWZXJ0aWNhbFNjcm9sbCB9IGZyb20gXCJDb21wb25lbnRzXCI7XG5pbXBvcnQgeyBuYXZpZ2FibGUsIHN0YXRpY3MgfSBmcm9tIFwiSE9DXCI7XG5cbmludGVyZmFjZSBJVGFibGVQcm9wcyB7XG4gICAgY29udGFpbmVyOiBMaXN0aW5nVk87XG59XG5Ac3RhdGljcyh7XG4gICAgbW9kdWxlTmFtZTogXCJ0YWJsZVwiLFxuICAgIHZhbGlkYXRlOiAoY2FyZDogQ2FyZCwgbW9kdWxlVHlwZTogc3RyaW5nLCBwYXJlbnQ6IGFueSwgcHJvcHM6IGFueSkgPT4ge1xuICAgICAgICAvLyBObyBzZSBwdWVkZSBndWFyZGFyIGVsIGNvbnRhaW5lciBhcXXDrSwgcG9ycXVlIGVzIHVuIG3DqXRvZG8gZXN0w6F0aWNvLlxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBIZWxwZXIuZ2V0Q29udGFpbmVyKGNhcmQsICdsaXN0aW5nJykgYXMgTGlzdGluZ1ZPO1xuICAgICAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5kYXRhICYmIGNvbnRhaW5lci5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IEluc3RhbnRpYXRlZCA9IG5hdmlnYWJsZShUYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gKDxJbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICBjb250YWluZXI9e2NvbnRhaW5lcn1cbiAgICAgICAgICAgICAgICBwYXJlbnQ9e3BhcmVudH1cbiAgICAgICAgICAgICAgICBpc1Njcm9sbGFibGU9e3RydWV9XG4gICAgICAgICAgICAgICAgY2FyZD17Y2FyZH1cbiAgICAgICAgICAgICAgICBtb2R1bGVUeXBlPXttb2R1bGVUeXBlfSAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZSBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8SUNhcmRNb2R1bGVQcm9wcyAmIElUYWJsZVByb3BzLCB7fT4ge1xuICAgIHB1YmxpYyByZW5kZXIoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZE1vZHVsZVRhYmxlIGNhcmRNb2R1bGVcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgICAgICAgICAgICAgICA8VmVydGljYWxTY3JvbGwgcGFyZW50PXt0aGlzfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZFRpdGxlXCI+e3RoaXMuZ2V0VGl0bGUoKX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGFibGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmNvbnRhaW5lciEuZGF0YS5tYXAoKGxpc3RJdGVtOiBMaXN0aW5nRGF0YSwgaWR4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIga2V5PXtpZHh9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPntsaXN0SXRlbS50ZXh0fTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e2xpc3RJdGVtLnZhbHVlfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9WZXJ0aWNhbFNjcm9sbD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGl0bGUgPSAoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wcy5jb250YWluZXIhLmNvbnRlbnRfdHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BlY3MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBMb2NhbGl6ZSgnU1BFQ1MnKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jhc2ljX2RhdGEnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9jYWxpemUoJ0JBU0lDX0RBVEEnKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NhcmRNb2R1bGVzL3RhYmxlL3RhYmxlLmNvbXBvbmVudC50c3giLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7XG4gICAgQ2FyZCxcbiAgICBQcm9kdWN0LFxuICAgIENhcmRDb250YWluZXJUeXBlRW51bSxcbiAgICBMb2NhbGl6ZSxcbiAgICBIZWxwZXIsXG4gICAgSW1hZ2UgYXMgSW1hZ2VWTyxcbiAgICBJbWFnZURhdGEgYXMgSW1hZ2VEYXRhVk8sXG4gICAgU2Vhc29ucyBhcyBTZWFzb25zVk8sXG4gICAgU2Vhc29uc0RhdGEgYXMgU2Vhc29uc0RhdGFWTyxcbiAgICBDYXJkQ29udGFpbmVyLFxuICAgIFJlbGF0aW9uTW9kdWxlLFxuICAgIFNpbmdsZSxcbiAgICBEdXBsZSxcbiAgICBEdXBsZURhdGFcbn0gZnJvbSBcIlNlcnZpY2VzXCI7XG5pbXBvcnQgeyBJQ2FyZE1vZHVsZVByb3BzIH0gZnJvbSBcIkNhcmRNb2R1bGVzXCI7XG5pbXBvcnQgeyBEaXJlY3Rpb25CdXR0b24sIEhvcml6b250YWxTY3JvbGwsIE5hdmlnYXRpb25Db250YWluZXIgfSBmcm9tIFwiQ29tcG9uZW50c1wiO1xuaW1wb3J0IHsgbmF2aWdhYmxlLCBzdGF0aWNzIH0gZnJvbSBcIkhPQ1wiO1xuXG5pbnRlcmZhY2UgSUxpc3RQcm9wcyB7XG4gICAgaXRlbXNTaG93bjogbnVtYmVyLFxuICAgIGNvbnRhaW5lcjogSUxpc3RDb250YWluZXJUeXBlLFxuICAgIGNhcmQ6IENhcmQsXG4gICAgbW9kdWxlVHlwZTogTGlzdE1vZHVsZVR5cGVcbn1cblxuLyppbnRlcmZhY2UgSVRlbXBQcm9kdWN0IHtcbiAgICBjYXRlZ29yeSA6IHN0cmluZyxcbiAgICBjdXJyZW5jeSA6IHN0cmluZyxcbiAgICBpbWFnZSA6IHN0cmluZyxcbiAgICBpc19leGFjdCA6IGJvb2xlYW4sXG4gICAgaXNfdXBfdG9fZGF0ZSA6IGJvb2xlYW4sXG4gICAgcHJpY2UgOiBudW1iZXIsXG4gICAgcHJvZHVjdF9pZCA6IHN0cmluZyxcbiAgICBzb3VyY2UgOiB7XG4gICAgICAgIGRpc2NsYWltZXI/OiBzdHJpbmcsXG4gICAgICAgIGltYWdlOiBzdHJpbmcsXG4gICAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgICAgdXJsOiBzdHJpbmcsXG4gICAgfVxuXG59Ki9cblxuaW50ZXJmYWNlIElMaXN0Q29udGFpbmVyVHlwZS8qZXh0ZW5kcyBDYXJkQ29udGFpbmVyKi8ge1xuICAgIGNvbnRlbnRfdHlwZTogc3RyaW5nLFxuICAgIGRhdGE6IEFycmF5PGFueT5cbn07XG50eXBlIExpc3RNb2R1bGVUeXBlID0gJ0dhbGxlcnknIHwgJ1Nob3AnIHwgJ1RyYXZlbFNob3AnIHwgJ0ZpbG1vZ3JhcGh5JyB8ICdWZWhpY2xlcycgfCAnU2Vhc29ucycgfCAnQXBwZWFyc0luJyB8ICdGYXNoaW9uJyB8ICdIb21lJyB8ICdSZWNvbW1lbmRlZCcgfCAnQ2FzdCcgfCAnQXBwZWFyc0luTG9jYXRpb24nIHwgJ0NvbXBsZXRlVGhlRGVjbyc7XG5cbkBzdGF0aWNzKHtcbiAgICBtb2R1bGVOYW1lOiBcImxpc3RcIixcbiAgICB2YWxpZGF0ZTogKGNhcmQ6IENhcmQsIG1vZHVsZVR5cGU6IHN0cmluZywgcGFyZW50OiBhbnksIHByb3BzOiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyOiBJbWFnZVZPIHwgU2Vhc29uc1ZPIHwgSUxpc3RDb250YWluZXJUeXBlIHwgU2luZ2xlIHwgRHVwbGUgfCB1bmRlZmluZWQgPSBMaXN0LmdldENvbnRhaW5lcihjYXJkLCBtb2R1bGVUeXBlKTtcblxuICAgICAgICBpZiAoY29udGFpbmVyICE9PSB1bmRlZmluZWQgJiYgY29udGFpbmVyLmRhdGEgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZXIuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBJbnN0YW50aWF0ZWQgPSBuYXZpZ2FibGUoTGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gKDxJbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICBpdGVtc1Nob3duPXsyfVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcj17Y29udGFpbmVyfVxuICAgICAgICAgICAgICAgIHBhcmVudD17cGFyZW50fVxuICAgICAgICAgICAgICAgIGlzU2Nyb2xsYWJsZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICBjYXJkPXtjYXJkfVxuICAgICAgICAgICAgICAgIG1vZHVsZVR5cGU9e21vZHVsZVR5cGUgYXMgTGlzdE1vZHVsZVR5cGV9IC8+KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIExpc3QgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PElDYXJkTW9kdWxlUHJvcHMgJiBJTGlzdFByb3BzLCB7fT4ge1xuXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb250YWluZXIoY2FyZDogQ2FyZCwgbW9kdWxlVHlwZTogc3RyaW5nKTogSW1hZ2VWTyB8IElMaXN0Q29udGFpbmVyVHlwZSB8IFNpbmdsZSB8IER1cGxlIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJGaWxtb2dyYXBoeSBjYXJkOiBcIiwgY2FyZCk7XG4gICAgICAgIHN3aXRjaCAobW9kdWxlVHlwZSBhcyBMaXN0TW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnR2FsbGVyeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEhlbHBlci5nZXRDb250YWluZXIoY2FyZCwgJ2ltYWdlJykgYXMgSW1hZ2VWTztcbiAgICAgICAgICAgIGNhc2UgJ1Nob3AnOlxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiU2hvcCBjYXJkOiBcIiwgY2FyZCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50X3R5cGU6ICdwcm9kdWN0cycsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNhcmQucHJvZHVjdHMsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXN0aW5nJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiBhcyBJTGlzdENvbnRhaW5lclR5cGU7XG5cbiAgICAgICAgICAgIGNhc2UgJ1RyYXZlbFNob3AnOlxuICAgICAgICAgICAgICAgIGNvbnN0IG9iajIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRfdHlwZTogJ3Byb2R1Y3RzJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY2FyZC5wcm9kdWN0cyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpc3RpbmcnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqMiBhcyBJTGlzdENvbnRhaW5lclR5cGU7XG5cbiAgICAgICAgICAgIGNhc2UgJ0ZpbG1vZ3JhcGh5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSGVscGVyLmdldFJlbGF0aW9uKGNhcmQucmVsYXRpb25zLCAnZmlsbW9ncmFwaHknLCAnY29udGVudF90eXBlJykgYXMgRHVwbGU7XG4gICAgICAgICAgICBjYXNlICdDYXN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSGVscGVyLmdldFJlbGF0aW9uKGNhcmQucmVsYXRpb25zLCAnY2FzdGluZycsICdjb250ZW50X3R5cGUnKSBhcyBEdXBsZTtcbiAgICAgICAgICAgIGNhc2UgJ1NlYXNvbnMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBIZWxwZXIuZ2V0Q29udGFpbmVyKGNhcmQsICdzZWFzb25zJykgYXMgU2Vhc29uc1ZPO1xuICAgICAgICAgICAgY2FzZSAnQXBwZWFyc0luTG9jYXRpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBIZWxwZXIuZ2V0UmVsYXRpb24oY2FyZC5yZWxhdGlvbnMsICdmaWxtZWRfaW4nLCAnY29udGVudF90eXBlJykgYXMgU2luZ2xlO1xuICAgICAgICAgICAgY2FzZSAnQ29tcGxldGVUaGVEZWNvJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSGVscGVyLmdldFJlbGF0aW9uKGNhcmQucmVsYXRpb25zLCAnaG9tZV9kZWNvJywgJ2NvbnRlbnRfdHlwZScpIGFzIFNpbmdsZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyByZW5kZXIoKTogYW55IHtcbiAgICAgICAgY29uc3QgdGV4dFRpdGxlID0gdGhpcy5nZXRUaXRsZSgpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkTW9kdWxlTGlzdCBjYXJkTW9kdWxlXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkVGl0bGVcIj57dGV4dFRpdGxlfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxpc3RDb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8SG9yaXpvbnRhbFNjcm9sbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudD17dGhpc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVJZD17dGhpcy5wcm9wcy5jb250YWluZXIhLmNvbnRlbnRfdHlwZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1Nob3duPXt0aGlzLnByb3BzLml0ZW1zU2hvd259PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLmdldExpc3QoKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvSG9yaXpvbnRhbFNjcm9sbD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldExpc3QgPSAoKTogSlNYLkVsZW1lbnRbXSB8IG51bGwgPT4ge1xuICAgICAgICBjb25zdCB0eXBlOiBMaXN0TW9kdWxlVHlwZSA9IHRoaXMucHJvcHMubW9kdWxlVHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0dhbGxlcnknOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEdhbGxlcnlMaXN0KCk7XG4gICAgICAgICAgICBjYXNlICdTaG9wJzpcbiAgICAgICAgICAgIGNhc2UgJ1RyYXZlbFNob3AnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNob3BMaXN0KCk7XG4gICAgICAgICAgICBjYXNlICdGaWxtb2dyYXBoeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsbW9ncmFwaHlMaXN0KCk7XG4gICAgICAgICAgICBjYXNlICdDYXN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDYXN0TGlzdCgpO1xuICAgICAgICAgICAgLypjYXNlICdEaXJlY3RvcnMnOiovXG4gICAgICAgICAgICBjYXNlICdBcHBlYXJzSW5Mb2NhdGlvbic6XG4gICAgICAgICAgICBjYXNlICdDb21wbGV0ZVRoZURlY28nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlbFNpbmdsZUxpc3QoKTtcbiAgICAgICAgICAgIGNhc2UgJ1NlYXNvbnMnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlYXNvbkxpc3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0R2FsbGVyeUxpc3QgPSAoKTogSlNYLkVsZW1lbnRbXSB8IG51bGwgPT4ge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpc1xuICAgICAgICAgICAgICAgIC5wcm9wc1xuICAgICAgICAgICAgICAgIC5jb250YWluZXJcbiAgICAgICAgICAgICAgICAuZGF0YVxuICAgICAgICAgICAgICAgIC5tYXAoKGVsOiBJbWFnZURhdGFWTywgaTogbnVtYmVyKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxOYXZpZ2F0aW9uQ29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e3RoaXMucHJvcHMuY29udGFpbmVyIS5jb250ZW50X3R5cGUgKyAnX3Nob3dfJyArIGl9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ9e3RoaXN9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZU9yZGVyPXtpICUgdGhpcy5wcm9wcy5pdGVtc1Nob3dufVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Mn1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImhvcml6b250YWxFbGVtZW50IGxpc3RFbGVtZW50IGZvY3VzYWJsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9e2VsLnRodW1ifSAvPlxuICAgICAgICAgICAgICAgICAgICA8L05hdmlnYXRpb25Db250YWluZXI+XG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRTaG9wTGlzdCA9ICgpOiBKU1guRWxlbWVudFtdIHwgbnVsbCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzXG4gICAgICAgICAgICAgICAgLnByb3BzXG4gICAgICAgICAgICAgICAgLmNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC5kYXRhXG4gICAgICAgICAgICAgICAgLm1hcCgoZWw6IFByb2R1Y3QsIGk6IG51bWJlcikgPT4gdGhpcy5nZXRHZW5lcmljRWxlbWVudChlbC5wcmljZS50b1N0cmluZygpICsgZWwuY3VycmVuY3ksIGVsLmltYWdlLCBpKSk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGaWxtb2dyYXBoeUxpc3QgPSAoKTogSlNYLkVsZW1lbnRbXSB8IG51bGwgPT4ge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpc1xuICAgICAgICAgICAgICAgIC5wcm9wc1xuICAgICAgICAgICAgICAgIC5jb250YWluZXJcbiAgICAgICAgICAgICAgICAuZGF0YVxuICAgICAgICAgICAgICAgIC5tYXAoKGVsOiBEdXBsZURhdGEsIGk6IG51bWJlcikgPT4gdGhpcy5nZXRHZW5lcmljRWxlbWVudChlbC5mcm9tLnRpdGxlLCBlbC5mcm9tLmltYWdlID8gZWwuZnJvbS5pbWFnZS50aHVtYiA6IG51bGwsIGkpKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENhc3RMaXN0ID0gKCk6IEpTWC5FbGVtZW50W10gfCBudWxsID0+IHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXNcbiAgICAgICAgICAgICAgICAucHJvcHNcbiAgICAgICAgICAgICAgICAuY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLmRhdGFcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChlbDogRHVwbGVEYXRhKSA9PiBlbC5yZWxfdHlwZSA9PSAncGxheXMnICYmIGVsLmZyb20uaW1hZ2UgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgLm1hcCgoZWw6IER1cGxlRGF0YSwgaTogbnVtYmVyKSA9PiB0aGlzLmdldEdlbmVyaWNFbGVtZW50KGVsLmZyb20udGl0bGUsIGVsLmZyb20uaW1hZ2UudGh1bWIsIGkpKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFJlbFNpbmdsZUxpc3QgPSAoKTogSlNYLkVsZW1lbnRbXSB8IG51bGwgPT4ge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpc1xuICAgICAgICAgICAgICAgIC5wcm9wc1xuICAgICAgICAgICAgICAgIC5jb250YWluZXJcbiAgICAgICAgICAgICAgICAuZGF0YVxuICAgICAgICAgICAgICAgIC5tYXAoKGVsOiBDYXJkLCBpOiBudW1iZXIpID0+IHRoaXMuZ2V0R2VuZXJpY0VsZW1lbnQoZWwudGl0bGUsIGVsLmltYWdlLnRodW1iLCBpKSk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHByaXZhdGUgZ2V0U2Vhc29uTGlzdCA9ICgpOiBKU1guRWxlbWVudFtdIHwgbnVsbCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzXG4gICAgICAgICAgICAgICAgLnByb3BzXG4gICAgICAgICAgICAgICAgLmNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC5kYXRhXG4gICAgICAgICAgICAgICAgLm1hcCgoZWw6IFNlYXNvbnNEYXRhVk8sIGk6IG51bWJlcikgPT4gdGhpcy5nZXRHZW5lcmljRWxlbWVudCgnU2Vhc29uICcgKyBlbC5zZWFzb25faW5kZXgsIGVsLmltYWdlLnRodW1iLCBpKSk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGdldEdlbmVyaWNFbGVtZW50ID0gKHRpdGxlOiBzdHJpbmcsIGltYWdlOiBzdHJpbmcsIG9yZGVyOiBudW1iZXIpOiBKU1guRWxlbWVudCA9PlxuICAgICAgICA8TmF2aWdhdGlvbkNvbnRhaW5lclxuICAgICAgICAgICAga2V5PXt0aGlzLnByb3BzLmNvbnRhaW5lciEuY29udGVudF90eXBlICsgJ19zaG93XycgKyBvcmRlcn1cbiAgICAgICAgICAgIHBhcmVudD17dGhpc31cbiAgICAgICAgICAgIGZvcmNlT3JkZXI9e29yZGVyICUgdGhpcy5wcm9wcy5pdGVtc1Nob3dufVxuICAgICAgICAgICAgY29sdW1ucz17Mn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImhvcml6b250YWxFbGVtZW50IGxpc3RFbGVtZW50XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImltYWdlIGZvY3VzYWJsZVwiPjxpbWcgc3JjPXtpbWFnZX0gLz48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGl0bGUgZm9jdXNhYmxlXCI+e3RpdGxlfTwvZGl2PlxuICAgICAgICA8L05hdmlnYXRpb25Db250YWluZXI+XG5cblxuICAgIHByaXZhdGUgZ2V0VGl0bGUgPSAoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wcm9wcy5jb250YWluZXIhLmNvbnRlbnRfdHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZ2FsbGVyeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvY2FsaXplKCdHQUxMRVJZJyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NhcmRNb2R1bGVzL2xpc3QvbGlzdC5jb21wb25lbnQudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQge1xuICAgIENhcmQsIENhcmRDb250YWluZXJUeXBlRW51bSwgSGVscGVyLFxuICAgIEF3YXJkcyBhcyBBd2FyZHNDb250YWluZXIsIEF3YXJkc0RhdGEsIExpc3RpbmdEYXRhLFxufSBmcm9tIFwiU2VydmljZXNcIjtcbmltcG9ydCB7IElDYXJkTW9kdWxlUHJvcHMgfSBmcm9tIFwiQ2FyZE1vZHVsZXNcIjtcbmltcG9ydCB7IERpcmVjdGlvbkJ1dHRvbiwgVmVydGljYWxTY3JvbGwgfSBmcm9tIFwiQ29tcG9uZW50c1wiO1xuaW1wb3J0IHsgbmF2aWdhYmxlLCBzdGF0aWNzIH0gZnJvbSBcIkhPQ1wiO1xuXG5kZWNsYXJlIGNvbnN0IExvY2FsaXplOiBhbnk7XG5cbmludGVyZmFjZSBJQXdhcmRzUHJvcHMge1xuICAgIGNvbnRhaW5lcjogQXdhcmRzQ29udGFpbmVyO1xufVxuQHN0YXRpY3Moe1xuICAgIG1vZHVsZU5hbWU6IFwiYXdhcmRzXCIsXG4gICAgdmFsaWRhdGU6IChjYXJkOiBDYXJkLCBtb2R1bGVUeXBlOiBzdHJpbmcsIHBhcmVudDogYW55LCBwcm9wczogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IEhlbHBlci5nZXRDb250YWluZXIoY2FyZCwgJ2F3YXJkcycpIGFzIEF3YXJkc0NvbnRhaW5lcjtcbiAgICAgICAgLy8gTU9DS1VQXG4gICAgICAgIC8vIGNvbnRhaW5lciEuZGF0YSA9IFtcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICB0aXRsZTogXCJNZWpvciBhY3RvclwiLFxuICAgICAgICAvLyAgICAgICAgIHdpbm5lcjogW3t9LCB7fSwge31dLFxuICAgICAgICAvLyAgICAgICAgIG5vbWluZWU6IFt7fV0sXG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIHRpdGxlOiBcIk1lam9yIGFjdG9yXCIsXG4gICAgICAgIC8vICAgICAgICAgd2lubmVyOiBbe30sIHt9LCB7fV0sXG4gICAgICAgIC8vICAgICAgICAgbm9taW5lZTogW3t9XSxcbiAgICAgICAgLy8gICAgIH0sXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICAgdGl0bGU6IFwiTWVqb3IgYWN0b3JcIixcbiAgICAgICAgLy8gICAgICAgICB3aW5uZXI6IFt7fSwge30sIHt9XSxcbiAgICAgICAgLy8gICAgICAgICBub21pbmVlOiBbe31dLFxuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICB0aXRsZTogXCJNZWpvciBhY3RvclwiLFxuICAgICAgICAvLyAgICAgICAgIHdpbm5lcjogW3t9LCB7fSwge31dLFxuICAgICAgICAvLyAgICAgICAgIG5vbWluZWU6IFt7fV0sXG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIHRpdGxlOiBcIk1lam9yIGFjdG9yXCIsXG4gICAgICAgIC8vICAgICAgICAgd2lubmVyOiBbe30sIHt9LCB7fV0sXG4gICAgICAgIC8vICAgICAgICAgbm9taW5lZTogW3t9XSxcbiAgICAgICAgLy8gICAgIH0sXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICAgdGl0bGU6IFwiTWVqb3IgYWN0b3JcIixcbiAgICAgICAgLy8gICAgICAgICB3aW5uZXI6IFt7fSwge30sIHt9XSxcbiAgICAgICAgLy8gICAgICAgICBub21pbmVlOiBbe31dLFxuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gXSBhcyBhbnk7XG4gICAgICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLmRhdGEgJiYgY29udGFpbmVyLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgSW5zdGFudGlhdGVkID0gbmF2aWdhYmxlKEF3YXJkcyk7XG4gICAgICAgICAgICByZXR1cm4gKDxJbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICBjb250YWluZXI9e2NvbnRhaW5lcn1cbiAgICAgICAgICAgICAgICBwYXJlbnQ9e3BhcmVudH1cbiAgICAgICAgICAgICAgICBpc1Njcm9sbGFibGU9e3RydWV9XG4gICAgICAgICAgICAgICAgY2FyZD17Y2FyZH1cbiAgICAgICAgICAgICAgICBtb2R1bGVUeXBlPXttb2R1bGVUeXBlfSAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxufSlcbmV4cG9ydCBjbGFzcyBBd2FyZHMgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PElDYXJkTW9kdWxlUHJvcHMgJiBJQXdhcmRzUHJvcHMsIHt9PiB7XG4gICAgcHJpdmF0ZSBjb250YWluZXI6IEF3YXJkc0NvbnRhaW5lciB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIHNjcm9sbEJveDogSFRNTEVsZW1lbnQ7XG5cbiAgICBwdWJsaWMgcmVuZGVyKCk6IGFueSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmRNb2R1bGVBd2FyZHMgY2FyZE1vZHVsZVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxWZXJ0aWNhbFNjcm9sbCBwYXJlbnQ9e3RoaXN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkVGl0bGVcIj57dGhpcy5nZXRUaXRsZSgpfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhd2FyZHNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGFibGU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmNvbnRhaW5lciEuZGF0YS5tYXAoKGxpc3RJdGVtOiBBd2FyZHNEYXRhLCBpZHg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpbm5lck51bSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtLndpbm5lciBpbnN0YW5jZW9mIEFycmF5ICYmIGxpc3RJdGVtLndpbm5lci5sZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtLndpbm5lci5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vbWluZWVOdW0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0SXRlbS5ub21pbmVlIGluc3RhbmNlb2YgQXJyYXkgJiYgbGlzdEl0ZW0ubm9taW5lZS5sZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtLm5vbWluZWUubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub21pbmVlVGV4dHMgPSBub21pbmVlTnVtID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7bm9taW5lZU51bX0gJHtub21pbmVlTnVtID4gMSA/IExvY2FsaXplKFwiTk9NSU5FRV9QTFVSQUxcIikgOiBMb2NhbGl6ZShcIk5PTUlORUVfU0lOR1VMQVJcIil9YCA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxBd2FyZHNUZXh0cyA9IHdpbm5lck51bSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke3dpbm5lck51bX0gJHt3aW5uZXJOdW0gPiAxID8gTG9jYWxpemUoXCJXSU5ORVJfUExVUkFMXCIpIDogTG9jYWxpemUoXCJXSU5ORVJfU0lOR1VMQVJcIil9JHtub21pbmVlTnVtID4gMCA/IGAgLyAke25vbWluZWVUZXh0c31gIDogXCJcIn1gIDogbm9taW5lZVRleHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBrZXk9e2lkeH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIga2V5PVwibmFtZVwiIGNsYXNzTmFtZT1cImF3YXJkTmFtZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57bGlzdEl0ZW0udGl0bGV9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIga2V5PVwibnVtXCIgY2xhc3NOYW1lPVwiYXdhcmROdW1zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPnt0b3RhbEF3YXJkc1RleHRzfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvVmVydGljYWxTY3JvbGw+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRpdGxlID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gTG9jYWxpemUoJ0FXQVJEUycpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvY2FyZERldGFpbC9jYXJkTW9kdWxlcy9hd2FyZHMvYXdhcmRzLmNvbXBvbmVudC50c3giLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7XG4gICAgQ2FyZCwgQ2FyZENvbnRhaW5lclR5cGVFbnVtLCBIZWxwZXIsXG4gICAgTWFwIGFzIE1hcFZPLCBNYXBEYXRhIGFzIE1hcERhdGFWTywgTG9jYWxpemUsXG59IGZyb20gXCJTZXJ2aWNlc1wiO1xuaW1wb3J0IHsgSUNhcmRNb2R1bGVQcm9wcyB9IGZyb20gXCJDYXJkTW9kdWxlc1wiO1xuaW1wb3J0IHsgRGlyZWN0aW9uQnV0dG9uLCBWZXJ0aWNhbFNjcm9sbCB9IGZyb20gXCJDb21wb25lbnRzXCI7XG5pbXBvcnQgeyBuYXZpZ2FibGUsIHN0YXRpY3MgfSBmcm9tIFwiSE9DXCI7XG5cbmludGVyZmFjZSBJTWFwUHJvcHMge1xuICAgIGNvbnRhaW5lcjogTWFwVk87XG4gICAgbWFwRGF0YTogTWFwRGF0YVZPO1xufVxuQHN0YXRpY3Moe1xuICAgIG1vZHVsZU5hbWU6IFwibWFwXCIsXG4gICAgdmFsaWRhdGU6IChjYXJkOiBDYXJkLCBtb2R1bGVUeXBlOiBzdHJpbmcsIHBhcmVudDogYW55LCBwcm9wczogYW55KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW01hcF0gY2FyZDogXCIsIGNhcmQpO1xuICAgICAgICAvLyBObyBzZSBwdWVkZSBndWFyZGFyIGVsIGNvbnRhaW5lciBhcXXDrSwgcG9ycXVlIGVzIHVuIG3DqXRvZG8gZXN0w6F0aWNvLlxuICAgICAgICBjb25zdCBjb250YWluZXI6IE1hcFZPIHwgdW5kZWZpbmVkID0gSGVscGVyLmdldENvbnRhaW5lcihjYXJkLCAnbWFwJykgYXMgTWFwVk87XG4gICAgICAgIGlmIChjb250YWluZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgY29udGFpbmVyLmRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgY29udGFpbmVyLmRhdGEubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgY29udGFpbmVyLmRhdGFbMF0ubGF0aXR1ZGUgJiZcbiAgICAgICAgICAgIGNvbnRhaW5lci5kYXRhWzBdLmxvbmdpdHVkZSkge1xuICAgICAgICAgICAgY29uc3QgSW5zdGFudGlhdGVkID0gbmF2aWdhYmxlKE1hcCk7XG4gICAgICAgICAgICByZXR1cm4gKDxJbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgICAgY29udGFpbmVyPXtjb250YWluZXJ9XG4gICAgICAgICAgICAgICAgbWFwRGF0YT17Y29udGFpbmVyLmRhdGFbMF19XG4gICAgICAgICAgICAgICAgcGFyZW50PXtwYXJlbnR9XG4gICAgICAgICAgICAgICAgY2FyZD17Y2FyZH1cbiAgICAgICAgICAgICAgICBtb2R1bGVUeXBlPXttb2R1bGVUeXBlfSAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxufSlcbmV4cG9ydCBjbGFzcyBNYXAgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PElDYXJkTW9kdWxlUHJvcHMgJiBJTWFwUHJvcHMsIHt9PiB7XG4gICAgcHVibGljIHJlbmRlcigpOiBhbnkge1xuICAgICAgICBjb25zdCB0ZXh0VGl0bGUgPSB0aGlzLmdldFRpdGxlKCk7XG4gICAgICAgIGNvbnN0IHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tIH0gPSB0aGlzLnByb3BzLm1hcERhdGE7XG4gICAgICAgIGxldCBtYXBVcmwgPSBgaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL3N0YXRpY21hcD9jZW50ZXI9JHtsYXRpdHVkZX0sJHtsb25naXR1ZGV9JnNpemU9MzAweDE2OGA7XG4gICAgICAgIGNvbnN0IGFwcGxpZWRab29tID0gcGFyc2VJbnQoYCR7em9vbX1gLCAxMCk7XG4gICAgICAgIGlmIChhcHBsaWVkWm9vbSkge1xuICAgICAgICAgICAgbWFwVXJsICs9IGAmem9vbT0ke2FwcGxpZWRab29tfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZE1vZHVsZU1hcCBjYXJkTW9kdWxlXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAge3RleHRUaXRsZSA/IDxkaXYgY2xhc3NOYW1lPVwiY2FyZFRpdGxlXCI+e3RleHRUaXRsZX08L2Rpdj4gOiBudWxsfVxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1hcFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9e21hcFVybH0gY2xhc3NOYW1lPVwibWFwVGh1bWJuYWlsXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRpdGxlKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMb2NhbGl6ZSgnTE9DQVRJT04nKTtcbiAgICAgICAgLypcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BzLmNvbnRhaW5lciEuY29udGVudF90eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdsb2NhdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvY2FsaXplKCdMT0NBVElPTicpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSovXG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NhcmRNb2R1bGVzL21hcC9tYXAuY29tcG9uZW50LnRzeCIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyBIZWFkZXIsIFRleHQsIFRhYmxlLCBBd2FyZHMsIExpc3QsIE1hcCB9IGZyb20gJ0NhcmRNb2R1bGVzJztcbmltcG9ydCB7IENhcmQsIENhcmRDb250YWluZXJUeXBlRW51bSB9IGZyb20gXCJTZXJ2aWNlc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElDYXJkTW9kdWxlUHJvcHMge1xuICAgIGNhcmQ6IENhcmQ7XG4gICAgbW9kdWxlVHlwZTogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgY2FyZE1vZHVsZUNsYXNzZXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBSZWFjdC5Db21wb25lbnRDbGFzczxJQ2FyZE1vZHVsZVByb3BzPixcbn0gPSB7XG4gICAgICAgIEhlYWRlcixcbiAgICAgICAgQnV0dG9uSGVhZGVyOiBIZWFkZXIsXG4gICAgICAgIE1vdmllSGVhZGVyOiBIZWFkZXIsXG4gICAgICAgIERlc2NyaXB0aW9uOiBUZXh0LFxuICAgICAgICBCaW9ncmFwaHk6IFRleHQsXG4gICAgICAgIFJlZmVyZW5jZTogVGV4dCxcbiAgICAgICAgRnVsbEN1cmlvc2l0eTogVGV4dCxcbiAgICAgICAgT3ZlcnZpZXc6IFRleHQsXG4gICAgICAgIEdhbGxlcnk6IExpc3QsXG4gICAgICAgIFNob3A6IExpc3QsXG4gICAgICAgIFRyYXZlbFNob3A6IExpc3QsXG4gICAgICAgIERpcmVjdG9yczogTGlzdCxcbiAgICAgICAgU2Vhc29uczogTGlzdCxcbiAgICAgICAgRmlsbW9ncmFwaHk6IExpc3QsXG4gICAgICAgIENhc3Q6IExpc3QsXG4gICAgICAgIEFwcGVhcnNJbkxvY2F0aW9uOiBMaXN0LFxuICAgICAgICBDb21wbGV0ZVRoZURlY286IExpc3QsXG4gICAgICAgIFNwZWNpZmljYXRpb25zOiBUYWJsZSxcbiAgICAgICAgQmFzaWNJbmZvOiBUYWJsZSxcbiAgICAgICAgQXdhcmRzTW9kdWxlTGlzdDogQXdhcmRzLFxuICAgICAgICBNYXBNb2R1bGU6IE1hcCxcbiAgICB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9jYXJkRGV0YWlsL2NhcmRNb2R1bGVzL2NhcmREZXRhaWwubW9kdWxlcy50c3giLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IERpdmVBUElDbGFzcywgQ2FyZCwgSGVscGVyIH0gZnJvbSBcIlNlcnZpY2VzXCI7XG5pbXBvcnQgeyBMb2FkaW5nLCBDYXJkRGV0YWlsIH0gZnJvbSBcIkNvbXBvbmVudHNcIjtcbmltcG9ydCB7IG5hdmlnYWJsZSB9IGZyb20gXCJIT0NcIjtcblxuZGVjbGFyZSBjb25zdCBEaXZlQVBJOiBEaXZlQVBJQ2xhc3M7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNhcmREZXRhaWxDb250YWluZXJQcm9wcyB7XG4gICAgY2FyZElkOiBzdHJpbmc7XG4gICAgdmVyc2lvbjogc3RyaW5nO1xuICAgIHBhcmVudDogYW55XG59XG5leHBvcnQgaW50ZXJmYWNlIElDYXJkRGV0YWlsQ29udGFpbmVyU3RhdGUge1xuICAgIHN0YXR1czogXCJMT0FESU5HXCIgfCBcIkxPQURFRFwiO1xuICAgIGNhcmQ/OiBDYXJkO1xufVxuZXhwb3J0IGNsYXNzIENhcmREZXRhaWxDb250YWluZXJDbGFzcyBleHRlbmRzXG4gICAgUmVhY3QuUHVyZUNvbXBvbmVudDxJQ2FyZERldGFpbENvbnRhaW5lclByb3BzLCBJQ2FyZERldGFpbENvbnRhaW5lclN0YXRlPiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7IHN0YXR1czogXCJMT0FESU5HXCIsIGNhcmQ6IHVuZGVmaW5lZCB9O1xuICAgIH1cbiAgICBwdWJsaWMgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUuc3RhdHVzID09PSBcIkxPQURJTkdcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgRGl2ZUFQSS5nZXRDYXJkVmVyc2lvbih7IGNhcmRJZDogdGhpcy5wcm9wcy5jYXJkSWQsIHZlcnNpb246IHRoaXMucHJvcHMudmVyc2lvbiwgcHJvZHVjdHM6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGNhcmQ6IENhcmQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY2FyZF0gJHtjYXJkLnRpdGxlfTogYCwgY2FyZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgLi4udGhpcy5zdGF0ZSwgc3RhdHVzOiBcIkxPQURFRFwiLCBjYXJkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgRGl2ZUFQSS5nZXRDYXJkLypWZXJzaW8qbiovKHsgY2FyZElkOiB0aGlzLnByb3BzLmNhcmRJZCwvKiB2ZXJzaW9uOiB0aGlzLnByb3BzLnZlcnNpb24sKi8gcHJvZHVjdHM6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGNhcmQ6IENhcmQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY2FyZF0gJHtjYXJkLnRpdGxlfTogYCwgY2FyZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgLi4udGhpcy5zdGF0ZSwgc3RhdHVzOiBcIkxPQURFRFwiLCBjYXJkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHJlbmRlcigpOiBhbnkge1xuICAgICAgICBjb25zdCBzdWJjb21wb25lbnQgPSAhdGhpcy5zdGF0ZSB8fCB0aGlzLnN0YXRlLnN0YXR1cyAhPT0gXCJMT0FERURcIiA/XG4gICAgICAgICAgICA8TG9hZGluZyAvPiA6XG4gICAgICAgICAgICA8Q2FyZERldGFpbCBwYXJlbnQ9e3RoaXN9IGNhcmQ9e3RoaXMuc3RhdGUuY2FyZH0gY29sdW1ucz17MX0gbmF2Q2xhc3M9XCJjYXJkRGV0YWlsTmF2XCIgaXNEZWZhdWx0PXt0cnVlfSAvPjtcbiAgICAgICAgcmV0dXJuIHN1YmNvbXBvbmVudDtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBDYXJkRGV0YWlsQ29udGFpbmVyID0gbmF2aWdhYmxlKENhcmREZXRhaWxDb250YWluZXJDbGFzcyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb250YWluZXJzL2NhcmREZXRhaWwvY2FyZERldGFpbC5jb250YWluZXIudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBOYXZpZ2F0aW9uQ29udGFpbmVyIH0gZnJvbSBcIkNvbXBvbmVudHNcIjtcblxuaW50ZXJmYWNlIElCT01Qcm9wcyB7XG4gICAgbmF2aWdhdGlvblBhcmVudDogYW55O1xufTtcbmV4cG9ydCBjbGFzcyBCb3R0b21PdmVybGF5TWVzc2FnZSBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8SUJPTVByb3BzLCB7IGhpZGRlbjogYm9vbGVhbiB9PiB7XG4gICAgY29uc3RydWN0b3IocHJvcHM6IElCT01Qcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7IGhpZGRlbjogZmFsc2UgfTtcbiAgICB9XG4gICAgcHVibGljIHJlbmRlcigpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSAmJiB0aGlzLnN0YXRlLmhpZGRlbiA/IG51bGwgOiB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgfVxuICAgIHByaXZhdGUgZ2V0Q2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJvdHRvbU1lc3NhZ2UgZmlsbFBhcmVudFwiPlxuICAgICAgICAgICAgICAgIDxOYXZpZ2F0aW9uQ29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIG1vZGFsPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ9e3RoaXMucHJvcHMubmF2aWdhdGlvblBhcmVudH1cbiAgICAgICAgICAgICAgICAgICAgaXNEZWZhdWx0PXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGVQYXJlbnQ9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnM9ezF9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1lc3NhZ2VDb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2xvc2VDb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TmF2aWdhdGlvbkNvbnRhaW5lciBjbGFzc05hbWU9XCJjYXJvdXNlbEJ1dHRvbiBjYXJvdXNlbENsb3NlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50PXt0aGlzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RlZmF1bHQ9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM9ezF9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBoaWRkZW46IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvTmF2aWdhdGlvbkNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvTmF2aWdhdGlvbkNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29udGFpbmVycy91aS9ib3R0b21PdmVybGF5TWVzc2FnZS5jb250YWluZXIudHN4IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29ubmVjdCwgTWFwRGlzcGF0Y2hUb1Byb3BzT2JqZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCB7IG5hdmlnYWJsZSwgSU5hdmlnYWJsZVByb3BzIH0gZnJvbSAnSE9DJztcbmltcG9ydCB7IExvYWRpbmcsIE5hdmlnYXRpb25Db250YWluZXIsIE1pbmlDYXJkTGlzdCB9IGZyb20gJ0NvbXBvbmVudHMnO1xuaW1wb3J0IHsgSVN0YXRlLCBJU3luY1N0YXRlLCBJTmF2U3RhdGUgfSBmcm9tICdSZWR1Y2Vycyc7XG5pbXBvcnQgeyBTeW5jQWN0aW9ucywgSVN5bmNBY3Rpb25zLCBVSUFjdGlvbnMsIElVSUFjdGlvbnMgfSBmcm9tICdBY3Rpb25zJztcbmltcG9ydCB7IExvY2FsaXplLCBDYXJkLCBSZWxhdGlvbk1vZHVsZSB9IGZyb20gJ1NlcnZpY2VzJztcbmltcG9ydCB7IFNVUFBPUlRFRF9DQVJEX1RZUEVTIH0gZnJvbSAnQ29uc3RhbnRzJztcbmltcG9ydCB7IEJvdHRvbU92ZXJsYXlNZXNzYWdlIH0gZnJvbSBcIkNvbnRhaW5lcnNcIjtcblxuZXhwb3J0IGNsYXNzIENhcm91c2VsQ2xhc3NcbiAgICBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8eyBzdGF0ZTogSVN5bmNTdGF0ZSB9ICYgSVN5bmNBY3Rpb25zICYgSU5hdmlnYWJsZVByb3BzICYgSU5hdlN0YXRlICZcbiAgICB7IHVpQWN0aW9uczogTWFwRGlzcGF0Y2hUb1Byb3BzT2JqZWN0IH0sIHsgcmV3aW5kZWQ6IGJvb2xlYW4gfT4ge1xuICAgIHByaXZhdGUgaW50ZXJ2YWw6IGFueTtcbiAgICBwcml2YXRlIGNodW5rUmVxdWVzdGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBidXR0b25zQ29udGFpbmVyOiBhbnk7XG4gICAgcHJpdmF0ZSBhY3RpdmVGaWx0ZXJzOiBhbnlbXTtcbiAgICBwcml2YXRlIGN1cnJlbnRTY2VuZVRleHQgPSBMb2NhbGl6ZShcIkNVUlJFTlRfU0NFTkVcIik7XG4gICAgcHJpdmF0ZSBhZE1lc3NhZ2VDb250ZW50OiBKU1guRWxlbWVudDtcbiAgICBwcml2YXRlIGVuZE1lc3NhZ2VDb250ZW50OiBKU1guRWxlbWVudDtcbiAgICBwcml2YXRlIG9mZk1lc3NhZ2VDb250ZW50OiBKU1guRWxlbWVudDtcbiAgICBwcml2YXRlIHJlYWR5TWVzc2FnZUNvbnRlbnQ6IEpTWC5FbGVtZW50O1xuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBhbnkpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0geyByZXdpbmRlZDogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5jbG9zZUNhcm91c2VsID0gdGhpcy5jbG9zZUNhcm91c2VsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFRpbWUgPSB0aGlzLmdldEN1cnJlbnRUaW1lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRNZXNzYWdlQ29udGVudCA9IChcbiAgICAgICAgICAgIDxkaXYga2V5PVwiYWRNZXNzYWdlQ29udGVudFwiIGNsYXNzTmFtZT1cImZpbGxQYXJlbnQgYWRNZXNzYWdlIGNhcm91c2VsTWVzc2FnZUNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFkTWVzc2FnZUxlZnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGgxPntMb2NhbGl6ZShcIlBJWlpBX09SX1BPUF9DT1JOXCIpfTwvaDE+XG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQxXCI+e0xvY2FsaXplKFwiV0VfUkVDT01NRU5EXCIpfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dDJcIj57TG9jYWxpemUoXCJNQUtFX1BPUF9DT1JOXCIpfTwvcD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFkTWVzc2FnZVJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxoMT57TG9jYWxpemUoXCJUVkdSSURfQ09NTUVSQ0lBTF9UWFRcIil9PC9oMT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZW5kTWVzc2FnZUNvbnRlbnQgPSAoXG4gICAgICAgICAgICA8ZGl2IGtleT1cImVuZE1lc3NhZ2VDb250ZW50XCIgY2xhc3NOYW1lPVwiZmlsbFBhcmVudCBlbmRNZXNzYWdlIGNhcm91c2VsTWVzc2FnZUNvbnRlbnQgY2VudGVyZWRNZXNzYWdlXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtZXNzYWdlQ2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxoMT57TG9jYWxpemUoXCJFVkVSWVRISU5HX0VORFwiKX08L2gxPlxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0MVwiPntMb2NhbGl6ZShcIk1PVklFX0VOREVEXCIpfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJidXR0b25zQ29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TmF2aWdhdGlvbkNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdlbmVyaWNCdG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudD17dGhpc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RlZmF1bHQ9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17MX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9XCJtZXNzYWdlQ2xvc2VDYXJvdXNlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnVpQWN0aW9ucy5vcGVuKHsgdG9wOiBcIlRWXCIsIGJvdHRvbTogXCJHUklEXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgID57TG9jYWxpemUoXCJPS0FZXCIpfTwvTmF2aWdhdGlvbkNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLm9mZk1lc3NhZ2VDb250ZW50ID0gKFxuICAgICAgICAgICAgPGRpdiBrZXk9XCJvZmZNZXNzYWdlQ29udGVudFwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmlsbFBhcmVudCBvZmZNZXNzYWdlQ29udGVudCBjYXJvdXNlbE1lc3NhZ2VDb250ZW50IGNlbnRlcmVkTWVzc2FnZVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWVzc2FnZUNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICA8aDE+e0xvY2FsaXplKFwiRVZFUllUSElOR19FTkRcIil9PC9oMT5cbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dDFcIj57TG9jYWxpemUoXCJNT1ZJRV9PRkZcIil9PC9wPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbnNDb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxOYXZpZ2F0aW9uQ29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZ2VuZXJpY0J0blwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PVwibWVzc2FnZUNsb3NlQ2Fyb3VzZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudD17dGhpc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RlZmF1bHQ9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17MX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMudWlBY3Rpb25zLm9wZW4oeyB0b3A6IFwiVFZcIiwgYm90dG9tOiBcIkdSSURcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPntMb2NhbGl6ZShcIk9LQVlcIil9PC9OYXZpZ2F0aW9uQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucmVhZHlNZXNzYWdlQ29udGVudCA9IChcbiAgICAgICAgICAgIDxkaXYga2V5PVwib2ZmTWVzc2FnZUNvbnRlbnRcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZpbGxQYXJlbnQgcmVhZHlNZXNzYWdlQ29udGVudCBjYXJvdXNlbE1lc3NhZ2VDb250ZW50IGNlbnRlcmVkTWVzc2FnZVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWVzc2FnZUNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICA8aDE+e0xvY2FsaXplKFwiTElHSFRTX0NBTUVSQVwiKX08L2gxPlxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0MVwiPntMb2NhbGl6ZShcIldFX0FSRV9MT0FESU5HXCIpfTwvcD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wczogUmVhZG9ubHk8eyBzdGF0ZTogSVN5bmNTdGF0ZTsgfVxuICAgICAgICAmIElTeW5jQWN0aW9ucyAmIElOYXZpZ2FibGVQcm9wcyAmIElOYXZTdGF0ZT4pIHtcbiAgICAgICAgLyppZiAobmV4dFByb3BzLnN0YXRlLnR5cGUgPT09IFwiU09DS0VUXCIgJiYgbmV4dFByb3BzLnN0YXRlLnNvY2tldFN0YXR1cyAhPT0gdGhpcy5wcm9wcy5zdGF0ZS5zb2NrZXRTdGF0dXNcbiAgICAgICAgICAgICYmIG5leHRQcm9wcy5zdGF0ZS5zb2NrZXRTdGF0dXMgPT09ICdDT05ORUNURUQnKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmRhdGFTeW5jKG5leHRQcm9wcy5zdGF0ZS5tb3ZpZUlkKTtcbiAgICAgICAgfSovXG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5zeW5jQ2hhbm5lbCgpO1xuICAgICAgICB0aGlzLmFjdGl2ZUZpbHRlcnMgPSBbdGhpcy5hbGxDYXRlZ29yaWVzRmlsdGVyXTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgcHVibGljIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICAvLyB0aGlzLnByb3BzLnNldFNlbGVjdGVkT25TY2VuZUNoYW5nZShmYWxzZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFN0YXRlID0gKCk6IElTeW5jU3RhdGUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zdGF0ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVuZGVyKCk6IGFueSB7XG4gICAgICAgIGxldCBjYXJkczogQXJyYXk8Q2FyZCB8IFJlbGF0aW9uTW9kdWxlPiA9XG4gICAgICAgICAgICB0aGlzLnByb3BzLnN0YXRlLmNhcmRzICE9PSB1bmRlZmluZWQgPyB0aGlzLnByb3BzLnN0YXRlLmNhcmRzIDogW107XG4gICAgICAgIC8vIGNvbnN0IHNjZW5lOiBJQ2h1bmtTY2VuZSA9IHRoaXMucHJvcHMuc3RhdGUuc2NlbmU7XG5cbiAgICAgICAgLy8gRmlsdGVyIGJ5IG9mZnNldCBhbmQgZ2V0dGluZyByZWxhdGlvbiBjYXJkcyB0byB0aGUgZmlyc3QgbGV2ZWwuXG4gICAgICAgIGNhcmRzID0gY2FyZHMuZmlsdGVyKChjYXJkOiBDYXJkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FyZCAmJiBjYXJkLnR5cGUgJiZcbiAgICAgICAgICAgICAgICBTVVBQT1JURURfQ0FSRF9UWVBFUy5pbmRleE9mKGNhcmQudHlwZSkgPiAtMSAmJlxuICAgICAgICAgICAgICAgIGNhcmQudHlwZSAhPT0gJ3BlcnNvbic7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lckNhcm91c2VsIGZpbGxQYXJlbnRcIj5cbiAgICAgICAgICAgICAgICA8TmF2aWdhdGlvbkNvbnRhaW5lciBrZXk9XCJidXR0b25Db250YWluZXJcIlxuICAgICAgICAgICAgICAgICAgICByZWY9eyhlbDogYW55KSA9PiB7IGlmIChlbCkgeyB0aGlzLmJ1dHRvbnNDb250YWluZXIgPSBlbC5nZXRXcmFwcGVkSW5zdGFuY2UoKS5yZWZDb21wb25lbnQ7IH0gfX1cbiAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlUGFyZW50PXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50PXt0aGlzfVxuICAgICAgICAgICAgICAgICAgICBmb3JjZUZpcnN0PXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zPXsxfT5cbiAgICAgICAgICAgICAgICAgICAge3RoaXMuYnV0dG9uc0NvbnRhaW5lciA/IHRoaXMuZ2V0QnV0dG9ucygpIDogXCJcIn1cbiAgICAgICAgICAgICAgICA8L05hdmlnYXRpb25Db250YWluZXI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkc1wiPlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJkcy5sZW5ndGggPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMb2FkaW5nIC8+IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TWluaUNhcmRMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzPXtjYXJkc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92aWVJZD17dGhpcy5nZXRTdGF0ZSgpLm1vdmllSWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldE1vdmllVGltZT17dGhpcy5nZXRDdXJyZW50VGltZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50PXt0aGlzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zPXsxfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2Ake3RoaXMucHJvcHMuc3RhdGUubW92aWVJZH0jJHtEYXRlLm5vd31gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cE5hbWU9XCJNaW5pQ2FyZExpc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZE9uU2NlbmVDaGFuZ2U9e3RoaXMucHJvcHMuc2V0U2VsZWN0ZWRPblNjZW5lQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNTZWxlY3RlZE9uQ2hhbmdlU2NlbmU9e3RoaXMucHJvcHMuc3RhdGUuc2VsZWN0ZWRPblNjZW5lQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICB7dGhpcy5nZXRNZXNzYWdlRm9yQ2Fyb3VzZWwoKX1cbiAgICAgICAgICAgIDwvZGl2ID5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEN1cnJlbnRUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zdGF0ZS5jdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEJ1dHRvbnMoKTogSlNYLkVsZW1lbnQge1xuICAgICAgICBsZXQgY3VycmVudFRpbWVJblNlY3MgPSB0aGlzLnByb3BzLnN0YXRlLmN1cnJlbnRUaW1lO1xuICAgICAgICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IoY3VycmVudFRpbWVJblNlY3MgLyAzNjAwKTtcbiAgICAgICAgY3VycmVudFRpbWVJblNlY3MgJT0gMzYwMDtcbiAgICAgICAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoY3VycmVudFRpbWVJblNlY3MgLyA2MCk7XG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBwYXJzZUludCgoY3VycmVudFRpbWVJblNlY3MgJSA2MCkudG9GaXhlZCgwKSwgMTApO1xuXG4gICAgICAgIGxldCBidXR0b25Db3VudCA9IDc7XG4gICAgICAgIGlmICgwKSB7IC8vIFRPRE86IENoZWNrIGlmIHByZXYgYnV0dG9uIG5lZWRlZFxuICAgICAgICAgICAgYnV0dG9uQ291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMCkgeyAvLyBUT0RPOiBDaGVjayBpZiBuZXh0IGJ1dHRvbiBuZWVkZWRcbiAgICAgICAgICAgIGJ1dHRvbkNvdW50LS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucmV3aW5kZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBidXR0b25Db3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVGb3JtYXR0ZWQgPSBgJHtob3VycyA8IDEwID8gXCIwXCIgKyBob3VycyA6IGhvdXJzfTpgXG4gICAgICAgICAgICArIGAke21pbnV0ZXMgPCAxMCA/IFwiMFwiICsgbWludXRlcyA6IG1pbnV0ZXN9OiR7c2Vjb25kcyA8IDEwID8gXCIwXCIgKyBzZWNvbmRzIDogc2Vjb25kc31gO1xuICAgICAgICBjb25zdCBidXR0b25zVG9SZW5kZXIgPSBbXTtcbiAgICAgICAgYnV0dG9uc1RvUmVuZGVyLnB1c2goPE5hdmlnYXRpb25Db250YWluZXIga2V5PVwiY2Fyb3VzZWxDbG9zZVwiIGNsYXNzTmFtZT1cImNhcm91c2VsQnV0dG9uIGJjdEJ1dHRvbiBjbG9zZVwiXG4gICAgICAgICAgICBmb3JjZU9yZGVyPXswfVxuICAgICAgICAgICAgcGFyZW50PXt0aGlzLmJ1dHRvbnNDb250YWluZXJ9XG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmNsb3NlQ2Fyb3VzZWx9XG4gICAgICAgID5cbiAgICAgICAgPC9OYXZpZ2F0aW9uQ29udGFpbmVyPik7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGlkPVwiY2Fyb3VzZWxCdXR0b25zXCIgY2xhc3NOYW1lPVwiYm90dG9tQ29udGFpbmVyVG9wQnV0dG9uc1wiPlxuICAgICAgICAgICAgICAgIHtidXR0b25zVG9SZW5kZXJ9XG4gICAgICAgICAgICA8L2Rpdj4pO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xvc2VDYXJvdXNlbCgpIHtcbiAgICAgICAgdGhpcy5wcm9wcy51aUFjdGlvbnMub3Blbih7IHRvcDogXCJUVlwiLCBib3R0b206IFwiR1JJRFwiIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TWVzc2FnZUZvckNhcm91c2VsKCkge1xuICAgICAgICBsZXQgbWVzc2FnZUNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxTdGF0dXMgPSB0aGlzLmdldFN0YXRlKCkuY2hhbm5lbFN0YXR1cztcbiAgICAgICAgaWYgKGNoYW5uZWxTdGF0dXMgPT09IFwicGF1c2VkXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VDb250ZW50ID0gdGhpcy5hZE1lc3NhZ2VDb250ZW50O1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxTdGF0dXMgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VDb250ZW50ID0gdGhpcy5lbmRNZXNzYWdlQ29udGVudDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsU3RhdHVzID09PSBcIm9mZlwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlQ29udGVudCA9IHRoaXMub2ZmTWVzc2FnZUNvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbFN0YXR1cyA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlQ29udGVudCA9IHRoaXMucmVhZHlNZXNzYWdlQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBNZXNzYWdlIExvZ2ljXG4gICAgICAgIC8vIFNob3cgbWVzc2FnZSBvbmx5IGlmIG5vdCBoYXMgYmVlbiBjbG9zZWQgYmVmb3JlLFxuICAgICAgICAvLyBhbmQgaWYgdGhlIGNhcm91c2VsIGl0cyBzeW5jZWQgb24gdGhlIGNvcnJlY3QgdGltZSAobm90IHJld2luZClcbiAgICAgICAgaWYgKG1lc3NhZ2VDb250ZW50IC8qJiYgb25UaW1lICYmICFtZXNzYWdlRGlzY2FyZGVkKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPEJvdHRvbU92ZXJsYXlNZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIGtleT17YGJvdHRvbU1lc3NhZ2UjJHt0aGlzLnByb3BzLnN0YXRlLnRpbWVNb3ZpZVN5bmNlZH0jJHtjaGFubmVsU3RhdHVzfWB9XG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25QYXJlbnQ9e3RoaXN9PlxuICAgICAgICAgICAgICAgICAgICB7bWVzc2FnZUNvbnRlbnR9XG4gICAgICAgICAgICAgICAgPC9Cb3R0b21PdmVybGF5TWVzc2FnZT5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDQVJPVVNFTCBGSUxURVJTXG4gICAgcHJpdmF0ZSBhbGxDYXRlZ29yaWVzRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IChzdGF0ZTogSVN0YXRlKTogeyBzdGF0ZTogSVN5bmNTdGF0ZSB9ID0+ICh7IHN0YXRlOiB7IC4uLnN0YXRlLmNhcm91c2VsIH0gfSk7XG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSAoZGlzcGF0Y2g6IGFueSk6IGFueSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYmluZEFjdGlvbkNyZWF0b3JzKFN5bmNBY3Rpb25zLCBkaXNwYXRjaCksXG4gICAgICAgIHVpQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKFVJQWN0aW9ucywgZGlzcGF0Y2gpLFxuICAgIH07XG59O1xuXG5leHBvcnQgY29uc3QgQ2Fyb3VzZWwgPSBuYXZpZ2FibGUoY29ubmVjdChcbiAgICBtYXBTdGF0ZVRvUHJvcHMsXG4gICAgbWFwRGlzcGF0Y2hUb1Byb3BzLFxuKShDYXJvdXNlbENsYXNzKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb250YWluZXJzL2Nhcm91c2VsL2Nhcm91c2VsLmNvbnRhaW5lci50c3giLCJleHBvcnQgKiBmcm9tICcuL2xheW91dC9sYXlvdXQuY29udGFpbmVyJztcbmV4cG9ydCAqIGZyb20gJy4vQXBwL2FwcCc7XG5leHBvcnQgKiBmcm9tICcuL2NhcmRNb2R1bGVMaXN0L2NhcmRNb2R1bGVMaXN0LmNvbnRhaW5lcic7XG5leHBvcnQgKiBmcm9tICcuL2NhcmREZXRhaWwvY2FyZERldGFpbC5jb250YWluZXInO1xuZXhwb3J0ICogZnJvbSAnLi91aS9ib3R0b21PdmVybGF5TWVzc2FnZS5jb250YWluZXInO1xuZXhwb3J0ICogZnJvbSAnLi9jYXJvdXNlbC9jYXJvdXNlbC5jb250YWluZXInO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29udGFpbmVycy9pbmRleC50c3giXSwic291cmNlUm9vdCI6IiJ9